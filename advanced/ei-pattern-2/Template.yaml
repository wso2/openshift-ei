  
# Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

apiVersion: v1
kind: Template
metadata:
  name: ei-pattern-2
  annotations:
    openshift.io/display-name: WSO2 Enterprice Intigrater Deployment - Pattern 2
    description: >-
      WSO2 Enterprise Integrator (WSO2 EI) is a comprehensive integration solution that enables communication among various,
      disparate applications. Instead of having your applications communicate directly with each other in all their various
      formats, each application simply communicates with WSO2 EI, which acts mainly as an ESB to handle transforming and routing
      the messages to their appropriate destinations.

      This template create resources for WSO2 Enterprice Intigrater Pattern 2 deployment.
    openshift.io/documentation-url: https://docs.wso2.com/display/EI611/WSO2+Enterprise+Integrator+Documentation
    openshift.io/provider-display-name: WSO2, Inc.
    openshift.io/support-url: https://wso2.com/enterprise-integrator/6.6.0
objects:
# ConfigMap wso2ei-rdbms-service-mysql-configuration
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: wso2ei-rdbms-service-mysql-configuration
  data:
    mysql.cnf: |-
      [mysqld]
      max_connections = 10000

# ConfigMap wso2ei-rdbms-service-mysql-initialization
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: wso2ei-rdbms-service-mysql-initialization
  data:
    init.sql: |-
      DROP DATABASE IF EXISTS WSO2EI_USER_DB;
      DROP DATABASE IF EXISTS WSO2EI_INTEGRATOR_CONFIG_GOV_DB;
      DROP DATABASE IF EXISTS WSO2_CLUSTER_DB;
      DROP DATABASE IF EXISTS EI_ANALYTICS;
      DROP DATABASE IF EXISTS WSO2_PERSISTENCE_DB;
      DROP DATABASE IF EXISTS WSO2EI_MB_DB;
      
      CREATE DATABASE WSO2EI_USER_DB;
      CREATE DATABASE WSO2EI_INTEGRATOR_CONFIG_GOV_DB;
      CREATE DATABASE WSO2_CLUSTER_DB;
      CREATE DATABASE EI_ANALYTICS;
      CREATE DATABASE WSO2_PERSISTENCE_DB;
      CREATE DATABASE WSO2EI_MB_DB;
      
      
      CREATE USER IF NOT EXISTS 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      GRANT ALL ON WSO2EI_USER_DB.* TO 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      GRANT ALL ON WSO2EI_INTEGRATOR_CONFIG_GOV_DB.* TO 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      GRANT ALL ON WSO2_CLUSTER_DB.* TO 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      GRANT ALL ON EI_ANALYTICS.* TO 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      GRANT ALL ON WSO2_PERSISTENCE_DB.* TO 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      GRANT ALL ON WSO2EI_MB_DB.* TO 'wso2carbon'@'%' IDENTIFIED BY 'wso2carbon';
      
      USE WSO2EI_USER_DB;
      
      -- ################################
      -- USER MANAGER TABLES
      -- ################################
      
      CREATE TABLE UM_TENANT (
      			UM_ID INTEGER NOT NULL AUTO_INCREMENT,
      	        UM_DOMAIN_NAME VARCHAR(255) NOT NULL,
                  UM_EMAIL VARCHAR(255),
                  UM_ACTIVE BOOLEAN DEFAULT FALSE,
      	        UM_CREATED_DATE TIMESTAMP NOT NULL,
      	        UM_USER_CONFIG LONGBLOB,
      			PRIMARY KEY (UM_ID),
      			UNIQUE(UM_DOMAIN_NAME)
      )ENGINE INNODB;
      
      CREATE TABLE UM_DOMAIN(
                  UM_DOMAIN_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_DOMAIN_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (UM_DOMAIN_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE UNIQUE INDEX INDEX_UM_TENANT_UM_DOMAIN_NAME
                          ON UM_TENANT (UM_DOMAIN_NAME);
      
      CREATE TABLE UM_USER (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_USER_NAME VARCHAR(255) NOT NULL,
                   UM_USER_PASSWORD VARCHAR(255) NOT NULL,
                   UM_SALT_VALUE VARCHAR(31),
                   UM_REQUIRE_CHANGE BOOLEAN DEFAULT FALSE,
                   UM_CHANGED_TIME TIMESTAMP NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID),
                   UNIQUE(UM_USER_NAME, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_SYSTEM_USER (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_USER_NAME VARCHAR(255) NOT NULL,
                   UM_USER_PASSWORD VARCHAR(255) NOT NULL,
                   UM_SALT_VALUE VARCHAR(31),
                   UM_REQUIRE_CHANGE BOOLEAN DEFAULT FALSE,
                   UM_CHANGED_TIME TIMESTAMP NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID),
                   UNIQUE(UM_USER_NAME, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_ROLE (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_ROLE_NAME VARCHAR(255) NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
      		UM_SHARED_ROLE BOOLEAN DEFAULT FALSE,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID),
                   UNIQUE(UM_ROLE_NAME, UM_TENANT_ID)
      )ENGINE INNODB;
      
      
      CREATE TABLE UM_MODULE(
      	UM_ID INTEGER  NOT NULL AUTO_INCREMENT,
      	UM_MODULE_NAME VARCHAR(100),
      	UNIQUE(UM_MODULE_NAME),
      	PRIMARY KEY(UM_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_MODULE_ACTIONS(
      	UM_ACTION VARCHAR(255) NOT NULL,
      	UM_MODULE_ID INTEGER NOT NULL,
      	PRIMARY KEY(UM_ACTION, UM_MODULE_ID),
      	FOREIGN KEY (UM_MODULE_ID) REFERENCES UM_MODULE(UM_ID) ON DELETE CASCADE
      )ENGINE INNODB;
      
      CREATE TABLE UM_PERMISSION (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_RESOURCE_ID VARCHAR(255) NOT NULL,
                   UM_ACTION VARCHAR(255) NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
      		UM_MODULE_ID INTEGER DEFAULT 0,
      			       UNIQUE(UM_RESOURCE_ID,UM_ACTION, UM_TENANT_ID),
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE INDEX INDEX_UM_PERMISSION_UM_RESOURCE_ID_UM_ACTION ON UM_PERMISSION (UM_RESOURCE_ID, UM_ACTION, UM_TENANT_ID);
      
      CREATE TABLE UM_ROLE_PERMISSION (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_PERMISSION_ID INTEGER NOT NULL,
                   UM_ROLE_NAME VARCHAR(255) NOT NULL,
                   UM_IS_ALLOWED SMALLINT NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
      	     UM_DOMAIN_ID INTEGER,
                   UNIQUE (UM_PERMISSION_ID, UM_ROLE_NAME, UM_TENANT_ID, UM_DOMAIN_ID),
      	     FOREIGN KEY (UM_PERMISSION_ID, UM_TENANT_ID) REFERENCES UM_PERMISSION(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
      	     FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      -- REMOVED UNIQUE (UM_PERMISSION_ID, UM_ROLE_ID)
      CREATE TABLE UM_USER_PERMISSION (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_PERMISSION_ID INTEGER NOT NULL,
                   UM_USER_NAME VARCHAR(255) NOT NULL,
                   UM_IS_ALLOWED SMALLINT NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   FOREIGN KEY (UM_PERMISSION_ID, UM_TENANT_ID) REFERENCES UM_PERMISSION(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      -- REMOVED UNIQUE (UM_PERMISSION_ID, UM_USER_ID)
      CREATE TABLE UM_USER_ROLE (
                   UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                   UM_ROLE_ID INTEGER NOT NULL,
                   UM_USER_ID INTEGER NOT NULL,
                   UM_TENANT_ID INTEGER DEFAULT 0,
                   UNIQUE (UM_USER_ID, UM_ROLE_ID, UM_TENANT_ID),
                   FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_ROLE(UM_ID, UM_TENANT_ID),
                   FOREIGN KEY (UM_USER_ID, UM_TENANT_ID) REFERENCES UM_USER(UM_ID, UM_TENANT_ID),
                   PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_SHARED_USER_ROLE(
          UM_ROLE_ID INTEGER NOT NULL,
          UM_USER_ID INTEGER NOT NULL,
          UM_USER_TENANT_ID INTEGER NOT NULL,
          UM_ROLE_TENANT_ID INTEGER NOT NULL,
          UNIQUE(UM_USER_ID,UM_ROLE_ID,UM_USER_TENANT_ID, UM_ROLE_TENANT_ID),
          FOREIGN KEY(UM_ROLE_ID,UM_ROLE_TENANT_ID) REFERENCES UM_ROLE(UM_ID,UM_TENANT_ID) ON DELETE CASCADE,
          FOREIGN KEY(UM_USER_ID,UM_USER_TENANT_ID) REFERENCES UM_USER(UM_ID,UM_TENANT_ID) ON DELETE CASCADE
      )ENGINE INNODB;
      
      CREATE TABLE UM_ACCOUNT_MAPPING(
      	UM_ID INTEGER NOT NULL AUTO_INCREMENT,
      	UM_USER_NAME VARCHAR(255) NOT NULL,
      	UM_TENANT_ID INTEGER NOT NULL,
      	UM_USER_STORE_DOMAIN VARCHAR(100),
      	UM_ACC_LINK_ID INTEGER NOT NULL,
      	UNIQUE(UM_USER_NAME, UM_TENANT_ID, UM_USER_STORE_DOMAIN, UM_ACC_LINK_ID),
      	FOREIGN KEY (UM_TENANT_ID) REFERENCES UM_TENANT(UM_ID) ON DELETE CASCADE,
      	PRIMARY KEY (UM_ID)
      )ENGINE INNODB;
      
      
      CREATE TABLE UM_USER_ATTRIBUTE (
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_ATTR_NAME VARCHAR(255) NOT NULL,
                  UM_ATTR_VALUE VARCHAR(1024),
                  UM_PROFILE_ID VARCHAR(255),
                  UM_USER_ID INTEGER,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  FOREIGN KEY (UM_USER_ID, UM_TENANT_ID) REFERENCES UM_USER(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE INDEX UM_USER_ID_INDEX ON UM_USER_ATTRIBUTE(UM_USER_ID);
      
      CREATE TABLE UM_DIALECT(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_DIALECT_URI VARCHAR(255) NOT NULL,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  UNIQUE(UM_DIALECT_URI, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_CLAIM(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_DIALECT_ID INTEGER NOT NULL,
                  UM_CLAIM_URI VARCHAR(255) NOT NULL,
                  UM_DISPLAY_TAG VARCHAR(255),
                  UM_DESCRIPTION VARCHAR(255),
                  UM_MAPPED_ATTRIBUTE_DOMAIN VARCHAR(255),
                  UM_MAPPED_ATTRIBUTE VARCHAR(255),
                  UM_REG_EX VARCHAR(255),
                  UM_SUPPORTED SMALLINT,
                  UM_REQUIRED SMALLINT,
                  UM_DISPLAY_ORDER INTEGER,
      	    UM_CHECKED_ATTRIBUTE SMALLINT,
                  UM_READ_ONLY SMALLINT,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  UNIQUE(UM_DIALECT_ID, UM_CLAIM_URI, UM_TENANT_ID,UM_MAPPED_ATTRIBUTE_DOMAIN),
                  FOREIGN KEY(UM_DIALECT_ID, UM_TENANT_ID) REFERENCES UM_DIALECT(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      
      CREATE TABLE UM_PROFILE_CONFIG(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_DIALECT_ID INTEGER NOT NULL,
                  UM_PROFILE_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  FOREIGN KEY(UM_DIALECT_ID, UM_TENANT_ID) REFERENCES UM_DIALECT(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS UM_CLAIM_BEHAVIOR(
          UM_ID INTEGER NOT NULL AUTO_INCREMENT,
          UM_PROFILE_ID INTEGER,
          UM_CLAIM_ID INTEGER,
          UM_BEHAVIOUR SMALLINT,
          UM_TENANT_ID INTEGER DEFAULT 0,
          FOREIGN KEY(UM_PROFILE_ID, UM_TENANT_ID) REFERENCES UM_PROFILE_CONFIG(UM_ID,UM_TENANT_ID),
          FOREIGN KEY(UM_CLAIM_ID, UM_TENANT_ID) REFERENCES UM_CLAIM(UM_ID,UM_TENANT_ID),
          PRIMARY KEY(UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_HYBRID_ROLE(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_ROLE_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_HYBRID_USER_ROLE(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_USER_NAME VARCHAR(255),
                  UM_ROLE_ID INTEGER NOT NULL,
                  UM_TENANT_ID INTEGER DEFAULT 0,
      	    UM_DOMAIN_ID INTEGER,
                  UNIQUE (UM_USER_NAME, UM_ROLE_ID, UM_TENANT_ID, UM_DOMAIN_ID),
                  FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_HYBRID_ROLE(UM_ID, UM_TENANT_ID) ON DELETE CASCADE,
      	    FOREIGN KEY (UM_DOMAIN_ID, UM_TENANT_ID) REFERENCES UM_DOMAIN(UM_DOMAIN_ID, UM_TENANT_ID) ON DELETE CASCADE,
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE UM_SYSTEM_ROLE(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_ROLE_NAME VARCHAR(255),
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE INDEX SYSTEM_ROLE_IND_BY_RN_TI ON UM_SYSTEM_ROLE(UM_ROLE_NAME, UM_TENANT_ID);
      
      CREATE TABLE UM_SYSTEM_USER_ROLE(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
                  UM_USER_NAME VARCHAR(255),
                  UM_ROLE_ID INTEGER NOT NULL,
                  UM_TENANT_ID INTEGER DEFAULT 0,
                  UNIQUE (UM_USER_NAME, UM_ROLE_ID, UM_TENANT_ID),
                  FOREIGN KEY (UM_ROLE_ID, UM_TENANT_ID) REFERENCES UM_SYSTEM_ROLE(UM_ID, UM_TENANT_ID),
                  PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      
      CREATE TABLE UM_HYBRID_REMEMBER_ME(
                  UM_ID INTEGER NOT NULL AUTO_INCREMENT,
      			UM_USER_NAME VARCHAR(255) NOT NULL,
      			UM_COOKIE_VALUE VARCHAR(1024),
      			UM_CREATED_TIME TIMESTAMP,
                  UM_TENANT_ID INTEGER DEFAULT 0,
      			PRIMARY KEY (UM_ID, UM_TENANT_ID)
      )ENGINE INNODB;
      
      
      
      USE WSO2EI_INTEGRATOR_CONFIG_GOV_DB;
      
      CREATE TABLE IF NOT EXISTS REG_CLUSTER_LOCK (
                   REG_LOCK_NAME VARCHAR (20),
                   REG_LOCK_STATUS VARCHAR (20),
                   REG_LOCKED_TIME TIMESTAMP,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (REG_LOCK_NAME)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_LOG (
                   REG_LOG_ID INTEGER AUTO_INCREMENT,
                   REG_PATH VARCHAR (750),
                   REG_USER_ID VARCHAR (31) NOT NULL,
                   REG_LOGGED_TIME TIMESTAMP NOT NULL,
                   REG_ACTION INTEGER NOT NULL,
                   REG_ACTION_DATA VARCHAR (500),
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   PRIMARY KEY (REG_LOG_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE INDEX REG_LOG_IND_BY_REGLOG USING HASH ON REG_LOG(REG_LOGGED_TIME, REG_TENANT_ID);
      
      -- The REG_PATH_VALUE should be less than 767 bytes, and hence was fixed at 750.
      -- See CARBON-5917.
      
      CREATE TABLE IF NOT EXISTS REG_PATH(
                   REG_PATH_ID INTEGER NOT NULL AUTO_INCREMENT,
                   REG_PATH_VALUE VARCHAR(750) NOT NULL,
                   REG_PATH_PARENT_ID INTEGER,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   CONSTRAINT PK_REG_PATH PRIMARY KEY(REG_PATH_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE INDEX REG_PATH_IND_BY_PATH_VALUE USING HASH ON REG_PATH(REG_PATH_VALUE, REG_TENANT_ID);
      CREATE INDEX REG_PATH_IND_BY_PATH_PARENT_ID USING HASH ON REG_PATH(REG_PATH_PARENT_ID, REG_TENANT_ID);
      
      CREATE TABLE IF NOT EXISTS REG_CONTENT (
                   REG_CONTENT_ID INTEGER NOT NULL AUTO_INCREMENT,
                   REG_CONTENT_DATA LONGBLOB,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   CONSTRAINT PK_REG_CONTENT PRIMARY KEY(REG_CONTENT_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_CONTENT_HISTORY (
                   REG_CONTENT_ID INTEGER NOT NULL,
                   REG_CONTENT_DATA LONGBLOB,
                   REG_DELETED   SMALLINT,
                   REG_TENANT_ID INTEGER DEFAULT 0,
                   CONSTRAINT PK_REG_CONTENT_HISTORY PRIMARY KEY(REG_CONTENT_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_RESOURCE (
                  REG_PATH_ID         INTEGER NOT NULL,
                  REG_NAME            VARCHAR(256),
                  REG_VERSION         INTEGER NOT NULL AUTO_INCREMENT,
                  REG_MEDIA_TYPE      VARCHAR(500),
                  REG_CREATOR         VARCHAR(31) NOT NULL,
                  REG_CREATED_TIME    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                  REG_LAST_UPDATOR    VARCHAR(31),
                  REG_LAST_UPDATED_TIME    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                  REG_DESCRIPTION     VARCHAR(1000),
                  REG_CONTENT_ID      INTEGER,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  REG_UUID VARCHAR(100) NOT NULL,
                  CONSTRAINT PK_REG_RESOURCE PRIMARY KEY(REG_VERSION, REG_TENANT_ID)
      )ENGINE INNODB;
      
      ALTER TABLE REG_RESOURCE ADD CONSTRAINT REG_RESOURCE_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE ADD CONSTRAINT REG_RESOURCE_FK_BY_CONTENT_ID FOREIGN KEY (REG_CONTENT_ID, REG_TENANT_ID) REFERENCES REG_CONTENT (REG_CONTENT_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_IND_BY_NAME USING HASH ON REG_RESOURCE(REG_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_IND_BY_PATH_ID_NAME USING HASH ON REG_RESOURCE(REG_PATH_ID, REG_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_IND_BY_UUID USING HASH ON REG_RESOURCE(REG_UUID);
      CREATE INDEX REG_RESOURCE_IND_BY_TENAN USING HASH ON REG_RESOURCE(REG_TENANT_ID, REG_UUID);
      CREATE INDEX REG_RESOURCE_IND_BY_TYPE USING HASH ON REG_RESOURCE(REG_TENANT_ID, REG_MEDIA_TYPE);
      
      CREATE TABLE IF NOT EXISTS REG_RESOURCE_HISTORY (
                  REG_PATH_ID         INTEGER NOT NULL,
                  REG_NAME            VARCHAR(256),
                  REG_VERSION         INTEGER NOT NULL,
                  REG_MEDIA_TYPE      VARCHAR(500),
                  REG_CREATOR         VARCHAR(31) NOT NULL,
                  REG_CREATED_TIME    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                  REG_LAST_UPDATOR    VARCHAR(31),
                  REG_LAST_UPDATED_TIME    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                  REG_DESCRIPTION     VARCHAR(1000),
                  REG_CONTENT_ID      INTEGER,
                  REG_DELETED         SMALLINT,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  REG_UUID VARCHAR(100) NOT NULL,
                  CONSTRAINT PK_REG_RESOURCE_HISTORY PRIMARY KEY(REG_VERSION, REG_TENANT_ID)
      )ENGINE INNODB;
      
      ALTER TABLE REG_RESOURCE_HISTORY ADD CONSTRAINT REG_RESOURCE_HIST_FK_BY_PATHID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_HISTORY ADD CONSTRAINT REG_RESOURCE_HIST_FK_BY_CONTENT_ID FOREIGN KEY (REG_CONTENT_ID, REG_TENANT_ID) REFERENCES REG_CONTENT_HISTORY (REG_CONTENT_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_HISTORY_IND_BY_NAME USING HASH ON REG_RESOURCE_HISTORY(REG_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_HISTORY_IND_BY_PATH_ID_NAME USING HASH ON REG_RESOURCE(REG_PATH_ID, REG_NAME, REG_TENANT_ID);
      
      CREATE TABLE IF NOT EXISTS REG_COMMENT (
                  REG_ID        INTEGER NOT NULL AUTO_INCREMENT,
                  REG_COMMENT_TEXT      VARCHAR(500) NOT NULL,
                  REG_USER_ID           VARCHAR(31) NOT NULL,
                  REG_COMMENTED_TIME    TIMESTAMP NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_COMMENT PRIMARY KEY(REG_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_RESOURCE_COMMENT (
                  REG_COMMENT_ID          INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      )ENGINE INNODB;
      
      ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_COMMENT ADD CONSTRAINT REG_RESOURCE_COMMENT_FK_BY_COMMENT_ID FOREIGN KEY (REG_COMMENT_ID, REG_TENANT_ID) REFERENCES REG_COMMENT (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_COMMENT_IND_BY_PATH_ID_AND_RESOURCE_NAME USING HASH ON REG_RESOURCE_COMMENT(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_COMMENT_IND_BY_VERSION USING HASH ON REG_RESOURCE_COMMENT(REG_VERSION, REG_TENANT_ID);
      
      CREATE TABLE IF NOT EXISTS REG_RATING (
                  REG_ID     INTEGER NOT NULL AUTO_INCREMENT,
                  REG_RATING        INTEGER NOT NULL,
                  REG_USER_ID       VARCHAR(31) NOT NULL,
                  REG_RATED_TIME    TIMESTAMP NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_RATING PRIMARY KEY(REG_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_RESOURCE_RATING (
                  REG_RATING_ID           INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      )ENGINE INNODB;
      
      ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_RATING ADD CONSTRAINT REG_RESOURCE_RATING_FK_BY_RATING_ID FOREIGN KEY (REG_RATING_ID, REG_TENANT_ID) REFERENCES REG_RATING (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_RATING_IND_BY_PATH_ID_AND_RESOURCE_NAME USING HASH ON REG_RESOURCE_RATING(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_RATING_IND_BY_VERSION USING HASH ON REG_RESOURCE_RATING(REG_VERSION, REG_TENANT_ID);
      
      
      CREATE TABLE IF NOT EXISTS REG_TAG (
                  REG_ID         INTEGER NOT NULL AUTO_INCREMENT,
                  REG_TAG_NAME       VARCHAR(500) NOT NULL,
                  REG_USER_ID        VARCHAR(31) NOT NULL,
                  REG_TAGGED_TIME    TIMESTAMP NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_TAG PRIMARY KEY(REG_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_RESOURCE_TAG (
                  REG_TAG_ID              INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      )ENGINE INNODB;
      
      ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_TAG ADD CONSTRAINT REG_RESOURCE_TAG_FK_BY_TAG_ID FOREIGN KEY (REG_TAG_ID, REG_TENANT_ID) REFERENCES REG_TAG (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_TAG_IND_BY_PATH_ID_AND_RESOURCE_NAME USING HASH ON REG_RESOURCE_TAG(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_TAG_IND_BY_VERSION USING HASH ON REG_RESOURCE_TAG(REG_VERSION, REG_TENANT_ID);
      
      CREATE TABLE IF NOT EXISTS REG_PROPERTY (
                  REG_ID         INTEGER NOT NULL AUTO_INCREMENT,
                  REG_NAME       VARCHAR(100) NOT NULL,
                  REG_VALUE        VARCHAR(1000),
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_PROPERTY PRIMARY KEY(REG_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_RESOURCE_PROPERTY (
                  REG_PROPERTY_ID         INTEGER NOT NULL,
                  REG_VERSION             INTEGER,
                  REG_PATH_ID             INTEGER,
                  REG_RESOURCE_NAME       VARCHAR(256),
                  REG_TENANT_ID INTEGER DEFAULT 0
      )ENGINE INNODB;
      
      ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      ALTER TABLE REG_RESOURCE_PROPERTY ADD CONSTRAINT REG_RESOURCE_PROPERTY_FK_BY_TAG_ID FOREIGN KEY (REG_PROPERTY_ID, REG_TENANT_ID) REFERENCES REG_PROPERTY (REG_ID, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_PROPERTY_IND_BY_PATH_ID_AND_RESOURCE_NAME USING HASH ON REG_RESOURCE_PROPERTY(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      CREATE INDEX REG_RESOURCE_PROPERTY_IND_BY_VERSION USING HASH ON REG_RESOURCE_PROPERTY(REG_VERSION, REG_TENANT_ID);
      
      -- CREATE TABLE IF NOT EXISTS REG_ASSOCIATIONS (
      -- SRC_PATH_ID     INTEGER,
      -- SRC_RESOURCE_NAME    VARCHAR(256),
      -- SRC_VERSION     INTEGER,
      -- TGT_PATH_ID     INTEGER,
      -- TGT_RESOURCE_NAME    VARCHAR(256),
      -- TGT_VERSION     INTEGER
      -- )ENGINE INNODB;
      --
      -- ALTER TABLE REG_ASSOCIATIONS ADD CONSTRAINT REG_ASSOCIATIONS_FK_BY_SRC_PATH_ID FOREIGN KEY (SRC_PATH_ID) REFERENCES REG_PATH (PATH_ID);
      -- ALTER TABLE REG_ASSOCIATIONS ADD CONSTRAINT REG_ASSOCIATIONS_FK_BY_TGT_PATH_ID FOREIGN KEY (TGT_PATH_ID) REFERENCES REG_PATH (PATH_ID);
      -- CREATE INDEX REG_ASSOCIATIONS_IND_BY_SRC_VERSION ON REG_ASSOCIATIONS(SRC_VERSION);
      -- CREATE INDEX REG_ASSOCIATIONS_IND_BY_TGT_VERSION ON REG_ASSOCIATIONS(TGT_VERSION);
      -- CREATE INDEX REG_ASSOCIATIONS_IND_BY_SRC_RESOURCE_NAME ON REG_ASSOCIATIONS(SRC_RESOURCE_NAME);
      -- CREATE INDEX REG_ASSOCIATIONS_IND_BY_TGT_RESOURCE_NAME ON REG_ASSOCIATIONS(TGT_RESOURCE_NAME);
      
      
      
      CREATE TABLE IF NOT EXISTS REG_ASSOCIATION (
                  REG_ASSOCIATION_ID INTEGER AUTO_INCREMENT,
                  REG_SOURCEPATH VARCHAR (750) NOT NULL,
                  REG_TARGETPATH VARCHAR (750) NOT NULL,
                  REG_ASSOCIATION_TYPE VARCHAR (2000) NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  PRIMARY KEY (REG_ASSOCIATION_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE TABLE IF NOT EXISTS REG_SNAPSHOT (
                  REG_SNAPSHOT_ID     INTEGER NOT NULL AUTO_INCREMENT,
                  REG_PATH_ID            INTEGER NOT NULL,
                  REG_RESOURCE_NAME      VARCHAR(255),
                  REG_RESOURCE_VIDS     LONGBLOB NOT NULL,
                  REG_TENANT_ID INTEGER DEFAULT 0,
                  CONSTRAINT PK_REG_SNAPSHOT PRIMARY KEY(REG_SNAPSHOT_ID, REG_TENANT_ID)
      )ENGINE INNODB;
      
      CREATE INDEX REG_SNAPSHOT_IND_BY_PATH_ID_AND_RESOURCE_NAME USING HASH ON REG_SNAPSHOT(REG_PATH_ID, REG_RESOURCE_NAME, REG_TENANT_ID);
      
      ALTER TABLE REG_SNAPSHOT ADD CONSTRAINT REG_SNAPSHOT_FK_BY_PATH_ID FOREIGN KEY (REG_PATH_ID, REG_TENANT_ID) REFERENCES REG_PATH (REG_PATH_ID, REG_TENANT_ID);
      
      USE WSO2EI_MB_DB;
      
      -- WSO2 Message Broker MySQL Database schema --
      
      -- Start of Message Store Tables --
      
      CREATE TABLE IF NOT EXISTS MB_QUEUE_MAPPING (
                      QUEUE_ID INTEGER AUTO_INCREMENT,
                      QUEUE_NAME VARCHAR(512) UNIQUE NOT NULL,
                      PRIMARY KEY (QUEUE_ID, QUEUE_NAME)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_METADATA (
                      MESSAGE_ID BIGINT,
                      QUEUE_ID INTEGER,
                      DLC_QUEUE_ID INTEGER NOT NULL,
                      MESSAGE_METADATA VARBINARY(65500) NOT NULL,
                      PRIMARY KEY (MESSAGE_ID, QUEUE_ID),
                      FOREIGN KEY (QUEUE_ID) REFERENCES MB_QUEUE_MAPPING (QUEUE_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE INDEX MB_METADATA_QUEUE_ID_INDEX ON MB_METADATA (QUEUE_ID) USING HASH;
      
      CREATE TABLE IF NOT EXISTS MB_CONTENT (
                      MESSAGE_ID BIGINT,
                      CONTENT_OFFSET INTEGER,
                      MESSAGE_CONTENT VARBINARY(65500) NOT NULL,
                      PRIMARY KEY (MESSAGE_ID,CONTENT_OFFSET),
                      FOREIGN KEY (MESSAGE_ID) REFERENCES MB_METADATA (MESSAGE_ID)
                      ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_EXPIRATION_DATA (
                      MESSAGE_ID BIGINT UNIQUE,
                      EXPIRATION_TIME BIGINT,
                      DLC_QUEUE_ID INTEGER NOT NULL,
                      MESSAGE_DESTINATION VARCHAR(512) NOT NULL,
                      FOREIGN KEY (MESSAGE_ID) REFERENCES MB_METADATA (MESSAGE_ID)
                      ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_RETAINED_METADATA (
                      TOPIC_ID INTEGER,
                      TOPIC_NAME VARCHAR(512) NOT NULL,
                      MESSAGE_ID BIGINT NOT NULL,
                      MESSAGE_METADATA VARBINARY(65000) NOT NULL,
                      PRIMARY KEY (TOPIC_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_DTX_XID (
                      INTERNAL_XID BIGINT UNIQUE NOT NULL,
                      NODE_ID VARCHAR(512) NOT NULL,
                      FORMAT_CODE BIGINT NOT NULL,
                      GLOBAL_ID VARBINARY(260), -- AMQP-10 vbin8 type
                      BRANCH_ID VARBINARY(260), -- AMQP-10 vbin8 type
                      PRIMARY KEY (INTERNAL_XID, NODE_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_DTX_ENQUEUE_RECORD (
                      INTERNAL_XID BIGINT NOT NULL,
                      MESSAGE_ID BIGINT NOT NULL,
                      MESSAGE_METADATA VARBINARY(65000) NOT NULL,
                      PRIMARY KEY (MESSAGE_ID),
                      FOREIGN KEY (INTERNAL_XID) REFERENCES MB_DTX_XID (INTERNAL_XID)
                      ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_DTX_DEQUEUE_RECORD (
                      INTERNAL_XID BIGINT NOT NULL,
                      MESSAGE_ID BIGINT NOT NULL,
                      QUEUE_NAME VARCHAR(512) NOT NULL,
                      MESSAGE_METADATA VARBINARY(65000) NOT NULL,
                      PRIMARY KEY (MESSAGE_ID),
                      FOREIGN KEY (INTERNAL_XID) REFERENCES MB_DTX_XID (INTERNAL_XID)
                      ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_DTX_ENQUEUE_CONTENT (
                      MESSAGE_ID BIGINT NOT NULL,
                      INTERNAL_XID BIGINT NOT NULL,
                      CONTENT_OFFSET INTEGER NOT NULL,
                      MESSAGE_CONTENT VARBINARY(65500) NOT NULL,
                      PRIMARY KEY (MESSAGE_ID, CONTENT_OFFSET),
                      FOREIGN KEY (MESSAGE_ID) REFERENCES MB_DTX_ENQUEUE_RECORD (MESSAGE_ID)
                      ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_DTX_DEQUEUE_CONTENT (
                      INTERNAL_XID BIGINT NOT NULL,
                      MESSAGE_ID BIGINT NOT NULL,
                      CONTENT_OFFSET INTEGER NOT NULL,
                      MESSAGE_CONTENT VARBINARY(65500) NOT NULL,
                      PRIMARY KEY (MESSAGE_ID, CONTENT_OFFSET),
                      FOREIGN KEY (MESSAGE_ID) REFERENCES MB_DTX_DEQUEUE_RECORD (MESSAGE_ID)
                      ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      -- End of Message Store Tables --
      
      -- Start of Andes Context Store Tables --
      
      CREATE TABLE IF NOT EXISTS MB_DURABLE_SUBSCRIPTION (
                              SUBSCRIPTION_ID VARCHAR(512) NOT NULL,
                              DESTINATION_IDENTIFIER VARCHAR(512) NOT NULL,
                              SUBSCRIPTION_DATA VARCHAR(2048) NOT NULL
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_NODE (
                              NODE_ID VARCHAR(512) NOT NULL,
                              NODE_DATA VARCHAR(2048) NOT NULL,
                              PRIMARY KEY(NODE_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_EXCHANGE (
                              EXCHANGE_NAME VARCHAR(512) NOT NULL,
                              EXCHANGE_DATA VARCHAR(2048) NOT NULL,
                              PRIMARY KEY(EXCHANGE_NAME)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_QUEUE (
                              QUEUE_NAME VARCHAR(512) NOT NULL,
                              QUEUE_DATA VARCHAR(2048) NOT NULL,
                              PRIMARY KEY(QUEUE_NAME)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_BINDING (
                              EXCHANGE_NAME VARCHAR(512) NOT NULL,
                              QUEUE_NAME VARCHAR(512) NOT NULL,
                              BINDING_DETAILS VARCHAR(2048) NOT NULL,
                              FOREIGN KEY (EXCHANGE_NAME) REFERENCES MB_EXCHANGE (EXCHANGE_NAME),
                              FOREIGN KEY (QUEUE_NAME) REFERENCES MB_QUEUE (QUEUE_NAME)
                              ON DELETE CASCADE
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_QUEUE_COUNTER (
                              QUEUE_NAME VARCHAR(512) NOT NULL,
                              MESSAGE_COUNT BIGINT,
                              PRIMARY KEY (QUEUE_NAME)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_SLOT (
                              SLOT_ID bigint(11) NOT NULL AUTO_INCREMENT,
                              START_MESSAGE_ID bigint(20) NOT NULL,
                              END_MESSAGE_ID bigint(20) NOT NULL,
                              STORAGE_QUEUE_NAME varchar(512) NOT NULL,
                              SLOT_STATE tinyint(4) NOT NULL DEFAULT '1',
                              ASSIGNED_NODE_ID varchar(512) DEFAULT NULL,
                              ASSIGNED_QUEUE_NAME varchar(512) DEFAULT NULL,
                              PRIMARY KEY (SLOT_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      -- Default value '1' for SLOT_STATE stands for CREATED state of slot
      
      CREATE INDEX MB_SLOT_MESSAGE_ID_INDEX ON MB_SLOT (START_MESSAGE_ID, END_MESSAGE_ID) USING HASH;
      
      CREATE INDEX MB_SLOT_QUEUE_INDEX ON MB_SLOT (STORAGE_QUEUE_NAME) USING HASH;
      
      CREATE TABLE IF NOT EXISTS MB_SLOT_MESSAGE_ID (
                              QUEUE_NAME varchar(512) NOT NULL,
                              MESSAGE_ID bigint(20) NOT NULL,
                              PRIMARY KEY (QUEUE_NAME,MESSAGE_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_NODE_TO_LAST_PUBLISHED_ID (
                              NODE_ID varchar(512) NOT NULL,
                              MESSAGE_ID bigint(20) NOT NULL,
                              PRIMARY KEY (NODE_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_QUEUE_TO_LAST_ASSIGNED_ID (
                              QUEUE_NAME varchar(512) NOT NULL,
                              MESSAGE_ID bigint(20) NOT NULL,
                              PRIMARY KEY (QUEUE_NAME)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_MSG_STORE_STATUS (
                              NODE_ID VARCHAR(512) NOT NULL,
                              TIME_STAMP BIGINT,
                              PRIMARY KEY (NODE_ID, TIME_STAMP)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_RETAINED_CONTENT (
                              MESSAGE_ID BIGINT,
                              CONTENT_OFFSET INT,
                              MESSAGE_CONTENT VARBINARY(65500) NOT NULL,
                              PRIMARY KEY (MESSAGE_ID,CONTENT_OFFSET)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_COORDINATOR_HEARTBEAT (
                              ANCHOR INT NOT NULL,
                              NODE_ID VARCHAR(512) NOT NULL,
                              LAST_HEARTBEAT BIGINT NOT NULL,
                              THRIFT_HOST VARCHAR(512) NOT NULL,
                              THRIFT_PORT INT NOT NULL,
                              PRIMARY KEY (ANCHOR)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_NODE_HEARTBEAT (
                              NODE_ID VARCHAR(512) NOT NULL,
                              LAST_HEARTBEAT BIGINT NOT NULL,
                              IS_NEW_NODE TINYINT NOT NULL,
                              CLUSTER_AGENT_HOST VARCHAR(512) NOT NULL,
                              CLUSTER_AGENT_PORT INT NOT NULL,
                              PRIMARY KEY (NODE_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_MEMBERSHIP (
                              EVENT_ID BIGINT NOT NULL AUTO_INCREMENT,
                              NODE_ID VARCHAR(512) NOT NULL,
                              CHANGE_TYPE tinyint(4) NOT NULL,
                              CHANGED_MEMBER_ID VARCHAR(512) NOT NULL,
                              PRIMARY KEY (EVENT_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
      
      CREATE TABLE IF NOT EXISTS MB_CLUSTER_EVENT (
                              EVENT_ID BIGINT NOT NULL AUTO_INCREMENT,
                              ORIGINATED_NODE_ID VARCHAR(512) NOT NULL,
                              DESTINED_NODE_ID VARCHAR(512) NOT NULL,
                              EVENT_ARTIFACT VARCHAR(25) NOT NULL,
                              EVENT_TYPE VARCHAR(25) NOT NULL,
                              EVENT_DETAILS VARCHAR(1024) NOT NULL,
                              EVENT_DESCRIPTION VARCHAR(1024),
                              PRIMARY KEY (EVENT_ID)
      ) ENGINE=InnoDB DEFAULT CHARSET=latin1;

# ConfigMap wso2ei-rdbms-service-mysql-test
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: wso2ei-rdbms-service-mysql-test
  data:
    run.sh: |-
      @test "Testing MySQL Connection" {
        mysql --host=wso2ei-rdbms-service-mysql --port=3306 -u root -proot
      }

# ConfigMap analytics-conf-dashboard
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: analytics-conf-dashboard
  data:
    deployment.yaml: |-
      # Carbon Configuration Parameters
      wso2.carbon:
          # value to uniquely identify a server
        id: wso2-sp
          # server name
        name: WSO2 Stream Processor
          # ports used by this server
        ports:
            # port offset
          offset: 2
        # Configuration used for the databridge communication
      databridge.config:
          # No of worker threads to consume events
          # THIS IS A MANDATORY FIELD
        workerThreads: 10
          # Maximum amount of messages that can be queued internally in MB
          # THIS IS A MANDATORY FIELD
        maxEventBufferCapacity: 10000000
          # Queue size; the maximum number of events that can be stored in the queue
          # THIS IS A MANDATORY FIELD
        eventBufferSize: 2000
          # Keystore file path
          # THIS IS A MANDATORY FIELD
        keyStoreLocation: ${sys:carbon.home}/resources/security/wso2carbon.jks
          # Keystore password
          # THIS IS A MANDATORY FIELD
        keyStorePassword: wso2carbon
          # Session Timeout value in mins
          # THIS IS A MANDATORY FIELD
        clientTimeoutMin: 30
          # Data receiver configurations
          # THIS IS A MANDATORY FIELD
        dataReceivers:
            # Data receiver configuration
        - dataReceiver:
              # Data receiver type
              # THIS IS A MANDATORY FIELD
            type: Thrift
              # Data receiver properties
            properties:
              tcpPort: '7611'
              sslPort: '7711'
            # Data receiver configuration
        - dataReceiver:
              # Data receiver type
              # THIS IS A MANDATORY FIELD
            type: Binary
              # Data receiver properties
            properties:
              tcpPort: '9611'
              sslPort: '9711'
              tcpReceiverThreadPoolSize: '100'
              sslReceiverThreadPoolSize: '100'
              hostName: 0.0.0.0
        # Configuration of the Data Agents - to publish events through databridge
      data.agent.config:
          # Data agent configurations
          # THIS IS A MANDATORY FIELD
        agents:
            # Data agent configuration
        - agentConfiguration:
              # Data agent name
              # THIS IS A MANDATORY FIELD
            name: Thrift
              # Data endpoint class
              # THIS IS A MANDATORY FIELD
            dataEndpointClass: org.wso2.carbon.databridge.agent.endpoint.thrift.ThriftDataEndpoint
              # Data publisher strategy
            publishingStrategy: async
              # Trust store path
            trustStorePath: ${sys:carbon.home}/resources/security/client-truststore.jks
              # Trust store password
            trustStorePassword: wso2carbon
              # Queue Size
            queueSize: 32768
              # Batch Size
            batchSize: 200
              # Core pool size
            corePoolSize: 1
              # Socket timeout in milliseconds
            socketTimeoutMS: 30000
              # Maximum pool size
            maxPoolSize: 1
              # Keep alive time in pool
            keepAliveTimeInPool: 20
              # Reconnection interval
            reconnectionInterval: 30
              # Max transport pool size
            maxTransportPoolSize: 250
              # Max idle connections
            maxIdleConnections: 250
              # Eviction time interval
            evictionTimePeriod: 5500
              # Min idle time in pool
            minIdleTimeInPool: 5000
              # Secure max transport pool size
            secureMaxTransportPoolSize: 250
              # Secure max idle connections
            secureMaxIdleConnections: 250
              # secure eviction time period
            secureEvictionTimePeriod: 5500
              # Secure min idle time in pool
            secureMinIdleTimeInPool: 5000
              # SSL enabled protocols
            sslEnabledProtocols: TLSv1.1,TLSv1.2
              # Ciphers
            ciphers: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
            # Data agent configuration
        - agentConfiguration:
              # Data agent name
              # THIS IS A MANDATORY FIELD
            name: Binary
              # Data endpoint class
              # THIS IS A MANDATORY FIELD
            dataEndpointClass: org.wso2.carbon.databridge.agent.endpoint.binary.BinaryDataEndpoint
              # Data publisher strategy
            publishingStrategy: async
              # Trust store path
            trustStorePath: ${sys:carbon.home}/resources/security/client-truststore.jks
              # Trust store password
            trustStorePassword: wso2carbon
              # Queue Size
            queueSize: 32768
              # Batch Size
            batchSize: 200
              # Core pool size
            corePoolSize: 1
              # Socket timeout in milliseconds
            socketTimeoutMS: 30000
              # Maximum pool size
            maxPoolSize: 1
              # Keep alive time in pool
            keepAliveTimeInPool: 20
              # Reconnection interval
            reconnectionInterval: 30
              # Max transport pool size
            maxTransportPoolSize: 250
              # Max idle connections
            maxIdleConnections: 250
              # Eviction time interval
            evictionTimePeriod: 5500
              # Min idle time in pool
            minIdleTimeInPool: 5000
              # Secure max transport pool size
            secureMaxTransportPoolSize: 250
              # Secure max idle connections
            secureMaxIdleConnections: 250
              # secure eviction time period
            secureEvictionTimePeriod: 5500
              # Secure min idle time in pool
            secureMinIdleTimeInPool: 5000
              # SSL enabled protocols
            sslEnabledProtocols: TLSv1.1,TLSv1.2
              # Ciphers
            ciphers: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
        # Deployment configuration parameters
      wso2.artifact.deployment:
          # Scheduler update interval
        updateInterval: 5
        # HA Configuration
      state.persistence:
        enabled: false
        intervalInMin: 1
        revisionsToKeep: 2
        persistenceStore: org.wso2.carbon.stream.processor.core.persistence.FileSystemPersistenceStore
        config:
          location: siddhi-app-persistence
        # Secure Vault Configuration
      wso2.securevault:
        secretRepository:
          type: org.wso2.carbon.secvault.repository.DefaultSecretRepository
          parameters:
            privateKeyAlias: wso2carbon
            keystoreLocation: ${sys:carbon.home}/resources/security/securevault.jks
            secretPropertiesFile: ${sys:carbon.home}/conf/${sys:wso2.runtime}/secrets.properties
        masterKeyReader:
          type: org.wso2.carbon.secvault.reader.DefaultMasterKeyReader
          parameters:
            masterKeyReaderFile: ${sys:carbon.home}/conf/${sys:wso2.runtime}/master-keys.yaml
      # Data Sources Configuration
      wso2.datasources:
        dataSources:
        # Dashboard data source
        - name: WSO2_DASHBOARD_DB
          description: The datasource used for dashboard feature
          jndiConfig:
            name: jdbc/DASHBOARD_DB
            useJndiReference: true
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/${sys:wso2.runtime}/database/DASHBOARD_DB;IFEXISTS=TRUE;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000;MVCC=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 20
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        - name: BUSINESS_RULES_DB
          description: The datasource used for dashboard feature
          jndiConfig:
            name: jdbc/BUSINESS_RULES_DB
            useJndiReference: true
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/${sys:wso2.runtime}/database/BUSINESS_RULES_DB;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000;MVCC=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 20
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        # Dashboard data source
        - name: WSO2_STATUS_DASHBOARD_DB
          description: The datasource used for dashboard feature
          jndiConfig:
            name: jdbc/wso2_status_dashboard
            useJndiReference: true
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/${sys:wso2.runtime}/database/wso2_status_dashboard;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000;MVCC=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 20
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        # carbon metrics data source
        - name: WSO2_METRICS_DB
          description: The datasource used for dashboard feature
          jndiConfig:
            name: jdbc/WSO2MetricsDB
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/dashboard/database/metrics;AUTO_SERVER=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 20
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        - name: WSO2_PERMISSIONS_DB
          description: The datasource used for dashboard feature
          jndiConfig:
            name: jdbc/PERMISSION_DB
            useJndiReference: true
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/${sys:wso2.runtime}/database/PERMISSION_DB;IFEXISTS=TRUE;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000;MVCC=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 10
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        - name: EI_ANALYTICS
          description: The datasource used for EI Analytics dashboard feature
          jndiConfig:
            name: jdbc/EI_ANALYTICS
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:mysql://wso2ei-rdbms-service-mysql:3306/EI_ANALYTICS?useSSL=false
              username: wso2carbon
              password: wso2carbon
              driverClassName: com.mysql.jdbc.Driver
              maxPoolSize: 50
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
      wso2.business.rules.manager:
        datasource: BUSINESS_RULES_DB
        # rule template wise configuration for deploying business rules
        deployment_configs:
           # <IP>:<HTTPS Port> of the Worker node
        - localhost:9443:
             # UUIDs of rule templates that are needed to be deployed on the node
          - stock-data-analysis
          - stock-exchange-input
          - stock-exchange-output
          - identifying-continuous-production-decrease
          - popular-tweets-analysis
          - http-analytics-processing
          - message-tracing-source-template
          - message-tracing-app-template
        # credentials for worker nodes
        username: admin
        password: admin
      wso2.status.dashboard:
        pollingInterval: 5
        metricsDatasourceName: WSO2_METRICS_DB
        dashboardDatasourceName: WSO2_STATUS_DASHBOARD_DB
        workerAccessCredentials:
          username: admin
          password: admin
      wso2.transport.http:
        transportProperties:
        - name: server.bootstrap.socket.timeout
          value: 60
        - name: client.bootstrap.socket.timeout
          value: 60
        - name: latency.metrics.enabled
          value: true
        listenerConfigurations:
        - id: default-https
          host: 0.0.0.0
          port: 9643
          scheme: https
          keyStoreFile: ${carbon.home}/resources/security/wso2carbon.jks
          keyStorePassword: wso2carbon
          certPass: wso2carbon
      # Authentication configuration
      auth.configs:
        type: local          # Type of the IdP client used
        userManager:
          adminRole: admin   # Admin role which is granted all permissions
          userStore:         # User store
            users:
            - user:
                username: admin
                password: YWRtaW4=
                roles: 1
            roles:
            - role:
                id: 1
                displayName: admin

# ConfigMap analytics-dashboard-bin
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: analytics-dashboard-bin
  data:
    carbon.sh: |-
      #!/bin/sh      
      # ----------------------------------------------------------------------------
      # Main Script for the WSO2 Carbon Server
      #
      # Environment Variable Prequisites
      #
      #   CARBON_HOME   Home of WSO2 Carbon installation. If not set I will  try
      #                   to figure it out.
      #   RUNTIME_HOME  Home of WSO2 Carbon Runtime. .
      #
      #   JAVA_HOME       Must point at your Java Development Kit installation.
      #
      #   JAVA_OPTS       (Optional) Java runtime options used when the commands
      #                   is executed.
      #
      # NOTE: Borrowed generously from Apache Tomcat startup scripts.
      # -----------------------------------------------------------------------------
      
      # OS specific support.  $var _must_ be set to either true or false.
      #ulimit -n 100000
      
      cygwin=false;
      darwin=false;
      os400=false;
      mingw=false;
      case "`uname`" in
      CYGWIN*) cygwin=true;;
      MINGW*) mingw=true;;
      OS400*) os400=true;;
      Darwin*) darwin=true
              if [ -z "$JAVA_VERSION" ] ; then
                   JAVA_VERSION="CurrentJDK"
                 else
                   echo "Using Java version: $JAVA_VERSION"
                 fi
                 if [ -z "$JAVA_HOME" ] ; then
                   JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/${JAVA_VERSION}/Home
                 fi
                 ;;
      esac
      
      # resolve links - $0 may be a softlink
      PRG="$0"
      
      while [ -h "$PRG" ]; do
        ls=`ls -ld "$PRG"`
        link=`expr "$ls" : '.*-> \(.*\)$'`
        if expr "$link" : '.*/.*' > /dev/null; then
          PRG="$link"
        else
          PRG=`dirname "$PRG"`/"$link"
        fi
      done
      
      # Get standard environment variables
      TEMPCURDIR=`dirname "$PRG"`
      
      # Only set RUNTIME_HOME if not already set
      [ -z "$RUNTIME_HOME" ] && RUNTIME_HOME=`cd "$TEMPCURDIR/.." ; pwd`
      
      # Only set CARBON_HOME if not already set
      [ -z "$CARBON_HOME" ] && CARBON_HOME=`cd "$TEMPCURDIR/../../../" ; pwd`
      
      # Only set RUNTIME if not already set
      [ -z "$RUNTIME" ] && RUNTIME=${RUNTIME_HOME##*/}
      
      # For Cygwin, ensure paths are in UNIX format before anything is touched
      if $cygwin; then
        [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
        [ -n "$CARBON_HOME" ] && CARBON_HOME=`cygpath --unix "$CARBON_HOME"`
        [ -n "$RUNTIME_HOME" ] && RUNTIME_HOME=`cygpath --unix "$RUNTIME_HOME"`
      fi
      
      # For OS400
      if $os400; then
        # Set job priority to standard for interactive (interactive - 6) by using
        # the interactive priority - 6, the helper threads that respond to requests
        # will be running at the same priority as interactive jobs.
        COMMAND='chgjob job('$JOBNAME') runpty(6)'
        system $COMMAND
      
        # Enable multi threading
        QIBM_MULTI_THREADED=Y
        export QIBM_MULTI_THREADED
      fi
      
      # For Migwn, ensure paths are in UNIX format before anything is touched
      if $mingw ; then
        [ -n "$CARBON_HOME" ] &&
          CARBON_HOME="`(cd "$CARBON_HOME"; pwd)`"
        [ -n "$JAVA_HOME" ] &&
          JAVA_HOME="`(cd "$JAVA_HOME"; pwd)`"
        # TODO classpath?
      fi
      
      if [ -z "$JAVACMD" ] ; then
        if [ -n "$JAVA_HOME"  ] ; then
          if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
            # IBM's JDK on AIX uses strange locations for the executables
            JAVACMD="$JAVA_HOME/jre/sh/java"
          else
            JAVACMD="$JAVA_HOME/bin/java"
          fi
        else
          JAVACMD=java
        fi
      fi
      
      if [ ! -x "$JAVACMD" ] ; then
        echo "Error: JAVA_HOME is not defined correctly."
        echo " CARBON cannot execute $JAVACMD"
        exit 1
      fi
      
      # if JAVA_HOME is not set we're not happy
      if [ -z "$JAVA_HOME" ]; then
        echo "You must set the JAVA_HOME variable before running CARBON."
        exit 1
      fi
      
      if [ -e "$RUNTIME_HOME/runtime.pid" ]; then
        PID=`cat "$RUNTIME_HOME"/runtime.pid`
      fi
      
      # ----- Process the input command ----------------------------------------------
      args=""
      for c in $*
      do
          if [ "$c" = "--debug" ] || [ "$c" = "-debug" ] || [ "$c" = "debug" ]; then
                CMD="--debug"
                continue
          elif [ "$CMD" = "--debug" ]; then
                if [ -z "$PORT" ]; then
                      PORT=$c
                fi
          elif [ "$c" = "--stop" ] || [ "$c" = "-stop" ] || [ "$c" = "stop" ]; then
                CMD="stop"
          elif [ "$c" = "--start" ] || [ "$c" = "-start" ] || [ "$c" = "start" ]; then
                CMD="start"
          elif [ "$c" = "--version" ] || [ "$c" = "-version" ] || [ "$c" = "version" ]; then
                CMD="version"
          elif [ "$c" = "--restart" ] || [ "$c" = "-restart" ] || [ "$c" = "restart" ]; then
                CMD="restart"
          elif [ "$c" = "--test" ] || [ "$c" = "-test" ] || [ "$c" = "test" ]; then
                CMD="test"
          else
              args="$args $c"
          fi
      done
      
      if [ "$CMD" = "--debug" ]; then
        if [ "$PORT" = "" ]; then
          echo " Please specify the debug port after the --debug option"
          exit 1
        fi
        if [ -n "$JAVA_OPTS" ]; then
          echo "Warning !!!. User specified JAVA_OPTS will be ignored, once you give the --debug option."
        fi
        CMD="RUN"
        JAVA_OPTS="-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=$PORT"
        echo "Please start the remote debugging client to continue..."
      elif [ "$CMD" = "start" ]; then
        if [ -e "$RUNTIME_HOME/runtime.pid" ]; then
          if  ps -p $PID > /dev/null ; then
            echo "Process is already running"
            exit 0
          fi
        fi
        export CARBON_HOME=$CARBON_HOME
      # using nohup bash to avoid erros in solaris OS.TODO
        nohup bash $RUNTIME_HOME/bin/carbon.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "stop" ]; then
        export CARBON_HOME=$CARBON_HOME
        kill -term `cat $RUNTIME_HOME/runtime.pid`
        exit 0
      elif [ "$CMD" = "restart" ]; then
        export CARBON_HOME=$CARBON_HOME
        kill -term `cat $RUNTIME_HOME/runtime.pid`
        process_status=0
        pid=`cat $RUNTIME_HOME/runtime.pid`
        while [ "$process_status" -eq "0" ]
        do
              sleep 1;
              ps -p$pid 2>&1 > /dev/null
              process_status=$?
        done
      
      # using nohup bash to avoid erros in solaris OS.TODO
        nohup bash $RUNTIME_HOME/bin/carbon.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "test" ]; then
          JAVACMD="exec "$JAVACMD""
      elif [ "$CMD" = "version" ]; then
        cat $CARBON_HOME/bin/kernel-version.txt
        exit 0
      fi
      
      # ---------- Handle the SSL Issue with proper JDK version --------------------
      jdk_18=`$JAVA_HOME/bin/java -version 2>&1 | grep "1.[8]"`
      if [ "$jdk_18" = "" ]; then
         echo " Starting WSO2 Carbon (in unsupported JDK)"
         echo " [ERROR] CARBON is supported only on JDK 1.8"
      fi
      
      CARBON_XBOOTCLASSPATH=""
      for f in "$CARBON_HOME"/bin/bootstrap/xboot/*.jar
      do
          if [ "$f" != "$CARBON_HOME/bin/bootstrap/xboot/*.jar" ];then
              CARBON_XBOOTCLASSPATH="$CARBON_XBOOTCLASSPATH":$f
          fi
      done
      
      JAVA_ENDORSED_DIRS="$CARBON_HOME/bin/bootstrap/endorsed":"$JAVA_HOME/jre/lib/endorsed":"$JAVA_HOME/lib/endorsed"
      
      CARBON_CLASSPATH=""
      if [ -e "$JAVA_HOME/bin/bootstrap/tools.jar" ]; then
          CARBON_CLASSPATH="$JAVA_HOME/lib/tools.jar"
      fi
      for f in "$CARBON_HOME"/bin/bootstrap/*.jar
      do
          if [ "$f" != "$CARBON_HOME/bin/bootstrap/*.jar" ];then
              CARBON_CLASSPATH="$CARBON_CLASSPATH":$f
          fi
      done
      for t in "$CARBON_HOME"/bin/bootstrap/commons-lang*.jar
      do
          CARBON_CLASSPATH="$CARBON_CLASSPATH":$t
      done
      # For Cygwin, switch paths to Windows format before running java
      if $cygwin; then
        JAVA_HOME=`cygpath --absolute --windows "$JAVA_HOME"`
        CARBON_HOME=`cygpath --absolute --windows "$CARBON_HOME"`
        RUNTIME_HOME=`cygpath --absolute --windows "$RUNTIME_HOME"`
        CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
        JAVA_ENDORSED_DIRS=`cygpath --path --windows "$JAVA_ENDORSED_DIRS"`
        CARBON_CLASSPATH=`cygpath --path --windows "$CARBON_CLASSPATH"`
        CARBON_XBOOTCLASSPATH=`cygpath --path --windows "$CARBON_XBOOTCLASSPATH"`
      fi
      
      # ----- Execute The Requested Command -----------------------------------------
      
      echo JAVA_HOME environment variable is set to $JAVA_HOME
      echo CARBON_HOME environment variable is set to $CARBON_HOME
      echo RUNTIME_HOME environment variable is set to $RUNTIME_HOME
      
      cd "$RUNTIME_HOME"
      
      START_EXIT_STATUS=121
      status=$START_EXIT_STATUS
      
      #To monitor a Carbon server in remote JMX mode on linux host machines, set the below system property.
      #   -Djava.rmi.server.hostname="your.IP.goes.here"
      
      while [ "$status" = "$START_EXIT_STATUS" ]
      do
          $JAVACMD \
          -Xbootclasspath/a:"$CARBON_XBOOTCLASSPATH" \
          -Xms256m -Xmx1024m \
          -XX:+HeapDumpOnOutOfMemoryError \
          -XX:HeapDumpPath="$RUNTIME_HOME/logs/heap-dump.hprof" \
          $JAVA_OPTS \
          -classpath "$CARBON_CLASSPATH" \
          -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" \
          -Djava.io.tmpdir="$CARBON_HOME/tmp" \
          -Dcarbon.registry.root=/ \
          -Djava.command="$JAVACMD" \
          -Dcarbon.home="$CARBON_HOME" \
          -Dwso2.runtime.path="$RUNTIME_HOME" \
          -Dwso2.runtime="$RUNTIME" \
          -Djava.util.logging.config.file="$RUNTIME_HOME/bin/bootstrap/logging.properties" \
          -Djava.security.egd=file:/dev/./urandom \
          -Dfile.encoding=UTF8 \
          -Djavax.net.ssl.keyStore="$CARBON_HOME/resources/security/wso2carbon.jks" \
          -Djavax.net.ssl.keyStorePassword="wso2carbon" \
          -Djavax.net.ssl.trustStore="$CARBON_HOME/resources/security/client-truststore.jks" \
          -Djavax.net.ssl.trustStorePassword="wso2carbon" \
          -javaagent:/home/wso2carbon/prometheus/jmx_prometheus_javaagent-0.12.0.jar=2222:/home/wso2carbon/prometheus/config.yaml \
          org.wso2.carbon.launcher.Main $*
          status=$?
      done

# ConfigMap analytics-conf-worker
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: analytics-conf-worker
  data:
    deployment.yaml: |-
      # Carbon Configuration Parameters
      wso2.carbon:
          # value to uniquely identify a server
        id: ${NODE_IP}
          # server name
        name: WSO2 EI integrator Analytics
          # ports used by this server
        ports:
            # port offset
          offset: 0
        type: wso2-ei-analytics
      wso2.transport.http:
        transportProperties:
        - name: server.bootstrap.socket.timeout
          value: 60
        - name: client.bootstrap.socket.timeout
          value: 60
        - name: latency.metrics.enabled
          value: true
        listenerConfigurations:
        - id: default
          host: 0.0.0.0
          port: 9091
        - id: msf4j-https
          host: 0.0.0.0
          port: 9444
          scheme: https
          keyStoreFile: ${carbon.home}/resources/security/wso2carbon.jks
          keyStorePassword: wso2carbon
          certPass: wso2carbon
        senderConfigurations:
        - id: http-sender
      siddhi.stores.query.api:
        transportProperties:
        - name: server.bootstrap.socket.timeout
          value: 60
        - name: client.bootstrap.socket.timeout
          value: 60
        - name: latency.metrics.enabled
          value: true
        listenerConfigurations:
        - id: default
          host: 0.0.0.0
          port: 7070
        - id: msf4j-https
          host: 0.0.0.0
          port: 7443
          scheme: https
          keyStoreFile: ${carbon.home}/resources/security/wso2carbon.jks
          keyStorePassword: wso2carbon
          certPass: wso2carbon
        # Configuration used for the databridge communication
      databridge.config:
          # No of worker threads to consume events
          # THIS IS A MANDATORY FIELD
        workerThreads: 10
          # Maximum amount of messages that can be queued internally in MB
          # THIS IS A MANDATORY FIELD
        maxEventBufferCapacity: 10000000
          # Queue size; the maximum number of events that can be stored in the queue
          # THIS IS A MANDATORY FIELD
        eventBufferSize: 2000
          # Keystore file path
          # THIS IS A MANDATORY FIELD
        keyStoreLocation: ${sys:carbon.home}/resources/security/wso2carbon.jks
          # Keystore password
          # THIS IS A MANDATORY FIELD
        keyStorePassword: wso2carbon
          # Session Timeout value in mins
          # THIS IS A MANDATORY FIELD
        clientTimeoutMin: 30
          # Data receiver configurations
          # THIS IS A MANDATORY FIELD
        dataReceivers:
            # Data receiver configuration
        - dataReceiver:
              # Data receiver type
              # THIS IS A MANDATORY FIELD
            type: Thrift
              # Data receiver properties
            properties:
              tcpPort: '7612'
              sslPort: '7712'
            # Data receiver configuration
        - dataReceiver:
              # Data receiver type
              # THIS IS A MANDATORY FIELD
            type: Binary
              # Data receiver properties
            properties:
              tcpPort: '9611'
              sslPort: '9711'
              tcpReceiverThreadPoolSize: '100'
              sslReceiverThreadPoolSize: '100'
              hostName: ${NODE_IP}
        # Configuration of the Data Agents - to publish events through databridge
      data.agent.config:
          # Data agent configurations
          # THIS IS A MANDATORY FIELD
        agents:
            # Data agent configuration
        - agentConfiguration:
              # Data agent name
              # THIS IS A MANDATORY FIELD
            name: Thrift
              # Data endpoint class
              # THIS IS A MANDATORY FIELD
            dataEndpointClass: org.wso2.carbon.databridge.agent.endpoint.thrift.ThriftDataEndpoint
              # Data publisher strategy
            publishingStrategy: async
              # Trust store path
            trustStorePath: ${sys:carbon.home}/resources/security/client-truststore.jks
              # Trust store password
            trustStorePassword: wso2carbon
              # Queue Size
            queueSize: 32768
              # Batch Size
            batchSize: 200
              # Core pool size
            corePoolSize: 1
              # Socket timeout in milliseconds
            socketTimeoutMS: 30000
              # Maximum pool size
            maxPoolSize: 1
              # Keep alive time in pool
            keepAliveTimeInPool: 20
              # Reconnection interval
            reconnectionInterval: 30
              # Max transport pool size
            maxTransportPoolSize: 250
              # Max idle connections
            maxIdleConnections: 250
              # Eviction time interval
            evictionTimePeriod: 5500
              # Min idle time in pool
            minIdleTimeInPool: 5000
              # Secure max transport pool size
            secureMaxTransportPoolSize: 250
              # Secure max idle connections
            secureMaxIdleConnections: 250
              # secure eviction time period
            secureEvictionTimePeriod: 5500
              # Secure min idle time in pool
            secureMinIdleTimeInPool: 5000
              # SSL enabled protocols
            sslEnabledProtocols: TLSv1.1,TLSv1.2
              # Ciphers
            ciphers: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
            # Data agent configuration
        - agentConfiguration:
              # Data agent name
              # THIS IS A MANDATORY FIELD
            name: Binary
              # Data endpoint class
              # THIS IS A MANDATORY FIELD
            dataEndpointClass: org.wso2.carbon.databridge.agent.endpoint.binary.BinaryDataEndpoint
              # Data publisher strategy
            publishingStrategy: async
              # Trust store path
            trustStorePath: ${sys:carbon.home}/resources/security/client-truststore.jks
              # Trust store password
            trustStorePassword: wso2carbon
              # Queue Size
            queueSize: 32768
              # Batch Size
            batchSize: 200
              # Core pool size
            corePoolSize: 1
              # Socket timeout in milliseconds
            socketTimeoutMS: 30000
              # Maximum pool size
            maxPoolSize: 1
              # Keep alive time in pool
            keepAliveTimeInPool: 20
              # Reconnection interval
            reconnectionInterval: 30
              # Max transport pool size
            maxTransportPoolSize: 250
              # Max idle connections
            maxIdleConnections: 250
              # Eviction time interval
            evictionTimePeriod: 5500
              # Min idle time in pool
            minIdleTimeInPool: 5000
              # Secure max transport pool size
            secureMaxTransportPoolSize: 250
              # Secure max idle connections
            secureMaxIdleConnections: 250
              # secure eviction time period
            secureEvictionTimePeriod: 5500
              # Secure min idle time in pool
            secureMinIdleTimeInPool: 5000
              # SSL enabled protocols
            sslEnabledProtocols: TLSv1.1,TLSv1.2
              # Ciphers
            ciphers: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
      # This is the main configuration for metrics
      wso2.metrics:
        # Enable Metrics
        enabled: false
        reporting:
          console:
              # The name for the Console Reporter
          - name: Console
              # Enable Console Reporter
            enabled: false
              # Polling Period in seconds.
              # This is the period for polling metrics from the metric registry and printing in the console
            pollingPeriod: 5
      wso2.metrics.jdbc:
        # Data Source Configurations for JDBC Reporters
        dataSource:
            # JNDI name of the data source to be used by the JDBC Reporter.
            # This data source should be defined in a *-datasources.xml file in conf/datasources directory.
        - &JDBC01
          dataSourceName: java:comp/env/jdbc/WSO2MetricsDB
            # Schedule regular deletion of metrics data older than a set number of days.
            # It is recommended that you enable this job to ensure your metrics tables do not get extremely large.
            # Deleting data older than seven days should be sufficient.
          scheduledCleanup:
              # Enable scheduled cleanup to delete Metrics data in the database.
            enabled: true
              # The scheduled job will cleanup all data older than the specified days
            daysToKeep: 3
              # This is the period for each cleanup operation in seconds.
            scheduledCleanupPeriod: 86400
        # The JDBC Reporter is in the Metrics JDBC Core feature
        reporting:
          # The JDBC Reporter configurations will be ignored if the Metrics JDBC Core feature is not available in runtime
          jdbc:
              # The name for the JDBC Reporter
          - name: JDBC
              # Enable JDBC Reporter
            enabled: true
              # Source of Metrics, which will be used to identify each metric in database -->
              # Commented to use the hostname by default
              # source: Carbon
              # Alias referring to the Data Source configuration
            dataSource: *JDBC01
              # Polling Period in seconds.
              # This is the period for polling metrics from the metric registry and updating the database with the values
            pollingPeriod: 60
        # Deployment configuration parameters
      wso2.artifact.deployment:
          # Scheduler update interval
        updateInterval: 5
        # Periodic Persistence Configuration
      state.persistence:
        enabled: true
        intervalInMin: 1
        revisionsToKeep: 2
        persistenceStore: org.wso2.carbon.stream.processor.core.persistence.DBPersistenceStore
        config:
          datasource: WSO2_PERSISTENCE_DB
          table: PERSISTENCE_TABLE
        # Secure Vault Configuration
      wso2.securevault:
        secretRepository:
          type: org.wso2.carbon.secvault.repository.DefaultSecretRepository
          parameters:
            privateKeyAlias: wso2carbon
            keystoreLocation: ${sys:carbon.home}/resources/security/securevault.jks
            secretPropertiesFile: ${sys:carbon.home}/conf/${sys:wso2.runtime}/secrets.properties
        masterKeyReader:
          type: org.wso2.carbon.secvault.reader.DefaultMasterKeyReader
          parameters:
            masterKeyReaderFile: ${sys:carbon.home}/conf/${sys:wso2.runtime}/master-keys.yaml
        # Datasource Configurations
      wso2.datasources:
        dataSources:
        - name: WSO2_CLUSTER_DB
          description: The datasource used by cluster coordinators in HA deployment
          definition:
            type: RDBMS
            configuration:
              connectionTestQuery: SELECT 1
              driverClassName: com.mysql.jdbc.Driver
              idleTimeout: 60000
              isAutoCommit: false
              jdbcUrl: jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2_CLUSTER_DB?useSSL=false
              maxPoolSize: 10
              password: wso2carbon
              username: wso2carbon
              validationTimeout: 30000
          # carbon metrics data source
        - name: WSO2_METRICS_DB
          description: The datasource used for dashboard feature
          jndiConfig:
            name: jdbc/WSO2MetricsDB
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/dashboard/database/metrics;AUTO_SERVER=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 30
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        - name: WSO2_PERMISSIONS_DB
          description: The datasource used for permission feature
          jndiConfig:
            name: jdbc/PERMISSION_DB
            useJndiReference: true
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:h2:${sys:carbon.home}/wso2/${sys:wso2.runtime}/database/PERMISSION_DB;IFEXISTS=TRUE;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000;MVCC=TRUE
              username: wso2carbon
              password: wso2carbon
              driverClassName: org.h2.Driver
              maxPoolSize: 10
              idleTimeout: 60000
              connectionTestQuery: SELECT 1
              validationTimeout: 30000
              isAutoCommit: false
        - name: EI_ANALYTICS
          description: The datasource used for EI Analytics dashboard feature
          jndiConfig:
            name: jdbc/EI_ANALYTICS
          definition:
            type: RDBMS
            configuration:
              jdbcUrl: jdbc:mysql://wso2ei-rdbms-service-mysql:3306/EI_ANALYTICS?useSSL=false
              username: wso2carbon
              password: wso2carbon
              driverClassName: com.mysql.jdbc.Driver
              connectionTestQuery: SELECT 1
              maxPoolSize: 50
              idleTimeout: 60000
              validationTimeout: 30000
              isAutoCommit: false
        - definition:
              configuration:
                username: wso2carbon
                driverClassName: com.mysql.jdbc.Driver
                validationTimeout: 30000
                connectionTestQuery: SELECT 1
                idleTimeout: 60000
                isAutoCommit: false
                maxPoolSize: 50
                password: wso2carbon
                jdbcUrl: jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2_PERSISTENCE_DB?useSSL=false
              type: RDBMS
          name: WSO2_PERSISTENCE_DB
          jndiConfig:
            name: jdbc/WSO2PersistenceDB
          description: The MySQL datasource used for system persistence
      siddhi:
        extensions:
        - extension:
            name: findCountryFromIP
            namespace: geo
            properties:
              geoLocationResolverClass: org.wso2.extension.siddhi.execution.geo.internal.impl.DefaultDBBasedGeoLocationResolver
              isCacheEnabled: true
              cacheSize: 10000
              isPersistInDatabase: true
              datasource: GEO_LOCATION_DATA
        - extension:
            name: findCityFromIP
            namespace: geo
            properties:
              geoLocationResolverClass: org.wso2.extension.siddhi.execution.geo.internal.impl.DefaultDBBasedGeoLocationResolver
              isCacheEnabled: true
              cacheSize: 10000
              isPersistInDatabase: true
              datasource: GEO_LOCATION_DATA
        # Cluster Configuration
      cluster.config:
        enabled: true
        groupId: ei.analytics
        coordinationStrategyClass: org.wso2.carbon.cluster.coordinator.rdbms.RDBMSCoordinationStrategy
        strategyConfig:
          datasource: WSO2_CLUSTER_DB
          heartbeatInterval: 1000
          heartbeatMaxRetry: 2
          eventPollingInterval: 1000
      # Authentication configuration
      auth.configs:
        type: local          # Type of the IdP client used
        userManager:
          adminRole: admin   # Admin role which is granted all permissions
          userStore:         # User store
            users:
            - user:
                username: admin
                password: YWRtaW4=
                roles: 1
            roles:
            - role:
                id: 1
                displayName: admin
      deployment.config:
        byteBufferExtractorThreadPoolSize: 5
        eventByteBufferQueueCapacity: 20000
        type: ha
        eventSyncClientPool:
          maxTotal: 10
          maxActive: 10
          minEvictableIdleTimeMillis: 120000
          maxWait: 60000
          maxIdle: 10
        eventSyncServer:
          workerThreads: 10
          bossThreads: 10
          advertisedPort: 9894
          host: ${NODE_IP}
          advertisedHost: ${NODE_IP}
          port: 9894

# ConfigMap analytics-worker-bin
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: analytics-worker-bin
  data:
    carbon.sh: |-
      #!/bin/sh
      # Main Script for the WSO2 Carbon Server
      #
      # Environment Variable Prequisites
      #
      #   CARBON_HOME   Home of WSO2 Carbon installation. If not set I will  try
      #                   to figure it out.
      #   RUNTIME_HOME  Home of WSO2 Carbon Runtime. .
      #
      #   JAVA_HOME       Must point at your Java Development Kit installation.
      #
      #   JAVA_OPTS       (Optional) Java runtime options used when the commands
      #                   is executed.
      #
      # NOTE: Borrowed generously from Apache Tomcat startup scripts.
      # -----------------------------------------------------------------------------
      
      # OS specific support.  $var _must_ be set to either true or false.
      #ulimit -n 100000
      
      cygwin=false;
      darwin=false;
      os400=false;
      mingw=false;
      case "`uname`" in
      CYGWIN*) cygwin=true;;
      MINGW*) mingw=true;;
      OS400*) os400=true;;
      Darwin*) darwin=true
              if [ -z "$JAVA_VERSION" ] ; then
                   JAVA_VERSION="CurrentJDK"
                 else
                   echo "Using Java version: $JAVA_VERSION"
                 fi
                 if [ -z "$JAVA_HOME" ] ; then
                   JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/${JAVA_VERSION}/Home
                 fi
                 ;;
      esac
      
      # resolve links - $0 may be a softlink
      PRG="$0"
      
      while [ -h "$PRG" ]; do
        ls=`ls -ld "$PRG"`
        link=`expr "$ls" : '.*-> \(.*\)$'`
        if expr "$link" : '.*/.*' > /dev/null; then
          PRG="$link"
        else
          PRG=`dirname "$PRG"`/"$link"
        fi
      done
      
      # Get standard environment variables
      TEMPCURDIR=`dirname "$PRG"`
      
      # Only set RUNTIME_HOME if not already set
      [ -z "$RUNTIME_HOME" ] && RUNTIME_HOME=`cd "$TEMPCURDIR/.." ; pwd`
      
      # Only set CARBON_HOME if not already set
      [ -z "$CARBON_HOME" ] && CARBON_HOME=`cd "$TEMPCURDIR/../../../" ; pwd`
      
      # Only set RUNTIME if not already set
      [ -z "$RUNTIME" ] && RUNTIME=${RUNTIME_HOME##*/}
      
      # For Cygwin, ensure paths are in UNIX format before anything is touched
      if $cygwin; then
        [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
        [ -n "$CARBON_HOME" ] && CARBON_HOME=`cygpath --unix "$CARBON_HOME"`
        [ -n "$RUNTIME_HOME" ] && RUNTIME_HOME=`cygpath --unix "$RUNTIME_HOME"`
      fi
      
      # For OS400
      if $os400; then
        # Set job priority to standard for interactive (interactive - 6) by using
        # the interactive priority - 6, the helper threads that respond to requests
        # will be running at the same priority as interactive jobs.
        COMMAND='chgjob job('$JOBNAME') runpty(6)'
        system $COMMAND
      
        # Enable multi threading
        QIBM_MULTI_THREADED=Y
        export QIBM_MULTI_THREADED
      fi
      
      # For Migwn, ensure paths are in UNIX format before anything is touched
      if $mingw ; then
        [ -n "$CARBON_HOME" ] &&
          CARBON_HOME="`(cd "$CARBON_HOME"; pwd)`"
        [ -n "$JAVA_HOME" ] &&
          JAVA_HOME="`(cd "$JAVA_HOME"; pwd)`"
        # TODO classpath?
      fi
      
      if [ -z "$JAVACMD" ] ; then
        if [ -n "$JAVA_HOME"  ] ; then
          if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
            # IBM's JDK on AIX uses strange locations for the executables
            JAVACMD="$JAVA_HOME/jre/sh/java"
          else
            JAVACMD="$JAVA_HOME/bin/java"
          fi
        else
          JAVACMD=java
        fi
      fi
      
      if [ ! -x "$JAVACMD" ] ; then
        echo "Error: JAVA_HOME is not defined correctly."
        echo " CARBON cannot execute $JAVACMD"
        exit 1
      fi
      
      # if JAVA_HOME is not set we're not happy
      if [ -z "$JAVA_HOME" ]; then
        echo "You must set the JAVA_HOME variable before running CARBON."
        exit 1
      fi
      
      if [ -e "$RUNTIME_HOME/runtime.pid" ]; then
        PID=`cat "$RUNTIME_HOME"/runtime.pid`
      fi
      
      # ----- Process the input command ----------------------------------------------
      args=""
      for c in $*
      do
          if [ "$c" = "--debug" ] || [ "$c" = "-debug" ] || [ "$c" = "debug" ]; then
                CMD="--debug"
                continue
          elif [ "$CMD" = "--debug" ]; then
                if [ -z "$PORT" ]; then
                      PORT=$c
                fi
          elif [ "$c" = "--stop" ] || [ "$c" = "-stop" ] || [ "$c" = "stop" ]; then
                CMD="stop"
          elif [ "$c" = "--start" ] || [ "$c" = "-start" ] || [ "$c" = "start" ]; then
                CMD="start"
          elif [ "$c" = "--version" ] || [ "$c" = "-version" ] || [ "$c" = "version" ]; then
                CMD="version"
          elif [ "$c" = "--restart" ] || [ "$c" = "-restart" ] || [ "$c" = "restart" ]; then
                CMD="restart"
          elif [ "$c" = "--test" ] || [ "$c" = "-test" ] || [ "$c" = "test" ]; then
                CMD="test"
          else
              args="$args $c"
          fi
      done
      
      if [ "$CMD" = "--debug" ]; then
        if [ "$PORT" = "" ]; then
          echo " Please specify the debug port after the --debug option"
          exit 1
        fi
        if [ -n "$JAVA_OPTS" ]; then
          echo "Warning !!!. User specified JAVA_OPTS will be ignored, once you give the --debug option."
        fi
        CMD="RUN"
        JAVA_OPTS="-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=$PORT"
        echo "Please start the remote debugging client to continue..."
      elif [ "$CMD" = "start" ]; then
        if [ -e "$RUNTIME_HOME/runtime.pid" ]; then
          if  ps -p $PID > /dev/null ; then
            echo "Process is already running"
            exit 0
          fi
        fi
        export CARBON_HOME=$CARBON_HOME
      # using nohup bash to avoid erros in solaris OS.TODO
        nohup bash $RUNTIME_HOME/bin/carbon.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "stop" ]; then
        export CARBON_HOME=$CARBON_HOME
        kill -term `cat $RUNTIME_HOME/runtime.pid`
        exit 0
      elif [ "$CMD" = "restart" ]; then
        export CARBON_HOME=$CARBON_HOME
        kill -term `cat $RUNTIME_HOME/runtime.pid`
        process_status=0
        pid=`cat $RUNTIME_HOME/runtime.pid`
        while [ "$process_status" -eq "0" ]
        do
              sleep 1;
              ps -p$pid 2>&1 > /dev/null
              process_status=$?
        done
      
      # using nohup bash to avoid erros in solaris OS.TODO
        nohup bash $RUNTIME_HOME/bin/carbon.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "test" ]; then
          JAVACMD="exec "$JAVACMD""
      elif [ "$CMD" = "version" ]; then
        cat $CARBON_HOME/bin/kernel-version.txt
        exit 0
      fi
      
      # ---------- Handle the SSL Issue with proper JDK version --------------------
      jdk_18=`$JAVA_HOME/bin/java -version 2>&1 | grep "1.[8]"`
      if [ "$jdk_18" = "" ]; then
         echo " Starting WSO2 Carbon (in unsupported JDK)"
         echo " [ERROR] CARBON is supported only on JDK 1.8"
      fi
      
      CARBON_XBOOTCLASSPATH=""
      for f in "$CARBON_HOME"/bin/bootstrap/xboot/*.jar
      do
          if [ "$f" != "$CARBON_HOME/bin/bootstrap/xboot/*.jar" ];then
              CARBON_XBOOTCLASSPATH="$CARBON_XBOOTCLASSPATH":$f
          fi
      done
      
      JAVA_ENDORSED_DIRS="$CARBON_HOME/bin/bootstrap/endorsed":"$JAVA_HOME/jre/lib/endorsed":"$JAVA_HOME/lib/endorsed"
      
      CARBON_CLASSPATH=""
      if [ -e "$JAVA_HOME/bin/bootstrap/tools.jar" ]; then
          CARBON_CLASSPATH="$JAVA_HOME/lib/tools.jar"
      fi
      for f in "$CARBON_HOME"/bin/bootstrap/*.jar
      do
          if [ "$f" != "$CARBON_HOME/bin/bootstrap/*.jar" ];then
              CARBON_CLASSPATH="$CARBON_CLASSPATH":$f
          fi
      done
      for t in "$CARBON_HOME"/bin/bootstrap/commons-lang*.jar
      do
          CARBON_CLASSPATH="$CARBON_CLASSPATH":$t
      done
      # For Cygwin, switch paths to Windows format before running java
      if $cygwin; then
        JAVA_HOME=`cygpath --absolute --windows "$JAVA_HOME"`
        CARBON_HOME=`cygpath --absolute --windows "$CARBON_HOME"`
        RUNTIME_HOME=`cygpath --absolute --windows "$RUNTIME_HOME"`
        CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
        JAVA_ENDORSED_DIRS=`cygpath --path --windows "$JAVA_ENDORSED_DIRS"`
        CARBON_CLASSPATH=`cygpath --path --windows "$CARBON_CLASSPATH"`
        CARBON_XBOOTCLASSPATH=`cygpath --path --windows "$CARBON_XBOOTCLASSPATH"`
      fi
      
      # ----- Execute The Requested Command -----------------------------------------
      
      echo JAVA_HOME environment variable is set to $JAVA_HOME
      echo CARBON_HOME environment variable is set to $CARBON_HOME
      echo RUNTIME_HOME environment variable is set to $RUNTIME_HOME
      
      cd "$RUNTIME_HOME"
      
      START_EXIT_STATUS=121
      status=$START_EXIT_STATUS
      
      #To monitor a Carbon server in remote JMX mode on linux host machines, set the below system property.
      #   -Djava.rmi.server.hostname="your.IP.goes.here"
      
      while [ "$status" = "$START_EXIT_STATUS" ]
      do
          $JAVACMD \
          -Xbootclasspath/a:"$CARBON_XBOOTCLASSPATH" \
          -Xms256m -Xmx1024m \
          -XX:+HeapDumpOnOutOfMemoryError \
          -XX:HeapDumpPath="$RUNTIME_HOME/logs/heap-dump.hprof" \
          $JAVA_OPTS \
          -classpath "$CARBON_CLASSPATH" \
          -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" \
          -Djava.io.tmpdir="$CARBON_HOME/tmp" \
          -Dcarbon.registry.root=/ \
          -Djava.command="$JAVACMD" \
          -Dcarbon.home="$CARBON_HOME" \
          -Dwso2.runtime.path="$RUNTIME_HOME" \
          -Dwso2.runtime="$RUNTIME" \
          -Djava.util.logging.config.file="$RUNTIME_HOME/bin/bootstrap/logging.properties" \
          -Djava.security.egd=file:/dev/./urandom \
          -Dfile.encoding=UTF8 \
          -Djavax.net.ssl.keyStore="$CARBON_HOME/resources/security/wso2carbon.jks" \
          -Djavax.net.ssl.keyStorePassword="wso2carbon" \
          -Djavax.net.ssl.trustStore="$CARBON_HOME/resources/security/client-truststore.jks" \
          -Djavax.net.ssl.trustStorePassword="wso2carbon" \
          -javaagent:/home/wso2carbon/prometheus/jmx_prometheus_javaagent-0.12.0.jar=2222:/home/wso2carbon/prometheus/config.yaml \
          org.wso2.carbon.launcher.Main $*
          status=$?
      done

# ConfigMap mb-conf-axis2
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mb-conf-axis2
  data:
    axis2.xml: |-
      <axisconfig name="AxisJava2.0">
          <!-- ================================================= -->
          <!-- Globally engaged modules -->
          <!-- ================================================= -->
          <module ref="addressing"/>
      
          <!-- ================================================= -->
          <!-- Parameters -->
          <!-- ================================================= -->
          <parameter name="hotdeployment">true</parameter>
          <parameter name="hotupdate">true</parameter>
          <parameter name="enableMTOM" locked="false">optional</parameter>
          <parameter name="cacheAttachments">true</parameter>
          <parameter name="attachmentDIR">work/mtom</parameter>
          <parameter name="sizeThreshold">4000</parameter>
      
          <parameter name="EnableChildFirstClassLoading">${childfirstCL}</parameter>
      
          <!--
          The exposeServiceMetadata parameter decides whether the metadata (WSDL, schema, policy) of
          the services deployed on Axis2 should be visible when ?wsdl, ?wsdl2, ?xsd, ?policy requests
          are received.
          This parameter can be defined in the axi2.xml file, in which case this will be applicable
          globally, or in the services.xml files, in which case, it will be applicable to the
          Service groups and/or services, depending on the level at which the parameter is declared.
          This value of this parameter defaults to true.
          -->
          <parameter name="exposeServiceMetadata">true</parameter>
      
          <!--If turned on with use the Accept header of the request to determine the contentType of the
          response-->
          <parameter name="httpContentNegotiation">true</parameter>
      
          <!--
          Defines how the persistence of WS-ReliableMessaging is handled
      
          Possible value are: inmemory & persistent
          -->
          <!-- Following parameter will completely disable REST handling in both the servlets-->
          <parameter name="disableREST" locked="false">false</parameter>
      
          <parameter name="Sandesha2StorageManager">inmemory</parameter>
      
          <!-- This deployment interceptor will be called whenever before a module is initialized or
           service is deployed -->
          <listener class="org.wso2.carbon.core.deployment.DeploymentInterceptor"/>
      
          <!-- setting servicePath. contextRoot is defined in the carbon.xml file -->
          <!-- modification of this variable should be accompanied by the change in 'ServerURL' in carbon.xml file -->
          <parameter name="servicePath">services</parameter>
      
          <!--the directory in which .aar services are deployed inside axis2 repository-->
          <parameter name="ServicesDirectory">axis2services</parameter>
      
          <!--the directory in which modules are deployed inside axis2 repository-->
          <parameter name="ModulesDirectory">axis2modules</parameter>
      
          <parameter name="userAgent" locked="true">WSO2 EI 6.6.0 - Broker</parameter>
          <parameter name="server" locked="true">WSO2 EI 6.6.0 - Broker</parameter>
      
          <!-- ========================================================================-->
      
          <!--During a fault, stacktrace can be sent with the fault message. The following flag will control -->
          <!--that behaviour.-->
          <parameter name="sendStacktraceDetailsWithFaults">false</parameter>
      
          <!--If there aren't any information available to find out the fault reason, we set the message of the expcetion-->
          <!--as the faultreason/Reason. But when a fault is thrown from a service or some where, it will be -->
          <!--wrapped by different levels. Due to this the initial exception message can be lost. If this flag-->
          <!--is set then, Axis2 tries to get the first exception and set its message as the faultreason/Reason.-->
          <parameter name="DrillDownToRootCauseForFaultReason">false</parameter>
      
          <!--Set the flag to true if you want to enable transport level session mangment-->
          <parameter name="manageTransportSession">true</parameter>
      
          <!-- Synapse Configuration file -->
          <parameter name="SynapseConfig.ConfigurationFile" locked="false">
              ./repository/deployment/server/synapse-configs
          </parameter>
      
          <!-- Synapse Home parameter -->
          <parameter name="SynapseConfig.HomeDirectory" locked="false">.</parameter>
      
          <!-- Resolve root used to resolve synapse references like schemas inside a WSDL -->
          <parameter name="SynapseConfig.ResolveRoot" locked="false">.</parameter>
      
          <!-- Synapse Server name parameter -->
          <parameter name="SynapseConfig.ServerName" locked="false">WSO2 Carbon Server</parameter>
      
          <!--By default, JAXWS services are created by reading annotations. WSDL and schema are generated-->
          <!--using a separate WSDL generator only when ?wsdl is called. Therefore, even if you engage-->
          <!--policies etc.. to AxisService, it doesn't appear in the WSDL. By setting the following property-->
          <!--to true, you can create the AxisService using the generated WSDL and remove the need for a-->
          <!--WSDL generator. When ?wsdl is called, WSDL is generated in the normal way.-->
          <parameter name="useGeneratedWSDLinJAXWS">${jaxwsparam}</parameter>
      
          <!-- Deployer for the dataservice. -->
          <!--<deployer extension="dbs" directory="dataservices" class="org.wso2.dataservices.DBDeployer"/>-->
      
          <!-- Axis1 deployer for Axis2-->
          <!--<deployer extension="wsdd" class="org.wso2.carbon.axis1services.Axis1Deployer" directory="axis1services"/>-->
      
          <!-- POJO service deployer for Jar -->
          <!--<deployer extension="jar" class="org.apache.axis2.deployment.POJODeployer" directory="pojoservices"/>-->
      
          <!-- POJO service deployer for Class  -->
          <!--<deployer extension="class" class="org.apache.axis2.deployment.POJODeployer" directory="pojoservices"/>-->
      
          <!-- JAXWS service deployer  -->
          <!--<deployer extension=".jar" class="org.apache.axis2.jaxws.framework.JAXWSDeployer" directory="servicejars"/>-->
          <!-- ================================================= -->
          <!-- Message Receivers -->
          <!-- ================================================= -->
          <!--This is the Default Message Receiver for the system , if you want to have MessageReceivers for -->
          <!--all the other MEP implement it and add the correct entry to here , so that you can refer from-->
          <!--any operation -->
          <!--Note : You can ovride this for particular service by adding the same element with your requirement-->
      
          <messageReceivers>
              <messageReceiver mep="http://www.w3.org/ns/wsdl/in-only"
                               class="org.apache.axis2.rpc.receivers.RPCInOnlyMessageReceiver"/>
              <messageReceiver mep="http://www.w3.org/ns/wsdl/robust-in-only"
                               class="org.apache.axis2.rpc.receivers.RPCInOnlyMessageReceiver"/>
              <messageReceiver mep="http://www.w3.org/ns/wsdl/in-out"
                               class="org.apache.axis2.rpc.receivers.RPCMessageReceiver"/>
          </messageReceivers>
      
          <messageFormatters>
              <messageFormatter contentType="application/x-www-form-urlencoded"
                                class="org.apache.axis2.transport.http.XFormURLEncodedFormatter"/>
              <messageFormatter contentType="multipart/form-data"
                                class="org.apache.axis2.transport.http.MultipartFormDataFormatter"/>
              <messageFormatter contentType="application/xml"
                                class="org.apache.axis2.transport.http.ApplicationXMLFormatter"/>
              <messageFormatter contentType="text/xml"
                                class="org.apache.axis2.transport.http.SOAPMessageFormatter"/>
              <messageFormatter contentType="application/soap+xml"
                                class="org.apache.axis2.transport.http.SOAPMessageFormatter"/>
      
              <!--JSON Message Formatters-->
              <!--messageFormatter contentType="application/json"
                                class="org.apache.axis2.json.JSONMessageFormatter"/-->
              <messageFormatter contentType="application/json"
                                class="org.apache.axis2.json.gson.JsonFormatter" />
              <messageFormatter contentType="application/json/badgerfish"
                                class="org.apache.axis2.json.JSONBadgerfishMessageFormatter"/>
              <!--messageFormatter contentType="text/javascript"
                                class="org.apache.axis2.json.JSONMessageFormatter"/-->
              <messageFormatter contentType="text/javascript"
                                class="org.apache.axis2.json.gson.JsonFormatter" />
      
              <!--messageFormatter contentType="application/x-www-form-urlencoded"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="multipart/form-data"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="application/xml"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="text/html"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="application/soap+xml"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="x-application/hessian"
      			class="org.apache.synapse.format.hessian.HessianMessageFormatter"/-->
              <!--<messageFormatter contentType="">
      			class="org.apache.synapse.format.hessian.HessianMessageFormatter"/-->
          </messageFormatters>
      
          <messageBuilders>
              <messageBuilder contentType="application/xml"
                              class="org.apache.axis2.builder.ApplicationXMLBuilder"/>
              <messageBuilder contentType="application/x-www-form-urlencoded"
                              class="org.apache.axis2.builder.XFormURLEncodedBuilder"/>
              <messageBuilder contentType="multipart/form-data"
                              class="org.apache.axis2.builder.MultipartFormDataBuilder"/>
      
              <!--JSON Message Builders-->
              <!--messageBuilder contentType="application/json"
                              class="org.apache.axis2.json.JSONOMBuilder"/-->
              <messageBuilder contentType="application/json"
                              class="org.apache.axis2.json.gson.JsonBuilder" />
              <messageBuilder contentType="application/json/badgerfish"
                              class="org.apache.axis2.json.JSONBadgerfishOMBuilder"/>
              <!--messageBuilder contentType="text/javascript"
                              class="org.apache.axis2.json.JSONOMBuilder"/-->
              <messageBuilder contentType="text/javascript"
                              class="org.apache.axis2.json.gson.JsonBuilder" />
      
              <!--messageBuilder contentType="application/xml"
           		        class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="application/x-www-form-urlencoded"
                              class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="multipart/form-data"
                              class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="multipart/related"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="application/soap+xml"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="text/plain"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="text/xml"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageFormatter contentType="text/plain"
                              class="org.apache.axis2.format.PlainTextBuilder"/-->
              <!--messageBuilder contentType="x-application/hessian"
      		       class="org.apache.synapse.format.hessian.HessianMessageBuilder"/-->
          </messageBuilders>
      
      
          <!-- ================================================= -->
          <!-- In Transports -->
          <!-- ================================================= -->
          <transportReceiver name="http"
                             class="org.wso2.carbon.core.transports.http.HttpTransportListener">
              <!--
                 Uncomment the following if you are deploying this within an application server. You
                 need to specify the HTTP port of the application server
              -->
              <parameter name="port">9763</parameter>
      
              <!--
             Uncomment the following to enable any proxy like Apache2 mod_proxy or any load balancer. The port on the proxy server like Apache is 80
             in this case.
              -->
              <!--<parameter name="proxyPort">80</parameter>-->
          </transportReceiver>
      
          <!--Please uncomment this in Multiple Instance Scenario if you want to use NIO Transport Recievers and
       	Remove the current transport REceivers in axis2.xml -->
          <!--transportReceiver name="http" class="org.apache.synapse.transport.nhttp.HttpCoreNIOListener">
              <parameter name="port" locked="false">8280</parameter>
              <parameter name="non-blocking" locked="false">true</parameter>
          </transportReceiver>
      
          <transportReceiver name="https" class="org.apache.synapse.transport.nhttp.HttpCoreNIOSSLListener">
              <parameter name="port" locked="false">8243</parameter>
              <parameter name="non-blocking" locked="false">true</parameter>
              <parameter name="keystore" locked="false">
                  <KeyStore>
                      <Location>repository/resources/security/wso2carbon.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                      <KeyPassword>wso2carbon</KeyPassword>
                  </KeyStore>
              </parameter>
              <parameter name="truststore" locked="false">
                  <TrustStore>
                      <Location>repository/resources/security/client-truststore.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                  </TrustStore>
              </parameter>
          </transportReceiver-->
      
      
          <transportReceiver name="https"
                             class="org.wso2.carbon.core.transports.http.HttpsTransportListener">
              <!--
                 Uncomment the following if you are deploying this within an application server. You
                 need to specify the HTTPS port of the application server
              -->
              <parameter name="port">9443</parameter>
      
              <!--
             Uncomment the following to enable any proxy like Apache2 mod_proxy or any load balancer. The port on a proxy server like Apache is 443
             in this case.
              -->
              <!--<parameter name="proxyPort">443</parameter>-->
          </transportReceiver>
      
          <!--
             Uncomment the following segment to enable TCP transport.
             Note : Addressing module should be engaged for TCP transport to work
          -->
          <!--<transportReceiver name="tcp"
                             class="org.apache.axis2.transport.tcp.TCPServer">
              <parameter name="port">6667</parameter>
          </transportReceiver>-->
      
          <!--
           To Enable Mail Transport Listener, please uncomment the following.
          -->
          <!--<transportReceiver name="mailto" class="org.apache.axis2.transport.mail.MailTransportListener">
      
          </transportReceiver>-->
      
      
          <!--
            Uncomment this and configure as appropriate for JMS transport support,
            after setting up your JMS environment (e.g. ActiveMQ)
          -->
          <!--<transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
              <parameter name="myTopicConnectionFactory">
              	<parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              	<parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
              	<parameter name="transport.jms.ConnectionFactoryJNDIName">TopicConnectionFactory</parameter>
              </parameter>
      
              <parameter name="myQueueConnectionFactory">
              	<parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              	<parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
              	<parameter name="transport.jms.ConnectionFactoryJNDIName">QueueConnectionFactory</parameter>
              </parameter>
      
              <parameter name="default">
              	<parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              	<parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
              	<parameter name="transport.jms.ConnectionFactoryJNDIName">QueueConnectionFactory</parameter>
              </parameter>
          </transportReceiver>-->
      
          <!--Uncomment this and configure as appropriate for JMS transport support with Apache Qpid -->
          <!--transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
              <parameter name="myTopicConnectionFactory" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.apache.qpid.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">TopicConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">topic</parameter>
              </parameter>
      
              <parameter name="myQueueConnectionFactory" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.apache.qpid.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
      
              <parameter name="default" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.apache.qpid.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
          </transportReceiver-->
      
          <!--Uncomment this and configure as appropriate for JMS transport support with WSO2 EI Broker Profile -->
          <!--transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
              <parameter name="myTopicConnectionFactory" locked="false">
                 <parameter name="java.naming.factory.initial" locked="false">org.wso2.andes.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">TopicConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">topic</parameter>
              </parameter>
      
              <parameter name="myQueueConnectionFactory" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.wso2.andes.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                 <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
      
              <parameter name="default" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.wso2.andes.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
          </transportReceiver-->
      
      
          <!-- ================================================= -->
          <!-- Out Transports -->
          <!-- ================================================= -->
      
          <!--transportSender name="tcp"
                           class="org.apache.axis2.transport.tcp.TCPTransportSender"/-->
          <transportReceiver name="local"
                             class="org.wso2.carbon.core.transports.local.CarbonLocalTransportReceiver"/>
          <transportSender name="local"
                           class="org.wso2.carbon.core.transports.local.CarbonLocalTransportSender"/>
          <!--<transportSender name="jms"
                           class="org.apache.axis2.transport.jms.JMSSender"/>-->
          <transportSender name="http"
                           class="org.apache.axis2.transport.http.CommonsHTTPTransportSender">
              <parameter name="PROTOCOL">HTTP/1.1</parameter>
              <parameter name="Transfer-Encoding">chunked</parameter>
              <!-- This parameter has been added to overcome problems encounted in SOAP action parameter -->
              <parameter name="OmitSOAP12Action">true</parameter>
          </transportSender>
          <transportSender name="https"
                           class="org.apache.axis2.transport.http.CommonsHTTPTransportSender">
              <parameter name="PROTOCOL">HTTP/1.1</parameter>
              <parameter name="Transfer-Encoding">chunked</parameter>
              <!-- This parameter has been added to overcome problems encounted in SOAP action parameter -->
              <parameter name="OmitSOAP12Action">true</parameter>
          </transportSender>
      
          <!-- To enable mail transport sender, ncomment the following and change the parameters
               accordingly-->
          <!--<transportSender name="mailto"
                           class="org.apache.axis2.transport.mail.MailTransportSender">
              <parameter name="mail.smtp.from">wso2demomail@gmail.com</parameter>
              <parameter name="mail.smtp.user">wso2demomail</parameter>
              <parameter name="mail.smtp.password">mailpassword</parameter>
              <parameter name="mail.smtp.host">smtp.gmail.com</parameter>
      
              <parameter name="mail.smtp.port">587</parameter>
              <parameter name="mail.smtp.starttls.enable">true</parameter>
              <parameter name="mail.smtp.auth">true</parameter>
          </transportSender>-->
      
          <!--Please uncomment this in Multiple Instance Scenario if you want to use NIO sender -->
          <!--
          <transportSender name="http" class="org.apache.synapse.transport.nhttp.HttpCoreNIOSender">
              <parameter name="non-blocking" locked="false">true</parameter>
          </transportSender>
          <transportSender name="https" class="org.apache.synapse.transport.nhttp.HttpCoreNIOSSLSender">
              <parameter name="non-blocking" locked="false">true</parameter>
              <parameter name="keystore" locked="false">
                  <KeyStore>
                      <Location>repository/resources/security/wso2carbon.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                      <KeyPassword>wso2carbon</KeyPassword>
                  </KeyStore>
              </parameter>
              <parameter name="truststore" locked="false">
                  <TrustStore>
                      <Location>repository/resources/security/client-truststore.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                  </TrustStore>
              </parameter>
          </transportSender>
      	-->
      
      
          <!-- ================================================= -->
          <!-- Phases  -->
          <!-- ================================================= -->
          <phaseOrder type="InFlow">
              <!--  System pre defined phases       -->
              <!--
                 The MsgInObservation phase is used to observe messages as soon as they are
                 received. In this phase, we could do some things such as SOAP message tracing & keeping
                 track of the time at which a particular message was received
      
                 NOTE: This should be the very first phase in this flow
              -->
              <phase name="MsgInObservation"/>
      
              <phase name="Validation"/>
              <phase name="Transport">
                  <handler name="RequestURIBasedDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher">
                      <order phase="Transport"/>
                  </handler>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
                      <order phase="Transport"/>
                  </handler>
                  <handler name="RequestURIOperationDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher" />
                  <handler name="JSONMessageHandler"
                           class="org.apache.axis2.json.gson.JSONMessageHandler" />
              </phase>
              <phase name="Addressing">
                  <handler name="AddressingBasedDispatcher"
                           class="org.wso2.carbon.core.multitenancy.MultitenantAddressingBasedDispatcher">
                      <order phase="Addressing"/>
                  </handler>
              </phase>
              <phase name="Ghost">
                  <handler name="GhostDispatcher"
                           class="org.wso2.carbon.core.dispatchers.GhostDispatcher"/>
              </phase>
              <phase name="Security"/>
              <phase name="PreDispatch"/>
              <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
                  <handler name="RequestURIBasedDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher"/>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
                  <handler name="SOAPMessageBodyBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
      
                  <handler name="HTTPLocationBasedDispatcher"
                           class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
              </phase>
              <!--  System pre defined phases       -->
              <phase name="RMPhase"/>
              <phase name="OpPhase"/>
              <!--   After Postdispatch phase module author or or service author can add any phase he want      -->
              <phase name="OperationInPhase"/>
          </phaseOrder>
          <phaseOrder type="OutFlow">
              <!-- Handlers related to unified-endpoint component are added to the UEPPhase -->
              <phase name="UEPPhase"/>
              <phase name="RMPhase"/>
              <phase name="OpPhase"/>
              <!--      user can add his own phases to this area  -->
              <phase name="OperationOutPhase"/>
              <!--system predefined phase-->
              <!--these phase will run irrespective of the service-->
              <phase name="PolicyDetermination"/>
              <phase name="MessageOut"/>
              <phase name="Security"/>
      
              <!--
                 The MsgOutObservation phase is used to observe messages just before the
                 responses are sent out. In this phase, we could do some things such as SOAP message
                 tracing & keeping track of the time at which a particular response was sent.
      
                 NOTE: This should be the very last phase in this flow
              -->
              <phase name="MsgOutObservation"/>
              <!--Following phase is added to publish stats -->
              <phase name="StatReporting"/>
          </phaseOrder>
          <phaseOrder type="InFaultFlow">
              <!--  System pre defined phases       -->
              <!--
                 The MsgInObservation phase is used to observe messages as soon as they are
                 received. In this phase, we could do some things such as SOAP message tracing & keeping
                 track of the time at which a particular message was received
      
                 NOTE: This should be the very first phase in this flow
              -->
              <phase name="MsgInObservation"/>
      
              <phase name="Validation"/>
              <phase name="Transport">
                  <handler name="RequestURIBasedDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher">
                      <order phase="Transport"/>
                  </handler>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
                      <order phase="Transport"/>
                  </handler>
              </phase>
      
              <phase name="Addressing">
                  <handler name="AddressingBasedDispatcher"
                           class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
                      <order phase="Addressing"/>
                  </handler>
              </phase>
              <phase name="Ghost">
                  <handler name="GhostDispatcher"
                           class="org.wso2.carbon.core.dispatchers.GhostDispatcher"/>
              </phase>
              <phase name="Security"/>
              <phase name="PreDispatch"/>
              <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
                  <handler name="RequestURIBasedDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher"/>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
                  <handler name="SOAPMessageBodyBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
      
                  <handler name="HTTPLocationBasedDispatcher"
                           class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
              </phase>
              <phase name="RMPhase"/>
              <phase name="OpPhase"/>
              <!--      user can add his own phases to this area  -->
              <phase name="OperationInFaultPhase"/>
          </phaseOrder>
          <phaseOrder type="OutFaultFlow">
              <!-- Handlers related to unified-endpoint component are added to the UEPPhase -->
              <phase name="UEPPhase"/>
              <phase name="RMPhase"/>
              <!--      user can add his own phases to this area  -->
              <phase name="OperationOutFaultPhase"/>
              <phase name="PolicyDetermination"/>
              <phase name="MessageOut"/>
              <phase name="Security"/>
              <phase name="Transport"/>
              <!--
                 The MsgOutObservation phase is used to observe messages just before the
                 responses are sent out. In this phase, we could do some things such as SOAP message
                 tracing & keeping track of the time at which a particular response was sent.
      
                 NOTE: This should be the very last phase in this flow
              -->
              <phase name="MsgOutObservation"/>
              <!--Following phase is added to publish stats -->
              <phase name="StatReporting"/>
          </phaseOrder>
      
          <clustering class="org.wso2.carbon.core.clustering.hazelcast.HazelcastClusteringAgent"
                      enable="true">
      
              <!--
                 This parameter indicates whether the cluster has to be automatically initalized
                 when the AxisConfiguration is built. If set to "true" the initialization will not be
                 done at that stage, and some other party will have to explictly initialize the cluster.
              -->
              <parameter name="AvoidInitiation">true</parameter>
      
              <!--
                 The membership scheme used in this setup. The only values supported at the moment are
                 "multicast" and "wka"
      
                 1. multicast - membership is automatically discovered using multicasting
                 2. wka - Well-Known Address based multicasting. Membership is discovered with the help
                          of one or more nodes running at a Well-Known Address. New members joining a
                          cluster will first connect to a well-known node, register with the well-known node
                          and get the membership list from it. When new members join, one of the well-known
                          nodes will notify the others in the group. When a member leaves the cluster or
                          is deemed to have left the cluster, it will be detected by the Group Membership
                          Service (GMS) using a TCP ping mechanism.
              -->
              <parameter name="membershipScheme">kubernetes</parameter>
              <!--<parameter name="licenseKey">xxx</parameter>-->
              <!--<parameter name="mgtCenterURL">http://localhost:8081/mancenter/</parameter>-->
      
              <!--
               The clustering domain/group. Nodes in the same group will belong to the same multicast
               domain. There will not be interference between nodes in different groups.
              -->
              <parameter name="domain">wso2.mb.domain</parameter>
      
              <!-- The multicast address to be used -->
              <!--<parameter name="mcastAddress">228.0.0.4</parameter>-->
      
              <!-- The multicast port to be used -->
              <parameter name="mcastPort">45564</parameter>
      
              <parameter name="mcastTTL">100</parameter>
      
              <parameter name="mcastTimeout">60</parameter>
      
              <!--
                 The IP address of the network interface to which the multicasting has to be bound to.
                 Multicasting would be done using this interface.
              -->
              <!--
                  <parameter name="mcastBindAddress">127.0.0.1</parameter>
              -->
              <!-- The host name or IP address of this member -->
      
              <parameter name="localMemberHost">mb</parameter>
      
              <!--
                  The bind adress of this member. The difference between localMemberHost & localMemberBindAddress
                  is that localMemberHost is the one that is advertised by this member, while localMemberBindAddress
                  is the address to which this member is bound to.
              -->
              <!--
              <parameter name="localMemberBindAddress">127.0.0.1</parameter>
              -->
      
              <!--
              The TCP port used by this member. This is the port through which other nodes will
              contact this member
               -->
              <parameter name="localMemberPort">4000</parameter>
      
              <!--
                  The bind port of this member. The difference between localMemberPort & localMemberBindPort
                  is that localMemberPort is the one that is advertised by this member, while localMemberBindPort
                  is the port to which this member is bound to.
              -->
              <!--
              <parameter name="localMemberBindPort">4001</parameter>
              -->
      
              <!--
              Properties specific to this member
              -->
              <parameter name="properties">
                  <property name="backendServerURL" value="https://${hostName}:${httpsPort}/services/"/>
                  <property name="mgtConsoleURL" value="https://${hostName}:${httpsPort}/"/>
                  <property name="subDomain" value="worker"/>
              </parameter>
      
              <parameter name="membershipSchemeClassName">org.wso2.carbon.membership.scheme.kubernetes.KubernetesMembershipScheme</parameter>
              <parameter name="KUBERNETES_NAMESPACE">${OPENSHIFT_PROJECT_NAME}</parameter>
              <parameter name="KUBERNETES_SERVICES">wso2ei-pattern-2-mb-service</parameter>
              <parameter name="KUBERNETES_MASTER_SKIP_SSL_VERIFICATION">true</parameter>
              <parameter name="USE_DNS">false</parameter>
      
              <!--
              Uncomment the following section to load custom Hazelcast data serializers.
              -->
              <!--
              <parameter name="hazelcastSerializers">
                  <serializer typeClass="java.util.TreeSet">org.wso2.carbon.hazelcast.serializer.TreeSetSerializer
                  </serializer>
                  <serializer typeClass="java.util.Map">org.wso2.carbon.hazelcast.serializer.MapSerializer</serializer>
              </parameter>
              -->
      
              <!--
              Enable the groupManagement entry if you need to run this node as a cluster manager.
              Multiple application domains with different GroupManagementAgent implementations
              can be defined in this section.
              -->
              <groupManagement enable="false">
                  <applicationDomain name="wso2.as.domain"
                                     description="AS group"
                                     agent="org.wso2.carbon.core.clustering.hazelcast.HazelcastGroupManagementAgent"
                                     subDomain="worker"
                                     port="2222"/>
              </groupManagement>
          </clustering>
      </axisconfig>

# ConfigMap mb-conf-datasources
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mb-conf-datasources
  data:
    master-datasources.xml: |-
      <?xml version='1.0' encoding='UTF-8'?>
      <datasources-configuration>
        <providers>
          <provider>org.wso2.carbon.ndatasource.rdbms.RDBMSDataSourceReader</provider>
        </providers>
        <datasources>
          <!-- For an explanation of the properties, see: http://people.apache.org/~fhanik/jdbc-pool/jdbc-pool.html -->
          <!--datasource>
                  <name>SAMPLE_DATA_SOURCE</name>
                  <jndiConfig>
                      <name></name>
                      <environment>
                          <property name="java.naming.factory.initial"></property>
                          <property name="java.naming.provider.url"></property>
                      </environment>
                  </jndiConfig>
                  <definition type="RDBMS">
                      <configuration>
                          <defaultAutoCommit></defaultAutoCommit>
                          <defaultReadOnly></defaultReadOnly>
                          <defaultTransactionIsolation>NONE|READ_COMMITTED|READ_UNCOMMITTED|REPEATABLE_READ|SERIALIZABLE</defaultTransactionIsolation>
                          <defaultCatalog></defaultCatalog>
                          <username></username>
                          <password svns:secretAlias="WSO2.DB.Password"></password>
                          <maxActive></maxActive>
                          <maxIdle></maxIdle>
                          <initialSize></initialSize>
                          <maxWait></maxWait>
      
                          <dataSourceClassName>com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</dataSourceClassName>
                          <dataSourceProps>
                              <property name="url">jdbc:mysql://localhost:3306/Test1</property>
                              <property name="user">root</property>
                              <property name="password">123</property>
                          </dataSourceProps>
      
                      </configuration>
                  </definition>
              </datasource-->
          <datasource>
            <name>WSO2_CARBON_DB</name>
            <description>The datasource used for registry and user manager</description>
            <jndiConfig>
              <name>jdbc/WSO2CarbonDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:h2:./repository/database/WSO2CARBON_DB;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>org.h2.Driver</driverClassName>
                <maxActive>50</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
              </configuration>
            </definition>
          </datasource>
          <!-- WSO2 MB embedded H2 Store     -->
          <datasource>
            <name>WSO2_MB_STORE_DB</name>
            <description>The datasource used for message broker database</description>
            <jndiConfig>
              <name>WSO2MBStoreDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2EI_MB_DB?autoReconnect=true&amp;useSSL=false</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>com.mysql.jdbc.Driver</driverClassName>
                <maxActive>50</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
                <defaultAutoCommit>false</defaultAutoCommit>
              </configuration>
            </definition>
          </datasource>
          <!-- MySQL data source -->
          <!--
              <datasource>
                   <name>WSO2_MB_STORE_DB</name>
                   <jndiConfig>
                       <name>WSO2MBStoreDB</name>
                   </jndiConfig>
                   <definition type="RDBMS">
                       <configuration>
                           <driverClassName>com.mysql.jdbc.Driver</driverClassName>
                           <url>jdbc:mysql://localhost/wso2_mb</url>
                           <username>root</username>
                           <password>root</password>
                           <maxActive>50</maxActive>
                           <maxWait>60000</maxWait>
                           <minIdle>5</minIdle>
                           <testOnBorrow>true</testOnBorrow>
                           <validationQuery>SELECT 1</validationQuery>
                          <validationInterval>30000</validationInterval>
                          <defaultAutoCommit>false</defaultAutoCommit>
                       </configuration>
                   </definition>
               </datasource>
      -->
          <!-- MSSQL server -->
          <!-- Please enable any one of the following datasource based on your MSSQL driver library -->
          <!-- JTDS datasource -->
          <!--
              <datasource>
                  <name>WSO2_MB_STORE_DB</name>
                  <jndiConfig>
                      <name>WSO2MBStoreDB</name>
                  </jndiConfig>
                  <definition type="RDBMS">
                  <configuration>
                          <url>jdbc:jtds:sqlserver://localhost:1433/wso2_mb</url>
                          <username>sa</username>
                          <password>sa</password>
                          <driverClassName>net.sourceforge.jtds.jdbc.Driver</driverClassName>
                          <maxActive>200</maxActive>
                          <maxWait>60000</maxWait>
                          <minIdle>5</minIdle>
                          <testOnBorrow>true</testOnBorrow>
                          <validationQuery>SELECT 1</validationQuery>
                          <validationInterval>30000</validationInterval>
                          <defaultAutoCommit>false</defaultAutoCommit>
                      </configuration>
                  </definition>
              </datasource>
      -->
          <!-- SQLServerXA datasource -->
          <!--
              <datasource>
                  <name>WSO2_MB_STORE_DB</name>
                  <jndiConfig>
                      <name>WSO2MBStoreDB</name>
                  </jndiConfig>
                  <definition type="RDBMS">
                      <configuration>
                          <defaultAutoCommit>false</defaultAutoCommit>
                          <dataSourceClassName>com.microsoft.sqlserver.jdbc.SQLServerXADataSource</dataSourceClassName>
                          <dataSourceProps>
                      <property name = "URL">jdbc:sqlserver://localhost/SQLExpress:1433</property>
                      <property name="databaseName">wso2_mb</property>
                              <property name="user">sa</property>
                              <property name="password">sa</property>
                          </dataSourceProps>
                      </configuration>
                  </definition>
              </datasource>
      -->
          <!-- Oracle datasource -->
          <!--
              <datasource>
                  <name>WSO2_MB_STORE_DB</name>
                  <jndiConfig>
                      <name>WSO2MBStoreDB</name>
                  </jndiConfig>
                  <definition type="RDBMS">
                      <configuration>
                          <driverClassName>oracle.jdbc.driver.OracleDriver</driverClassName>
                          <url>jdbc:oracle:thin:@localhost:1521/orcl</url>
                          <maxActive>100</maxActive>
                          <maxWait>60000</maxWait>
                          <minIdle>5</minIdle>
                          <testOnBorrow>true</testOnBorrow>
                          <validationQuery>SELECT 1 FROM DUAL</validationQuery>
                          <validationInterval>30000</validationInterval>
                          <username>scott</username>
                          <password>tiger</password>
                          <defaultAutoCommit>false</defaultAutoCommit>
                      </configuration>
                  </definition>
              </datasource>
      -->
          <!-- Postgresql datasource -->
          <!--
                      <datasource>
                          <name>WSO2_MB_STORE_DB</name>
                          <jndiConfig>
                              <name>WSO2MBStoreDB</name>
                          </jndiConfig>
                          <definition type="RDBMS">
                          <configuration>
                                  <url>jdbc:postgresql://localhost/wso2_mb</url>
                                  <username>postgres</username>
                                  <password>postgres</password>
                                  <driverClassName>org.postgresql.Driver</driverClassName>
                                  <validationQuery>SELECT 1</validationQuery>
                                  <validationInterval>30000</validationInterval>
                                  <defaultAutoCommit>false</defaultAutoCommit>
                              </configuration>
                          </definition>
                      </datasource>
      -->
          <datasource>
            <name>WSO2_CONFIG_DB</name>
            <description>The datasource used for config registry</description>
            <jndiConfig>
              <name>jdbc/WSO2ConfigDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2EI_INTEGRATOR_CONFIG_GOV_DB?autoReconnect=true&amp;useSSL=false</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>com.mysql.jdbc.Driver</driverClassName>
                <maxActive>80</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
              </configuration>
            </definition>
          </datasource>
          <datasource>
            <name>WSO2_USER_DB</name>
            <description>The datasource is used for user management and userstore</description>
            <jndiConfig>
              <name>jdbc/WSO2UserDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2EI_USER_DB?autoReconnect=true&amp;useSSL=false</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>com.mysql.jdbc.Driver</driverClassName>
                <maxActive>50</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
              </configuration>
            </definition>
          </datasource>
        </datasources>
      </datasources-configuration>

# ConfigMap mb-conf-entrypoint
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mb-conf-entrypoint
  data:
    docker-entrypoint.sh: |
      #!/bin/bash

      set -e

      # volume mounts
      config_volume=${WORKING_DIRECTORY}/wso2-config-volume
      artifact_volume=${WORKING_DIRECTORY}/wso2-artifact-volume

      # check if the WSO2 non-root user home exists
      test ! -d ${WORKING_DIRECTORY} && echo "WSO2 Docker non-root user home does not exist" && exit 1

      # check if the WSO2 product home exists
      test ! -d ${WSO2_SERVER_HOME} && echo "WSO2 Docker product home does not exist" && exit 1

      # copy any configuration changes mounted to config_volume
      test -d ${config_volume} && [[ "$(ls -A ${config_volume})" ]] && cp -RL ${config_volume}/* ${WSO2_SERVER_HOME}/
      # copy any artifact changes mounted to artifact_volume
      test -d ${artifact_volume} && [[ "$(ls -A ${artifact_volume})" ]] && cp -RL ${artifact_volume}/* ${WSO2_SERVER_HOME}/

      # make any node specific configuration changes
      # set the Docker container IP as the `localMemberHost` under axis2.xml clustering configurations (effective only when clustering is enabled)
      sed -i "s#<parameter\ name=\"localMemberHost\".*<\/parameter>#<parameter\ name=\"localMemberHost\">${NODE_IP}<\/parameter>#" ${WSO2_SERVER_HOME}/wso2/broker/conf/axis2/axis2.xml
      # set the Docker container IP as the Apache Thrift server host IP
      sed -i "s#<thriftServerHost>.*</thriftServerHost>#<thriftServerHost>${NODE_IP}</thriftServerHost>#" ${WSO2_SERVER_HOME}/wso2/broker/conf/broker.xml

      # start WSO2 Carbon server
      sh ${WSO2_SERVER_HOME}/bin/broker.sh "$@"

# ConfigMap mb-conf
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: mb-conf
  data:
    broker.xml: |-
      <?xml version='1.0' encoding='ISO-8859-1' standalone='no'?>
      <!-- This is the root configuration file of WSO2 Message Broker (MB). Links to configurations of 
      associated libraries are also specified here. 
      
      [Note for developers] - If you intend to rename or modify a property name, remember to update 
      relevant, org.wso2.andes.configuration.enums.AndesConfiguration, enum value using the Xpath 
      expression of the property.
      
      This file is ciphertool compliant. Refer PRODUCT_HOME/repository/conf/security/cipher-text.properties for examples.-->
      <broker>
        <coordination>
          <!-- You can override the cluster node identifier of this MB node using the nodeID. 
              If it is left as "default", the default node ID will be generated for it. (Using IP + UUID).
              The node ID of each member should ALWAYS be unique.-->
          <nodeID>default</nodeID>
          <!-- Thrift is used to maintain and sync slot (message groups) ranges between MB nodes. -->
          <thriftServerHost>wso2ei-broker</thriftServerHost>
          <thriftServerPort>7614</thriftServerPort>
          <thriftSOTimeout>0</thriftSOTimeout>
          <!--Thrift server reconnect timeout. Value specified in SECONDS-->
          <thriftServerReconnectTimeout>5</thriftServerReconnectTimeout>
          <!-- Hazelcast reliable topics are used to share all notifications across the MB cluster (e.g. subscription
              changes), And this property defines the time-to-live for a notification since its creation. (in Seconds) -->
          <clusterNotificationTimeout>10</clusterNotificationTimeout>
          <!-- Configurations related RDBMS based coordination algorithm -->
          <rdbmsBasedCoordination enabled="true">
            <!-- Heartbeat interval used in the RDBMS base coordination algorithm in milliseconds -->
            <heartbeatInterval>5000</heartbeatInterval>
            <!-- Time to wait before informing others about coordinator change in milliseconds. This value should be
                  larger than a database read time including network latency and should be less than heartbeatInterval -->
            <coordinatorEntryCreationWaitTime>3000</coordinatorEntryCreationWaitTime>
            <!-- Time interval used to poll database for membership related events in milliseconds. -->
            <eventPollingInterval>4000</eventPollingInterval>
          </rdbmsBasedCoordination>
          <!-- Enabling this will make the cluster notifications such as Queue changes(additions and deletions),
              Subscription changes, etc. sent within the cluster be synchronized using RDBMS. If set to false, Hazelcast
              will be used for this purpose.-->
          <rdbmsBasedClusterEventSynchronization enabled="true">
            <!--Specifies the interval at which, the cluster events will be read from the database. Needs to be
                  declared in milliseconds. Setting this to a very low value could downgrade the performance where as
                  setting this to a large value could increase the time taken for a cluster event to be synchronized in
                  all the nodes in a cluster.-->
            <eventSyncInterval>1000</eventSyncInterval>
          </rdbmsBasedClusterEventSynchronization>
        </coordination>
        <!-- You can enable/disable specific messaging transports in this section. By default all 
          transports are enabled. This section also allows you to customize the messaging flows used 
          within WSO2 MB. NOT performance related, but logic related. -->
        <transports>
          <amqp enabled="true">
            <bindAddress>0.0.0.0</bindAddress>
            <defaultConnection enabled="true" port="5672"/>
            <sslConnection enabled="true" port="8672">
              <keyStore>
                <location>repository/resources/security/wso2carbon.jks</location>
                <password>wso2carbon</password>
                <certType>SunX509</certType>
              </keyStore>
              <trustStore>
                <location>repository/resources/security/client-truststore.jks</location>
                <password>wso2carbon</password>
                <certType>SunX509</certType>
              </trustStore>
              <!--Configure SSL protocols for AMQP transport.
                       (TLSv1,TLSv1.1,TLSv1.2) -->
              <sslEnabledProtocols>TLSv1</sslEnabledProtocols>
              <!--Configure preferred cipher suites for AMQP transport.
                       (TLS_DHE_RSA_WITH_AES_256_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA) -->
              <!--<ciphers></ciphers> -->
            </sslConnection>
            <maximumRedeliveryAttempts>10</maximumRedeliveryAttempts>
            <allowSharedTopicSubscriptions>false</allowSharedTopicSubscriptions>
            <allowStrictNameValidation>true</allowStrictNameValidation>
            <!-- Refer repository/conf/advanced/qpid-config.xml for further AMQP-specific configurations.-->
          </amqp>
          <mqtt enabled="true">
            <bindAddress>0.0.0.0</bindAddress>
            <defaultConnection enabled="true" port="1883"/>
            <sslConnection enabled="true" port="8883">
              <keyStore>
                <location>repository/resources/security/wso2carbon.jks</location>
                <password>wso2carbon</password>
                <certType>SunX509</certType>
              </keyStore>
              <trustStore>
                <location>repository/resources/security/client-truststore.jks</location>
                <password>wso2carbon</password>
                <certType>SunX509</certType>
              </trustStore>
            </sslConnection>
            <!--All receiving events/messages will be in this ring buffer. Ring buffer size
                  of MQTT inbound event disruptor. Default is set to 32768 (1024 * 32)
                  Having a large ring buffer will have a increase memory usage and will improve performance
                  and vise versa -->
            <inboundBufferSize>32768</inboundBufferSize>
            <!-- Messages delivered to clients will be placed in this ring buffer. 
                  Ring buffer size of MQTT delivery event disruptor. Default is set to 32768 (1024 * 32)
                  Having a large ring buffer will have a increase memory usage and will improve performance
                  and vise versa -->
            <deliveryBufferSize>32768</deliveryBufferSize>
            <security>
              <!--
                             Instructs the MQTT server whether clients should always send credentials
                             when establishing a connection.
                             Possible values:
                              OPTIONAL: This is the default value. MQTT clients may or may not send 
                                        credentials. If a client sends credentials server will 
                                        validates it. 
                                        If client doesn't send credentials then server will not 
                                        authenticate, but allows client to establish the connection. 
                                        This behavior adheres to MQTT 3.1 specification.
                              REQUIRED: Clients should always provide credentials when connecting. 
                                        If client doesn't send credentials or they are invalid 
                                        server rejects the connection.
                         -->
              <authentication>OPTIONAL</authentication>
              <!--Class name of the authenticator to use. class should 
                             inherit from org.dna.mqtt.moquette.server.IAuthenticator
                             Note: default implementation authenticates against carbon user store
                             based on supplied username/password
                         -->
              <authenticator class="org.wso2.carbon.andes.authentication.andes.CarbonBasedMQTTAuthenticator"/>
              <!--authenticator class="org.wso2.carbon.andes.authentication.andes.OAuth2BasedMQTTAuthenticator">
                              <property name="hostURL">https://localhost:9443/services/OAuth2TokenValidationService</property>
                              <property name="username">admin</property>
                              <property name="password">admin</property>
                              <property name="maxConnectionsPerHost">10</property>
                              <property name="maxTotalConnections">150</property>
                          </authenticator-->
              <!--
                             Instructs the MQTT server whether clients should be authorized before either publishing or subscribing
                             Possible values:
                              NOT_REQUIRED: This is the default value. MQTT clients will skip the authorization check
                              REQUIRED: Clients will authorized before publishing. this will execute the class given in authorzier
                              Note: authentication should be REQUIRED for authorization to be REQUIRED.
                         -->
              <authorization>NOT_REQUIRED</authorization>
              <!--Class name of the authorizer to use. class should
                              inherit from org.dna.mqtt.moquette.server.IAutherizer
                              Note: default implementation authorizes against carbon permission with the topic.
                          -->
              <!--connectionPermission is required for a user to connect to broker-->
              <authorizer class="org.wso2.carbon.andes.authorization.andes.CarbonPermissionBasedMQTTAuthorizer">
                <property name="connectionPermission">/permission/admin/mqtt/connect</property>
              </authorizer>
            </security>
          </mqtt>
        </transports>
        <!-- Depending on the database type selected in master-datasources.xml, you must enable the
          relevant Data access classes here. Currently WSO2 MB Supports RDBMS(any RDBMS store). 
      	These stores are accessed for two purposes.
      	
          1. For message persistence ("messageStore")
          2. To persist and access other information relevant to messaging protocols.("contextStore").-->
        <!-- By default WSO2 MB runs with H2 persistent store. If you plan to use a different
          store, point to the relevant dataSource or uncomment the database appropriately.
      
          RDBMS
          =====
          If you are running an RDBMS you can use the existing RDBMS implementation of stores
          by pointing to the correct data source by updating the property "dataSource".
      
          Data source entry should be present in
          <MB_HOME>/repository/conf/datasources/master-datasources.xml.
      
          -->
        <persistence>
          <!-- RDBMS MB Store Configuration -->
          <messageStore class="org.wso2.andes.store.rdbms.RDBMSMessageStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
            <property name="storeUnavailableSQLStateClasses">08</property>
            <property name="integrityViolationSQLStateClasses">23,27,44</property>
            <property name="dataErrorSQLStateClasses">21,22</property>
            <property name="transactionRollbackSQLStateClasses">40</property>
          </messageStore>
          <contextStore class="org.wso2.andes.store.rdbms.RDBMSAndesContextStoreImpl">
            <property name="dataSource">WSO2MBStoreDB</property>
            <property name="storeUnavailableSQLStateClasses">08</property>
            <property name="integrityViolationSQLStateClasses">23,27,44</property>
            <property name="dataErrorSQLStateClasses">21,22</property>
            <property name="transactionRollbackSQLStateClasses">40</property>
          </contextStore>
          <cache>
            <!-- Size of the messages cache in MBs. Setting '0' will disable the cache. -->
            <size>256</size>
            <!-- Expected concurrency for the cache (4 is guava default) -->
            <concurrencyLevel>4</concurrencyLevel>
            <!--Number of seconds cache will keep messages after they are 
                                    added (unless they are consumed and deleted).-->
            <expirySeconds>2</expirySeconds>
            <!--Reference type used to hold messages in memory.
                          weak   - Using java weak references ( - results higher cache misses)
                          strong - ordinary references ( - higher cache hits, but not good if server 
                                   is going to run with limited heap size + under severe load).
                  -->
            <valueReferenceType>strong</valueReferenceType>
            <!--Prints cache statistics in 2 minute intervals 
                                                         in carbon log ( and console)-->
            <printStats>false</printStats>
          </cache>
          <!-- This class decides how unique IDs are generated for the MB node. This id generator is
              expected to be thread safe and a implementation of interface
              org.wso2.andes.server.cluster.coordination.MessageIdGenerator
      
              NOTE: This is NOT used in MB to generate message IDs. -->
          <idGenerator>org.wso2.andes.server.cluster.coordination.TimeStampBasedMessageIdGenerator</idGenerator>
          <!-- This is the Task interval (in SECONDS) to check whether communication 
              is healthy between message store (/Database) and this server instance. -->
          <storeHealthCheckInterval>10</storeHealthCheckInterval>
        </persistence>
        <!--Publisher transaction related configurations.-->
        <transaction>
          <!--Maximum batch size (Messages) in kilobytes for a transaction. Exceeding this limit will
               result in a failure in the subsequent commit (or prepare) request. Default is set to 1MB.
               Limit is calculated considering the payload of messages.-->
          <maxBatchSizeInKB>10240</maxBatchSizeInKB>
          <!-- Maximum number of parallel dtx enabled channel count. Distributed transaction
               requests exceeding this limit will fail. -->
          <maxParallelDtxChannels>20</maxParallelDtxChannels>
          <!-- Maximum wait time (in seconds) for a transactional publisher commit,
               rollback or close event to complete on server side -->
          <maxWaitTimeout>30</maxWaitTimeout>
        </transaction>
        <!-- This section allows you to tweak memory and processor allocations used by WSO2 MB.
          Broken down by critical processes so you have a clear view of which parameters to change in
          different scenarios.  -->
        <performanceTuning>
          <slots>
            <!--Rough estimate for size of a slot. What is meant by size is the number of messages
                  contained within bounties of a slot. -->
            <windowSize>1000</windowSize>
            <!--
                  If message publishers are slow, time taken to fill the slot (up to <windowSize>) will be longer.
                  This will add an latency to messages. Therefore broker will mark the slot as
                  ready to deliver before even the slot is entirely filled after specified time.
                  NOTE: specified in milliseconds.
                  -->
            <messageAccumulationTimeout>2000</messageAccumulationTimeout>
            <!-- Time interval which broker check for slots that can be marked as 'ready to deliver' 
                       (- slots which have a aged more than 'messageAccumulationTimeout')
                       NOTE: specified in milliseconds.
                  -->
            <maxSubmitDelay>1000</maxSubmitDelay>
            <!--Number of MessageDeliveryWorker threads that should be started-->
            <deliveryThreadCount>5</deliveryThreadCount>
            <!-- The idle time of a delivery task. Decreasing value might effect increasing delivery when the 
                       publisher is slow. But system load could go high -->
            <idleTaskDelay>100</idleTaskDelay>
            <!-- Number of parallel threads to execute slot deletion task. Increasing this value will remove slots
                       whose messages are read/delivered to consumers/acknowledged faster reducing heap memory used by
                       server.-->
            <deleteThreadCount>5</deleteThreadCount>
            <!-- Max number of pending message count to delete per Slot Deleting Task. This config is used to raise
                   a WARN when pending scheduled number of slots exceeds this limit (indicate of an  issue that can lead to
                   message accumulation on server.-->
            <SlotDeleteQueueDepthWarningThreshold>1000</SlotDeleteQueueDepthWarningThreshold>
            <!-- Maximum number of thrift client connections that should be created in the thrift connection pool -->
            <thriftClientPoolSize>10</thriftClientPoolSize>
          </slots>
          <delivery>
            <!-- Maximum number of undelivered messages that can have in memory. Increasing this
                  value increase the possibility of out of memory scenario but performance will be
                  improved -->
            <maxNumberOfReadButUndeliveredMessages>1000</maxNumberOfReadButUndeliveredMessages>
            <!-- This is the ring buffer size of the delivery disruptor. This value should be a
                  power of 2 (E.g. 1024, 2048, 4096). Use a small ring size if you want to reduce the
                  memory usage. -->
            <ringBufferSize>4096</ringBufferSize>
            <!--Number of parallel readers used to used to read content from message store.
                  Increasing this value will speed-up the message sending mechanism. But the load
                  on the data store will increase. -->
            <parallelContentReaders>5</parallelContentReaders>
            <!-- Number of parallel decompression handlers used to decompress messages before send to subscribers.
                  Increasing this value will speed-up the message decompressing mechanism. But the system load
                  will increase. -->
            <parallelDecompressionHandlers>5</parallelDecompressionHandlers>
            <!-- Number of parallel delivery handlers used to send messages to subscribers.
                  Increasing this value will speed-up the message sending mechanism. But the system load
                  will increase. -->
            <parallelDeliveryHandlers>5</parallelDeliveryHandlers>
            <!-- The size of the batch represents, at a given time the number of messages that could 
                  be retrieved from the database. -->
            <contentReadBatchSize>65000</contentReadBatchSize>
            <contentCache>
              <!-- Specify the maximum number of entries the cache may contain. -->
              <maximumSize>100</maximumSize>
              <!-- Specify the time in seconds that each entry should be 
                           automatically removed from the cache after the entry's creation. -->
              <expiryTime>120</expiryTime>
            </contentCache>
            <!--When delivering topic messages to multiple topic 
                      subscribers one of following stratigies can be choosen.
                  
                     1. DISCARD_NONE     - Broker do not loose any message to any subscriber. 
                                           When there are slow subscribers this can cause broker 
                                           go Out of Memory.
      
                     2. SLOWEST_SUB_RATE - Broker deliver to the speed of the slowest
                                           topic subscriber. This can cause fast subscribers
                                           to starve. But eliminate Out of Memory issue.
      
                     3. DISCARD_ALLOWED  - Broker will try best to deliver. To eliminate Out
                                           of Memory threat broker limits sent but not acked message 
                                           count to <maxUnackedMessages>. 
                                           If it is breached, and <deliveryTimeout> is also 
                                           breached message can either be lost or actually 
                                           sent but ack is not honoured.
                  -->
            <topicMessageDeliveryStrategy>
              <strategyName>DISCARD_NONE</strategyName>
              <!-- If you choose DISCARD_ALLOWED topic message delivery strategy, 
                           broker keep messages in memory until ack is done until this timeout.
                           If an ack is not received under this timeout, ack will be simulated 
                           internally and real acknowledgement is discarded.
                           deliveryTimeout is in seconds -->
              <deliveryTimeout>60</deliveryTimeout>
            </topicMessageDeliveryStrategy>
          </delivery>
          <ackHandling>
            <!--Number of message acknowledgement handlers to process acknowledgements concurrently.
                  These acknowledgement handlers will batch and process acknowledgements.  -->
            <ackHandlerCount>1</ackHandlerCount>
            <!--Maximum batch size of the acknowledgement handler. Andes process acknowledgements in
                  batches using Disruptor Increasing the batch size reduces the number of calls made to
                  database by MB. Depending on the database optimal batch size this value should be set.
                  Batches will be of the maximum batch size mostly in high throughput scenarios.
                  Underlying implementation use Disruptor for batching hence will batch message at a
                  lesser value than this in low throughput scenarios -->
            <ackHandlerBatchSize>100</ackHandlerBatchSize>
            <!-- Message delivery from server to the client will be paused temporarily if number of
                  delivered but unacknowledged message count reaches this size. Should be set considering
                  message consume rate. This is to avoid overwhelming slow subscribers. -->
            <maxUnackedMessages>1000</maxUnackedMessages>
          </ackHandling>
          <contentHandling>
            <!-- Within Andes there are content chunk handlers which convert incoming large content
                  chunks into max content chunk size allowed by Andes core. These handlers run in parallel
                  converting large content chunks to smaller chunks.
      
                  If the protocol specific content chunk size is different from the max chunk size allowed
                  by Andes core and there are significant number of large messages published, then having
                  multiple handlers will increase performance. -->
            <contentChunkHandlerCount>3</contentChunkHandlerCount>
            <!-- Andes core will store message content chunks according to this chunk size. Different
                  database will have limits and performance gains by tuning this parameter.
      
                  For instance in MySQL the maximum table column size for content is less than 65534, which
                  is the default chunk size of AMQP. By changing this parameter to a lesser value we can
                  store large content chunks converted to smaller content chunks within the DB with this
                  parameter. -->
            <maxContentChunkSize>65500</maxContentChunkSize>
            <!-- This is the configuration to allow compression of message contents, before store messages
                  into the database.-->
            <allowCompression>false</allowCompression>
            <!-- This is the configuration to change the value of the content compression threshold (in bytes).
                  Message contents less than this value will not compress, even compression is enabled. The recommended
                  message size of the smallest message before compression is 13bytes. Compress messages smaller than
                  13bytes will expand the message size by 0.4% -->
            <contentCompressionThreshold>1000</contentCompressionThreshold>
          </contentHandling>
          <inboundEvents>
            <!--Number of parallel writers used to write content to message store. Increasing this
                  value will speed-up the message receiving mechanism. But the load on the data store will
                  increase.-->
            <parallelMessageWriters>1</parallelMessageWriters>
            <!--Size of the Disruptor ring buffer for inbound event handling. For publishing at
                  higher rates increasing the buffer size may give some advantage on keeping messages in
                  memory and write.
      
                  NOTE: Buffer size should be a value of power of two -->
            <bufferSize>65536</bufferSize>
            <!--Maximum batch size of the batch write operation for inbound messages. MB internals
                  use Disruptor to batch events. Hence this batch size is set to avoid database requests
                  with high load (with big batch sizes) to write messages. This need to be configured in
                  high throughput messaging scenarios to regulate the hit on database from MB -->
            <messageWriterBatchSize>70</messageWriterBatchSize>
            <!--Timeout for waiting for a queue purge event to end to get the purged count. Doesn't
                  affect actual purging. If purge takes time, increasing the value will improve the
                  possibility of retrieving the correct purged count. Having a lower value doesn't stop
                  purge event. Getting the purged count is affected by this -->
            <purgedCountTimeout>180</purgedCountTimeout>
            <!--Number of parallel writers used to write content to message store for transaction
                  based publishing. Increasing this value will speedup commit duration for a transaction.
                  But the load on the data store will increase.-->
            <transactionMessageWriters>1</transactionMessageWriters>
          </inboundEvents>
          <!--Message expiration can be set for each messages which are published to Wso2 MB.
               After the expiration time, the messages will not be delivered to the consumers. Eventually
               they got deleted inside the MB.-->
          <messageExpiration>
            <!-- When messages delivered, in the delivery path messages were checked whether they are
                  already expired. If expired at that time add that message to a queue for a future batch
                  delete. This interval decides on the time gap between the batch deletes. Time interval
                  specified in seconds.-->
            <preDeliveryExpiryDeletionInterval>10</preDeliveryExpiryDeletionInterval>
            <!-- Periodically check the database for new expired messages which were not assigned to
                   any slot delivery worker so far and delete them. This interval decides on the time gap between
                   the periodic message deletion. Time interval specified in seconds.-->
            <periodicMessageDeletionInterval>900</periodicMessageDeletionInterval>
            <!-- When checking the database for expired messages, the messages which were handled by the slot
                  delivery worker should no be touched since that mess up the slot delivery worker functionality.
                  Those messages anyways get caught at the message delivery path. So there is a need to have a safe
                  buffer of slots which can be allocated to a slot delivery worker in the near future. The specified
                  number of slots from the last assigned should not be touched by the periodic deletion task.-->
            <safetySlotCount>3</safetySlotCount>
            <!--By default expired messages are removed from broker. Instead, to move expired messages to 
                  Dead Letter Channel make this to true-->
            <moveExpiredMessagesToDLC>false</moveExpiredMessagesToDLC>
          </messageExpiration>
        </performanceTuning>
        <!-- This section is about how you want to view messaging statistics from the admin console and
          how you plan to interact with it. -->
        <managementConsole>
          <!--Maximum number of messages to be fetched per page using Andes message browser when browsing
              queues/dlc -->
          <messageBrowsePageSize>100</messageBrowsePageSize>
          <!-- This property defines the maximum message content length that can be displayed at the
              management console when browsing queues. If the message length exceeds the value, a
              truncated content will be displayed with a statement "message content too large to display."
              at the end. default value is 100000 (can roughly display a 100KB message.)
              * NOTE : Increasing this value could cause delays when loading the message content page.-->
          <maximumMessageDisplayLength>100000</maximumMessageDisplayLength>
        </managementConsole>
        <!-- Memory and resource exhaustion is something we should prevent and recover from.
          This section allows you to specify the threshold at which to reduce/stop frequently intensive
          operations within MB temporarily. -->
        <!--
      	highLimit - flow control is enabled when message chunk pending to be handled by inbound 
      	 disruptor reaches above this limit
          lowLimit - flow control is disabled (if enabled) when message chunk pending to be handled
      	 by inbound disruptor reaches below this limit	
      	-->
        <flowControl>
          <!-- This is the global buffer limits which enable/disable the flow control globally -->
          <global>
            <lowLimit>800</lowLimit>
            <highLimit>8000</highLimit>
          </global>
          <!-- This is the channel specific buffer limits which enable/disable the flow control locally.
      		-->
          <bufferBased>
            <lowLimit>100</lowLimit>
            <highLimit>1000</highLimit>
          </bufferBased>
        </flowControl>
        <!--
          Message broker keeps track of all messages it has received as groups. These groups are termed
          'Slots' (To know more information about Slots and message broker install please refer to online wiki).
          Size of a slot is loosely determined by the configuration <windowSize> (and the number of
          parallel publishers for specific topic/queue). Message broker cluster (or in single node) keeps
          track of slots which constitutes for a large part of operating state before the cluster went down.
      	When first message broker node of the cluster starts up, it will read the database to recreate
          the internal state to previous state. 
          -->
        <recovery>
          <!--
              There could be multiple storage queues worked before entire cluster (or single node) went down.
              We need to recover all remaining messages of each storage queue when first node startup and we can
              read remaining message concurrently of each storage queue. Default value to set here to 5. You can
              increase this value based on number of storage queues exist. Please use optimal value based on
              number of storage queues to speed up warm startup.
              -->
          <concurrentStorageQueueReads>5</concurrentStorageQueueReads>
          <!-- Virtual host sync interval seconds in for the Virtual host syncing Task which will
                  sync the Virtual host details across the cluster -->
          <vHostSyncTaskInterval>900</vHostSyncTaskInterval>
          <!--
               Enables network partition detection ( and surrounding functionality, such
               as disconnecting subscriptions, enabling error based flow control if the
               minimal node count becomes less than configured value.
              -->
          <networkPartitionsDetection enabled="false">
            <!--
                      The minimum node count the cluster should maintain for this node to
                      operate. if cluster size becomes less that configured value
                      This node will not accept any incoming traffic ( and disconnect
                      subscriptions) etc.
                     -->
            <minimumClusterSize>2</minimumClusterSize>
          </networkPartitionsDetection>
        </recovery>
        <!--
              Specifies the deployment mode for the broker node (and cluster). Possible values {default, standalone}.
      
              default - Broker node will decide to run HA (master/slave) or fully distributed mode. Decision is taken based
                        on the node has a clustering mechanism enabled or not. If the node is not configured to join a cluster
                        it will run in HA mode (refer to axis2.xml for more information). If the node can join a cluster it
                        will start in fully clustered mode.
      
              standalone - This is the simplest mode a broker can be started. Node will assume datastore is not shared with
                           another node. Therefore it will not try to coordinate with other nodes (possibly non-existent) to
                           provide HA or clustering.
          -->
        <deployment>
          <mode>default</mode>
        </deployment>
      </broker>
    carbon.xml: |-
      <?xml version='1.0' encoding='ISO-8859-1' standalone='no'?>
      <!--
       Copyright (c) 2015, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
      
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
      
       http://www.apache.org/licenses/LICENSE-2.0
      
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
      -->
      <!--
          This is the main server configuration file
      
          ${carbon.home} represents the carbon.home system property.
          Other system properties can be specified in a similar manner.
      -->
      <Server xmlns="http://wso2.org/projects/carbon/carbon.xml">
        <!--
             Product Name
          -->
        <Name>WSO2 Message Broker</Name>
        <!--
             machine readable unique key to identify each product
          -->
        <ServerKey>MB</ServerKey>
        <!--
             Product Version
          -->
        <Version>3.2.0</Version>
        <!--
             Host name or IP address of the machine hosting this server
             e.g. www.wso2.org, 192.168.1.10
             This is will become part of the End Point Reference of the
             services deployed on this server instance.
          -->
        <!--HostName>www.wso2.org</HostName-->
        <!--
          Host name to be used for the Carbon management console
          -->
        <!--MgtHostName>mgt.wso2.org</MgtHostName-->
        <!--
              The URL of the back end server. This is where the admin services are hosted and
              will be used by the clients in the front end server.
              This is required only for the Front-end server. This is used when seperating BE server from FE server
             -->
        <ServerURL>local:/${carbon.context}/services/</ServerURL>
        <!--
          <ServerURL>https://${carbon.local.ip}:${carbon.management.port}${carbon.context}/services/</ServerURL>
          -->
        <!--
           The URL of the index page. This is where the user will be redirected after signing in to the
           carbon server.
           -->
        <!-- IndexPageURL>/carbon/admin/index.jsp</IndexPageURL-->
        <!--
          For cApp deployment, we have to identify the roles that can be acted by the current server.
          The following property is used for that purpose. Any number of roles can be defined here.
          Regular expressions can be used in the role.
          Ex : <Role>.*</Role> means this server can act any role
          -->
        <ServerRoles>
          <Role>MessageBroker</Role>
        </ServerRoles>
        <!-- uncommnet this line to subscribe to a bam instance automatically -->
        <!--<BamServerURL>https://bamhost:bamport/services/</BamServerURL>-->
        <!--
             The fully qualified name of the server
          -->
        <Package>org.wso2.carbon</Package>
        <!--
             Webapp context root of WSO2 Carbon management console.
          -->
        <WebContextRoot>/</WebContextRoot>
        <!--
          	Proxy context path is a useful parameter to add a proxy path when a Carbon server is fronted by reverse proxy. In addtion
              to the proxy host and proxy port this parameter allows you add a path component to external URLs. e.g.
           		URL of the Carbon server -> https://10.100.1.1:9443/carbon
         		URL of the reverse proxy -> https://prod.abc.com/appserver/carbon
      
         	appserver - proxy context path. This specially required whenever you are generating URLs to displace in
         	Carbon UI components.
          -->
        <!--
          	<MgtProxyContextPath></MgtProxyContextPath>
          	<ProxyContextPath></ProxyContextPath>
          -->
        <!-- In-order to  get the registry http Port from the back-end when the default http transport is not the same-->
        <!--RegistryHttpPort>9763</RegistryHttpPort-->
        <!--
          Number of items to be displayed on a management console page. This is used at the
          backend server for pagination of various items.
          -->
        <ItemsPerPage>15</ItemsPerPage>
        <!-- The endpoint URL of the cloud instance management Web service -->
        <!--<InstanceMgtWSEndpoint>https://ec2.amazonaws.com/</InstanceMgtWSEndpoint>-->
        <!--
             Ports used by this server
          -->
        <Ports>
          <!-- Ports offset. This entry will set the value of the ports defined below to
               the define value + Offset.
               e.g. Offset=2 and HTTPS port=9443 will set the effective HTTPS port to 9445
               -->
          <Offset>3</Offset>
          <!-- The JMX Ports -->
          <JMX>
            <!--The port RMI registry is exposed-->
            <RMIRegistryPort>9999</RMIRegistryPort>
            <!--The port RMI server should be exposed-->
            <RMIServerPort>11111</RMIServerPort>
          </JMX>
          <!-- Embedded LDAP server specific ports -->
          <EmbeddedLDAP>
            <!-- Port which embedded LDAP server runs -->
            <LDAPServerPort>10389</LDAPServerPort>
            <!-- Port which KDC (Kerberos Key Distribution Center) server runs -->
            <KDCServerPort>8000</KDCServerPort>
          </EmbeddedLDAP>
          <!-- 
                   Override datasources JNDIproviderPort defined in bps.xml and datasources.properties files
      	-->
          <!--<JNDIProviderPort>2199</JNDIProviderPort>-->
          <!--Override receive port of thrift based entitlement service.-->
          <ThriftEntitlementReceivePort>10500</ThriftEntitlementReceivePort>
          <!--
           This is the proxy port of the worker cluster. These need to be configured in a scenario where
           manager node is not exposed through the load balancer through which the workers are exposed
           therefore doesn't have a proxy port.
          <WorkerHttpProxyPort>80</WorkerHttpProxyPort>
          <WorkerHttpsProxyPort>443</WorkerHttpsProxyPort>
          -->
        </Ports>
        <!--
              JNDI Configuration
          -->
        <JNDI>
          <!-- 
                   The fully qualified name of the default initial context factory
              -->
          <DefaultInitialContextFactory>org.wso2.carbon.tomcat.jndi.CarbonJavaURLContextFactory</DefaultInitialContextFactory>
          <!-- 
                   The restrictions that are done to various JNDI Contexts in a Multi-tenant environment 
              -->
          <Restrictions>
            <!--
                      Contexts that will be available only to the super-tenant
                  -->
            <!-- <SuperTenantOnly>
                      <UrlContexts>
                          <UrlContext>
                              <Scheme>foo</Scheme>
                          </UrlContext>
                          <UrlContext>
                              <Scheme>bar</Scheme>
                          </UrlContext>
                      </UrlContexts>
                  </SuperTenantOnly> -->
            <!-- 
                      Contexts that are common to all tenants
                  -->
            <AllTenants>
              <UrlContexts>
                <UrlContext>
                  <Scheme>java</Scheme>
                </UrlContext>
                <!-- <UrlContext>
                              <Scheme>foo</Scheme>
                          </UrlContext> -->
              </UrlContexts>
            </AllTenants>
            <!-- 
                       All other contexts not mentioned above will be available on a per-tenant basis 
                       (i.e. will not be shared among tenants)
                  -->
          </Restrictions>
        </JNDI>
        <!--
              Property to determine if the server is running an a cloud deployment environment.
              This property should only be used to determine deployment specific details that are
              applicable only in a cloud deployment, i.e when the server deployed *-as-a-service.
          -->
        <IsCloudDeployment>false</IsCloudDeployment>
        <!--
      	Property to determine whether usage data should be collected for metering purposes
          -->
        <EnableMetering>false</EnableMetering>
        <!-- The Max time a thread should take for execution in seconds -->
        <MaxThreadExecutionTime>600</MaxThreadExecutionTime>
        <!--
              A flag to enable or disable Ghost Deployer. By default this is set to false. That is
              because the Ghost Deployer works only with the HTTP/S transports. If you are using
              other transports, don't enable Ghost Deployer.
          -->
        <GhostDeployment>
          <Enabled>false</Enabled>
        </GhostDeployment>
        <!--
              Eager loading or lazy loading is a design pattern commonly used in computer programming which
              will initialize an object upon creation or load on-demand. In carbon, lazy loading is used to
              load tenant when a request is received only. Similarly Eager loading is used to enable load
              existing tenants after carbon server starts up. Using this feature, you will be able to include
              or exclude tenants which are to be loaded when server startup.
      
              We can enable only one LoadingPolicy at a given time.
      
              1. Tenant Lazy Loading
                 This is the default behaviour and enabled by default. With this policy, tenants are not loaded at
                 server startup, but loaded based on-demand (i.e when a request is received for a tenant).
                 The default tenant idle time is 30 minutes.
      
              2. Tenant Eager Loading
                 This is by default not enabled. It can be be enabled by un-commenting the <EagerLoading> section.
                 The eager loading configurations supported are as below. These configurations can be given as the
                 value for <Include> element with eager loading.
                      (i)Load all tenants when server startup             -   *
                      (ii)Load all tenants except foo.com & bar.com       -   *,!foo.com,!bar.com
                      (iii)Load only foo.com &  bar.com to be included    -   foo.com,bar.com
          -->
        <Tenant>
          <LoadingPolicy>
            <LazyLoading>
              <IdleTime>30</IdleTime>
            </LazyLoading>
            <!-- <EagerLoading>
                         <Include>*,!foo.com,!bar.com</Include>
                  </EagerLoading>-->
          </LoadingPolicy>
        </Tenant>
        <!--
           Caching related configurations
          -->
        <Cache>
          <!-- Default cache timeout in minutes -->
          <DefaultCacheTimeout>15</DefaultCacheTimeout>
        </Cache>
        <!--
          Axis2 related configurations
          -->
        <Axis2Config>
          <!--
                   Location of the Axis2 Services & Modules repository
      
                   This can be a directory in the local file system, or a URL.
      
                   e.g.
                   1. /home/wso2wsas/repository/ - An absolute path
                   2. repository - In this case, the path is relative to CARBON_HOME
                   3. file:///home/wso2wsas/repository/
                   4. http://wso2wsas/repository/
              -->
          <RepositoryLocation>${carbon.home}/repository/deployment/server/</RepositoryLocation>
          <!--
               Deployment update interval in seconds. This is the interval between repository listener
               executions. 
              -->
          <DeploymentUpdateInterval>15</DeploymentUpdateInterval>
          <!--
                  Location of the main Axis2 configuration descriptor file, a.k.a. axis2.xml file
      
                  This can be a file on the local file system, or a URL
      
                  e.g.
                  1. /home/repository/axis2.xml - An absolute path
                  2. conf/axis2.xml - In this case, the path is relative to CARBON_HOME
                  3. file:///home/carbon/repository/axis2.xml
                  4. http://repository/conf/axis2.xml
              -->
          <ConfigurationFile>${carbon.home}/conf/axis2/axis2.xml</ConfigurationFile>
          <!--
                ServiceGroupContextIdleTime, which will be set in ConfigurationContex
                for multiple clients which are going to access the same ServiceGroupContext
                Default Value is 30 Sec.
              -->
          <ServiceGroupContextIdleTime>30000</ServiceGroupContextIdleTime>
          <!--
                This repository location is used to crete the client side configuration
                context used by the server when calling admin services.
              -->
          <ClientRepositoryLocation>${carbon.home}/repository/deployment/client/</ClientRepositoryLocation>
          <!-- This axis2 xml is used in createing the configuration context by the FE server
               calling to BE server -->
          <clientAxis2XmlLocation>${carbon.home}/conf/axis2/axis2_client.xml</clientAxis2XmlLocation>
          <!-- If this parameter is set, the ?wsdl on an admin service will not give the admin service wsdl. -->
          <HideAdminServiceWSDLs>true</HideAdminServiceWSDLs>
          <!--WARNING-Use With Care! Uncommenting bellow parameter would expose all AdminServices in HTTP transport.
      	With HTTP transport your credentials and data routed in public channels are vulnerable for sniffing attacks. 
      	Use bellow parameter ONLY if your communication channels are confirmed to be secured by other means -->
          <!--HttpAdminServices>*</HttpAdminServices-->
        </Axis2Config>
        <!--
             The default user roles which will be created when the server
             is started up for the first time.
          -->
        <ServiceUserRoles>
          <Role>
            <Name>admin</Name>
            <Description>Default Administrator Role</Description>
          </Role>
          <Role>
            <Name>user</Name>
            <Description>Default User Role</Description>
          </Role>
        </ServiceUserRoles>
        <!-- 
            Enable following config to allow Emails as usernames. 	
          -->
        <!--EnableEmailUserName>true</EnableEmailUserName-->
        <!--
             Configurations related to Carbon Crypto Service which is a crypto framework used inside Carbon products.
          -->
        <CryptoService>
          <Enabled>true</Enabled>
          <!-- The crypto provider which is used for internal data encryption and decryption -->
          <InternalCryptoProviderClassName>org.wso2.carbon.crypto.provider.KeyStoreBasedInternalCryptoProvider</InternalCryptoProviderClassName>
          <!--
                  The crypto provider which is used for the crypto needs which come when communicating with external parties.
                  e.g. Signing, Decrypting.
              -->
          <ExternalCryptoProviderClassName>org.wso2.carbon.core.encryption.KeyStoreBasedExternalCryptoProvider</ExternalCryptoProviderClassName>
          <!--
                  The list of key resolvers which will be used based on the context when handling crypto with external parties.
                  e.g. Resolving the public key of an external entity.
              -->
          <KeyResolvers>
            <KeyResolver className="org.wso2.carbon.crypto.defaultProvider.resolver.ContextIndependentKeyResolver" priority="-1"/>
          </KeyResolvers>
        </CryptoService>
        <!--
            Security configurations
          -->
        <Security>
          <!--
                  KeyStore which will be used for encrypting/decrypting passwords
                  and other sensitive information.
              -->
          <KeyStore>
            <!-- Keystore file location-->
            <Location>${carbon.home}/repository/resources/security/wso2carbon.jks</Location>
            <!-- Keystore type (JKS/PKCS12 etc.)-->
            <Type>JKS</Type>
            <!-- Keystore password-->
            <Password>wso2carbon</Password>
            <!-- Private Key alias-->
            <KeyAlias>wso2carbon</KeyAlias>
            <!-- Private Key password-->
            <KeyPassword>wso2carbon</KeyPassword>
          </KeyStore>
          <!--
                  The KeyStore which is used for encrypting/decrypting internal data.
                  This block is read by Carbon Crypto Service.
              -->
          <InternalKeyStore>
            <!-- Keystore file location-->
            <Location>${carbon.home}/repository/resources/security/wso2carbon.jks</Location>
            <!-- Keystore type (JKS/PKCS12 etc.)-->
            <Type>JKS</Type>
            <!-- Keystore password-->
            <Password>wso2carbon</Password>
            <!-- Private Key alias-->
            <KeyAlias>wso2carbon</KeyAlias>
            <!-- Private Key password-->
            <KeyPassword>wso2carbon</KeyPassword>
          </InternalKeyStore>
          <!--
                  System wide trust-store which is used to maintain the certificates of all
                  the trusted parties.
              -->
          <TrustStore>
            <!-- trust-store file location -->
            <Location>${carbon.home}/repository/resources/security/client-truststore.jks</Location>
            <!-- trust-store type (JKS/PKCS12 etc.) -->
            <Type>JKS</Type>
            <!-- trust-store password -->
            <Password>wso2carbon</Password>
          </TrustStore>
          <!--
                  The Authenticator configuration to be used at the JVM level. We extend the
                  java.net.Authenticator to make it possible to authenticate to given servers and 
                  proxies.
              -->
          <NetworkAuthenticatorConfig>
            <!-- 
                      Below is a sample configuration for a single authenticator. Please note that
                      all child elements are mandatory. Not having some child elements would lead to
                      exceptions at runtime.
                  -->
            <!-- <Credential> -->
            <!-- 
                          the pattern that would match a subset of URLs for which this authenticator
                          would be used
                      -->
            <!-- <Pattern>regularExpression</Pattern> -->
            <!-- 
                          the type of this authenticator. Allowed values are:
                          1. server
                          2. proxy
                      -->
            <!-- <Type>proxy</Type> -->
            <!-- the username used to log in to server/proxy -->
            <!-- <Username>username</Username> -->
            <!-- the password used to log in to server/proxy -->
            <!-- <Password>password</Password> -->
            <!-- </Credential> -->
          </NetworkAuthenticatorConfig>
          <!--
               The Tomcat realm to be used for hosted Web applications. Allowed values are;
               1. UserManager
               2. Memory
      
               If this is set to 'UserManager', the realm will pick users & roles from the system's
               WSO2 User Manager. If it is set to 'memory', the realm will pick users & roles from
               CARBON_HOME/repository/conf/tomcat/tomcat-users.xml
              -->
          <TomcatRealm>UserManager</TomcatRealm>
          <!--Option to disable storing of tokens issued by STS-->
          <DisableTokenStore>false</DisableTokenStore>
          <!--
      	 Security token store class name. If this is not set, default class will be
      	 org.wso2.carbon.security.util.SecurityTokenStore
      	-->
          <!--TokenStoreClassName>org.wso2.carbon.identity.sts.store.DBTokenStore</TokenStoreClassName-->
          <XSSPreventionConfig>
            <Enabled>true</Enabled>
            <Rule>allow</Rule>
            <Patterns>
              <!--Pattern></Pattern-->
            </Patterns>
          </XSSPreventionConfig>
          <!-- Configurations to avoid Cross Site Request Forgery vulnerabilities -->
          <CSRFPreventionConfig>
            <!-- CSRFPreventionFilter configurations that adopts Synchronizer Token Pattern -->
            <CSRFPreventionFilter>
              <!-- Set below to true to enable the CSRFPreventionFilter -->
              <Enabled>false</Enabled>
              <!-- Url Pattern to skip application of CSRF protection-->
              <SkipUrlPattern>(.*)(/images|/css|/js|/docs)(.*)</SkipUrlPattern>
            </CSRFPreventionFilter>
          </CSRFPreventionConfig>
          <!-- Configuration to enable or disable CR and LF sanitization filter-->
          <CRLFPreventionConfig>
            <!--Set below to true to enable the CRLFPreventionFilter-->
            <Enabled>true</Enabled>
          </CRLFPreventionConfig>
        </Security>
        <!--
             The temporary work directory
          -->
        <WorkDirectory>${carbon.home}/tmp/work</WorkDirectory>
        <!--
             House-keeping configuration
          -->
        <HouseKeeping>
          <!--
                 true  - Start House-keeping thread on server startup
                 false - Do not start House-keeping thread on server startup.
                         The user will run it manually as and when he wishes.
              -->
          <AutoStart>true</AutoStart>
          <!--
                 The interval in *minutes*, between house-keeping runs
              -->
          <Interval>10</Interval>
          <!--
                The maximum time in *minutes*, temp files are allowed to live
                in the system. Files/directories which were modified more than
                "MaxTempFileLifetime" minutes ago will be removed by the
                house-keeping task
              -->
          <MaxTempFileLifetime>30</MaxTempFileLifetime>
        </HouseKeeping>
        <!--
             Configuration for handling different types of file upload & other file uploading related
             config parameters.
             To map all actions to a particular FileUploadExecutor, use
             <Action>*</Action>
          -->
        <FileUploadConfig>
          <!--
                 The total file upload size limit in MB
              -->
          <TotalFileSizeLimit>100</TotalFileSizeLimit>
          <Mapping>
            <Actions>
              <Action>keystore</Action>
              <Action>certificate</Action>
              <Action>*</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.AnyFileUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>jarZip</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.JarZipUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>dbs</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.DBSFileUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>tools</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.ToolsFileUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>toolsAny</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.ToolsAnyFileUploadExecutor</Class>
          </Mapping>
        </FileUploadConfig>
        <!-- FileNameRegEx is used to validate the file input/upload/write-out names.
          e.g.
           <FileNameRegEx>^(?!(?:CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(?:\.[^.])?$)[^&lt;&gt:"/\\|?*\x00-\x1F][^&lt;&gt:"/\\|?*\x00-\x1F\ .]$</FileNameRegEx>
          -->
        <!--<FileNameRegEx></FileNameRegEx>-->
        <!--
             Processors which process special HTTP GET requests such as ?wsdl, ?policy etc.
      
             In order to plug in a processor to handle a special request, simply add an entry to this
             section.
      
             The value of the Item element is the first parameter in the query string(e.g. ?wsdl)
             which needs special processing
             
             The value of the Class element is a class which implements
             org.wso2.carbon.transport.HttpGetRequestProcessor
          -->
        <HttpGetRequestProcessors>
          <Processor>
            <Item>info</Item>
            <Class>org.wso2.carbon.core.transports.util.InfoProcessor</Class>
          </Processor>
          <Processor>
            <Item>wsdl</Item>
            <Class>org.wso2.carbon.core.transports.util.Wsdl11Processor</Class>
          </Processor>
          <Processor>
            <Item>wsdl2</Item>
            <Class>org.wso2.carbon.core.transports.util.Wsdl20Processor</Class>
          </Processor>
          <Processor>
            <Item>xsd</Item>
            <Class>org.wso2.carbon.core.transports.util.XsdProcessor</Class>
          </Processor>
        </HttpGetRequestProcessors>
        <!-- Deployment Synchronizer Configuration. t Enabled value to true when running with "svn based" dep sync.
      	In master nodes you need to set both AutoCommit and AutoCheckout to true
      	and in  worker nodes set only AutoCheckout to true.
          -->
        <DeploymentSynchronizer>
          <Enabled>false</Enabled>
          <AutoCommit>false</AutoCommit>
          <AutoCheckout>true</AutoCheckout>
          <RepositoryType>svn</RepositoryType>
          <SvnUrl>http://svnrepo.example.com/repos/</SvnUrl>
          <SvnUser>username</SvnUser>
          <SvnPassword>password</SvnPassword>
          <SvnUrlAppendTenantId>true</SvnUrlAppendTenantId>
        </DeploymentSynchronizer>
        <!-- Deployment Synchronizer Configuration. Uncomment the following section when running with "registry based" dep sync.
              In master nodes you need to set both AutoCommit and AutoCheckout to true
              and in  worker nodes set only AutoCheckout to true.
          -->
        <!--<DeploymentSynchronizer>
              <Enabled>true</Enabled>
              <AutoCommit>false</AutoCommit>
              <AutoCheckout>true</AutoCheckout>
          </DeploymentSynchronizer>-->
        <!-- Mediation persistence configurations. Only valid if mediation features are available i.e. ESB -->
        <!--<MediationConfig>
              <LoadFromRegistry>false</LoadFromRegistry>
              <SaveToFile>false</SaveToFile>
              <Persistence>enabled</Persistence>
              <RegistryPersistence>enabled</RegistryPersistence>
          </MediationConfig>-->
        <!--
          Server intializing code, specified as implementation classes of org.wso2.carbon.core.ServerInitializer.
          This code will be run when the Carbon server is initialized
          -->
        <ServerInitializers>
          <!--<Initializer></Initializer>-->
        </ServerInitializers>
        <!--
          Indicates whether the Carbon Servlet is required by the system, and whether it should be
          registered
          -->
        <RequireCarbonServlet>${require.carbon.servlet}</RequireCarbonServlet>
        <!--
          Carbon H2 OSGI Configuration
          By default non of the servers start.
              name="web" - Start the web server with the H2 Console
              name="webPort" - The port (default: 8082)
              name="webAllowOthers" - Allow other computers to connect
              name="webSSL" - Use encrypted (HTTPS) connections
              name="tcp" - Start the TCP server
              name="tcpPort" - The port (default: 9092)
              name="tcpAllowOthers" - Allow other computers to connect
              name="tcpSSL" - Use encrypted (SSL) connections
              name="pg" - Start the PG server
              name="pgPort"  - The port (default: 5435)
              name="pgAllowOthers"  - Allow other computers to connect
              name="trace" - Print additional trace information; for all servers
              name="baseDir" - The base directory for H2 databases; for all servers  
          -->
        <!--H2DatabaseConfiguration>
              <property name="web" />
              <property name="webPort">8082</property>
              <property name="webAllowOthers" />
              <property name="webSSL" />
              <property name="tcp" />
              <property name="tcpPort">9092</property>
              <property name="tcpAllowOthers" />
              <property name="tcpSSL" />
              <property name="pg" />
              <property name="pgPort">5435</property>
              <property name="pgAllowOthers" />
              <property name="trace" />
              <property name="baseDir">${carbon.home}</property>
          </H2DatabaseConfiguration-->
        <!--Disabling statistics reporter by default-->
        <StatisticsReporterDisabled>true</StatisticsReporterDisabled>
        <!-- Enable accessing Admin Console via HTTP -->
        <!-- EnableHTTPAdminConsole>true</EnableHTTPAdminConsole -->
        <!--
             Default Feature Repository of WSO2 Carbon.
          -->
        <FeatureRepository>
          <RepositoryName>default repository</RepositoryName>
          <RepositoryURL>http://product-dist.wso2.com/p2/carbon/releases/wilkes/</RepositoryURL>
        </FeatureRepository>
        <!--
      	Configure API Management
         -->
        <APIManagement>
          <!--Uses the embedded API Manager by default. If you want to use an external 
      	API Manager instance to manage APIs, configure below  externalAPIManager-->
          <Enabled>true</Enabled>
          <!--Uncomment and configure API Gateway and 
      	Publisher URLs to use external API Manager instance-->
          <!--ExternalAPIManager>
      
      		<APIGatewayURL>http://localhost:8281</APIGatewayURL>
      		<APIPublisherURL>http://localhost:8281/publisher</APIPublisherURL>
      
      	</ExternalAPIManager-->
          <LoadAPIContextsInServerStartup>true</LoadAPIContextsInServerStartup>
        </APIManagement>
        <HostName>wso2ei-broker</HostName>
        <MgtHostName>wso2ei-broker</MgtHostName>
      </Server>   
    hazelcast.properties: |-
      hazelcast.max.no.heartbeat.seconds=600
      hazelcast.shutdownhook.enabled=false
      #Setting the hazelcast logging type to log4j
      hazelcast.logging.type=log4j 
    log4j.properties: |-
      log4j.rootLogger=INFO, CARBON_CONSOLE, CARBON_LOGFILE, CARBON_MEMORY, CARBON_SYS_LOG
      log4j.logger.AUDIT_LOG=INFO, AUDIT_LOGFILE
      log4j.logger.org.apache.axis2.wsdl.codegen.writer.PrettyPrinter=ERROR, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.axis2.clustering=INFO, CARBON_CONSOLE, CARBON_LOGFILE
      log4j.logger.org.apache=INFO, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.catalina=WARN
      log4j.logger.org.apache.tomcat=WARN
      log4j.logger.org.wso2.carbon.apacheds=WARN
      log4j.logger.org.apache.directory.server.ldap=ERROR
      log4j.logger.org.apache.directory.server.core.event=WARN
      log4j.logger.com.atomikos=INFO,ATOMIKOS
      log4j.logger.org.quartz=WARN
      log4j.logger.org.apache.jackrabbit.webdav=WARN
      log4j.logger.org.apache.juddi=ERROR
      log4j.logger.org.apache.commons.digester.Digester=WARN
      log4j.logger.org.apache.jasper.compiler.TldLocationsCache=WARN
      log4j.logger.org.apache.qpid=WARN
      log4j.logger.org.apache.qpid.server.Main=INFO
      log4j.logger.qpid.message=WARN
      log4j.logger.qpid.message.broker.listening=INFO
      log4j.logger.org.apache.tiles=WARN
      log4j.logger.org.apache.commons.httpclient=ERROR
      log4j.logger.org.apache.coyote=WARN
      log4j.logger.org.apache.solr=ERROR
      log4j.logger.me.prettyprint.cassandra.hector.TimingLogger=ERROR
      log4j.logger.org.wso2=INFO
      log4j.logger.org.apache.axis2.enterprise=FATAL, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.shared.ldap=WARN, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.server.ldap.handlers=WARN, CARBON_LOGFILE, CARBON_MEMORY
      #Following are to remove false error messages from startup (IS)
      log4j.logger.org.apache.directory.shared.ldap.entry.DefaultServerAttribute=FATAL, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.server.core.DefaultDirectoryService=ERROR, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.shared.ldap.ldif.LdifReader=ERROR, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.server.ldap.LdapProtocolHandler=ERROR, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.server.core=ERROR, CARBON_LOGFILE, CARBON_MEMORY
      log4j.logger.org.apache.directory.server.ldap.LdapSession=ERROR, CARBON_LOGFILE, CARBON_MEMORY
      #Hive Related Log configurations
      log4j.logger.DataNucleus=ERROR
      log4j.logger.Datastore=ERROR
      log4j.logger.Datastore.Schema=ERROR
      log4j.logger.JPOX.Datastore=ERROR
      log4j.logger.JPOX.Plugin=ERROR
      log4j.logger.JPOX.MetaData=ERROR
      log4j.logger.JPOX.Query=ERROR
      log4j.logger.JPOX.General=ERROR
      log4j.logger.JPOX.Enhancer=ERROR
      log4j.logger.org.apache.hadoop.hive=WARN
      log4j.logger.hive=WARN
      log4j.logger.ExecMapper=WARN
      log4j.logger.ExecReducer=WARN
      log4j.logger.net.sf.ehcache.config.ConfigurationFactory=ERROR
      
      #andes specific
      log4j.logger.org.wso2.andes.server.handler.ConnectionStartOkMethodHandler=WARN
      log4j.logger.org.wso2.andes.server.handler.ChannelOpenHandler=WARN
      log4j.logger.org.wso2.andes.server.handler.ChannelCloseHandler=WARN
      log4j.logger.org.wso2.andes.server.AMQChannel=WARN
      log4j.logger.org.wso2.andes.server.handler.ConnectionCloseMethodHandler=WARN
      log4j.logger.org.wso2.andes.server.handler.QueueDeclareHandler=WARN
      log4j.logger.org.wso2.andes.server.handler.QueueBindHandler=WARN
      log4j.logger.org.wso2.andes.server.virtualhost.VirtualHostConfigRecoveryHandler=WARN
      log4j.logger.org.wso2.andes.amqp.QpidAndesBridge=WARN
      log4j.logger.MessageExpirationTask=WARN
      
      # Set to level TRACE to enable MessageTracer for the broker profile
      log4j.logger.org.wso2.andes.tools.utils.MessageTracer=INFO,CARBON_TRACE_LOGFILE
      
      #Andes logs for troubleshooting
      #kernel - outbound
      log4j.logger.org.wso2.andes.kernel.slot.MessageDeliveryTask=INFO
      log4j.logger.org.wso2.andes.kernel.slot.SlotDeliveryWorkerManager=INFO
      log4j.logger.org.wso2.andes.kernel.slot.SlotManagerClusterMode=INFO
      log4j.logger.org.wso2.andes.kernel.subscription.AndesSubscription=INFO
      log4j.logger.org.wso2.andes.kernel.MessageHandler=INFO
      
      #Kernel - inbound
      log4j.logger.org.wso2.andes.kernel.distruptor.inbound.MessageWriter=INFO
      log4j.logger.org.wso2.andes.kernel.distruptor.inbound.AckHandler=INFO
      log4j.logger.org.wso2.andes.kernel.distruptor.inbound.StateEventHandler=INFO
      
      log4j.additivity.org.apache.axis2.clustering=false
      log4j.additivity.com.atomikos=false
      log4j.additivity.org.apache=false
      
      # CARBON_CONSOLE is set to be a ConsoleAppender using a PatternLayout.
      log4j.appender.CARBON_CONSOLE=org.wso2.carbon.utils.logging.appenders.CarbonConsoleAppender
      log4j.appender.CARBON_CONSOLE.layout=org.wso2.carbon.utils.logging.TenantAwarePatternLayout
      # ConversionPattern will be overridden by the configuration setting in the DB
      log4j.appender.CARBON_CONSOLE.layout.ConversionPattern=[%d] [${logger.server.name}] %P%5p {%c} - %x %m%n
      log4j.appender.CARBON_CONSOLE.layout.TenantPattern=%U%@%D[%T]
      log4j.appender.CARBON_CONSOLE.threshold=DEBUG
      
      # The memory appender for logging
      log4j.appender.CARBON_MEMORY=org.wso2.carbon.logging.service.appender.CarbonMemoryAppender
      log4j.appender.CARBON_MEMORY.bufferSize=2000
      log4j.appender.CARBON_MEMORY.layout=org.wso2.carbon.utils.logging.TenantAwarePatternLayout
      # ConversionPattern will be overridden by the configuration setting in the DB
      log4j.appender.CARBON_MEMORY.layout.ConversionPattern=TID: [%T] [%S] [%d] %P%5p {%c} - %x %m {%c}%n
      log4j.appender.CARBON_MEMORY.layout.TenantPattern=%U%@%D [%T] [%S]
      log4j.appender.CARBON_MEMORY.columnList=%T,%S,%A,%d,%c,%p,%m,%H,%I,%Stacktrace
      log4j.appender.CARBON_MEMORY.threshold=DEBUG
      
      
      # CARBON_LOGFILE is set to be a DailyRollingFileAppender using a PatternLayout.
      log4j.appender.CARBON_LOGFILE=org.wso2.carbon.utils.logging.appenders.CarbonDailyRollingFileAppender
      # Log file will be overridden by the configuration setting in the DB
      # This path should be relative to WSO2 Carbon Home
      log4j.appender.CARBON_LOGFILE.File=${carbon.home}/repository/logs/${instance.log}/wso2carbon${instance.log}.log
      log4j.appender.CARBON_LOGFILE.Append=true
      log4j.appender.CARBON_LOGFILE.layout=org.wso2.carbon.utils.logging.TenantAwarePatternLayout
      # ConversionPattern will be overridden by the configuration setting in the DB
      log4j.appender.CARBON_LOGFILE.layout.ConversionPattern=TID: [%T] [%S] [%d] %P%5p {%c} - %x %m %n
      log4j.appender.CARBON_LOGFILE.layout.TenantPattern=%U%@%D [%T] [%S]
      log4j.appender.CARBON_LOGFILE.threshold=DEBUG
      
      log4j.appender.CARBON_SYS_LOG = org.apache.log4j.net.SyslogAppender
      log4j.appender.CARBON_SYS_LOG.layout=org.apache.log4j.PatternLayout
      log4j.appender.CARBON_SYS_LOG.layout.ConversionPattern=[%d] %5p {%c} - %x %m %n
      log4j.appender.CARBON_SYS_LOG.SyslogHost=localhost
      log4j.appender.CARBON_SYS_LOG.Facility=USER
      log4j.appender.CARBON_SYS_LOG.threshold=DEBUG
      
      # LOGEVENT is set to be a LogEventAppender using a PatternLayout to send logs to LOGEVENT
      log4j.appender.LOGEVENT=org.wso2.carbon.logging.service.appender.LogEventAppender
      log4j.appender.LOGEVENT.url=tcp://10.100.3.103:7611
      log4j.appender.LOGEVENT.layout=org.wso2.carbon.utils.logging.TenantAwarePatternLayout
      log4j.appender.LOGEVENT.columnList=%T,%S,%A,%d,%c,%p,%m,%H,%I,%Stacktrace
      log4j.appender.LOGEVENT.userName=admin
      log4j.appender.LOGEVENT.password=admin
      #log4j.appender.LOGEVENT.password=secretAlias:Log4j.Appender.LOGEVENT.Password
      
      # Appender config to CARBON_TRACE_LOGFILE
      log4j.appender.CARBON_TRACE_LOGFILE=org.apache.log4j.DailyRollingFileAppender
      log4j.appender.CARBON_TRACE_LOGFILE.File=${carbon.home}/repository/logs/${instance.log}/wso2carbon-trace-messages${instance.log}.log
      log4j.appender.CARBON_TRACE_LOGFILE.Append=true
      log4j.appender.CARBON_TRACE_LOGFILE.layout=org.wso2.carbon.utils.logging.TenantAwarePatternLayout
      log4j.appender.CARBON_TRACE_LOGFILE.layout.ConversionPattern=[%d] %P%5p {%c} - %x %m %n
      log4j.appender.CARBON_TRACE_LOGFILE.layout.TenantPattern=%U%@%D [%T] [%S]
      log4j.appender.CARBON_TRACE_LOGFILE.threshold=TRACE
      log4j.additivity.trace.messages=false
      
      # Appender config to AUDIT_LOGFILE
      log4j.appender.AUDIT_LOGFILE=org.wso2.carbon.utils.logging.appenders.CarbonDailyRollingFileAppender
      log4j.appender.AUDIT_LOGFILE.File=${carbon.home}/repository/logs/audit.log
      log4j.appender.AUDIT_LOGFILE.Append=true
      log4j.appender.AUDIT_LOGFILE.layout=org.wso2.carbon.utils.logging.TenantAwarePatternLayout
      log4j.appender.AUDIT_LOGFILE.layout.ConversionPattern=[%d] %P%5p {%c}- %x %m %n
      log4j.appender.AUDIT_LOGFILE.layout.TenantPattern=%U%@%D [%T] [%S]
      log4j.appender.AUDIT_LOGFILE.threshold=INFO
      log4j.additivity.AUDIT_LOG=false
      
      # Appender config to send Atomikos transaction logs to new log file tm.out.
      log4j.appender.ATOMIKOS = org.apache.log4j.RollingFileAppender
      log4j.appender.ATOMIKOS.File = repository/logs/tm.out
      log4j.appender.ATOMIKOS.Append = true
      log4j.appender.ATOMIKOS.layout = org.apache.log4j.PatternLayout
      log4j.appender.ATOMIKOS.layout.ConversionPattern=%p %t %c - %m%n
      
      # This file is used to override the default logger settings, and is used to remove unwanted logs from Shindig appearing on the console.
      
      # Specification of Handler used by Console Logger
      handlers=java.util.logging.ConsoleHandler
      
      # Replacing default INFO level with SEVERE
      java.util.logging.ConsoleHandler.level=SEVERE
      
      log4j.logger.com.hazelcast=INFO 
    registry.xml: |-
      <?xml version='1.0' encoding='ISO-8859-1' standalone='no'?>
      <wso2registry>
        <!--
          For details on configuring different config & governance registries see;
          http://wso2.org/library/tutorials/2010/04/sharing-registry-space-across-multiple-product-instances
          -->
        <currentDBConfig>wso2registry</currentDBConfig>
        <readOnly>false</readOnly>
        <enableCache>true</enableCache>
        <registryRoot>/</registryRoot>
        <dbConfig name="wso2registry">
          <dataSource>jdbc/WSO2CarbonDB</dataSource>
        </dbConfig>
        <indexingConfiguration>
          <startIndexing>false</startIndexing>
          <startingDelayInSeconds>35</startingDelayInSeconds>
          <indexingFrequencyInSeconds>3</indexingFrequencyInSeconds>
          <!--number of resources submit for given indexing thread -->
          <batchSize>50</batchSize>
          <!--number of worker threads for indexing -->
          <indexerPoolSize>50</indexerPoolSize>
          <!-- location storing the time the indexing took place-->
          <lastAccessTimeLocation>/_system/local/repository/components/org.wso2.carbon.registry/indexing/lastaccesstime</lastAccessTimeLocation>
          <!-- the indexers that implement the indexer interface for a relevant media type/(s) -->
          <indexers>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.MSExcelIndexer" mediaTypeRegEx="application/vnd.ms-excel"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.MSPowerpointIndexer" mediaTypeRegEx="application/vnd.ms-powerpoint"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.MSWordIndexer" mediaTypeRegEx="application/msword"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.PDFIndexer" mediaTypeRegEx="application/pdf"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.XMLIndexer" mediaTypeRegEx="application/xml"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.XMLIndexer" mediaTypeRegEx="application/(.)+\+xml"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="application/swagger\+json"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="application/(.)+\+json"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="text/(.)+"/>
            <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="application/x-javascript"/>
          </indexers>
          <exclusions>
            <exclusion pathRegEx="/_system/config/repository/dashboards/gadgets/swfobject1-5/.*[.]html"/>
            <exclusion pathRegEx="/_system/local/repository/components/org[.]wso2[.]carbon[.]registry/mount/.*"/>
          </exclusions>
        </indexingConfiguration>
        <!--<handler class="org.wso2.carbon.registry.extensions.handlers.SynapseRepositoryHandler">
              <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                  <property name="mediaType">application/vnd.apache.synapse</property>
              </filter>
          </handler>
      
          <handler class="org.wso2.carbon.registry.extensions.handlers.SynapseRepositoryHandler">
              <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                  <property name="mediaType">application/vnd.apache.esb</property>
              </filter>
          </handler>
      
          <handler class="org.wso2.carbon.registry.extensions.handlers.Axis2RepositoryHandler">
              <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                  <property name="mediaType">application/vnd.apache.axis2</property>
              </filter>
          </handler>
      
          <handler class="org.wso2.carbon.registry.extensions.handlers.Axis2RepositoryHandler">
              <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                  <property name="mediaType">application/vnd.apache.wsas</property>
              </filter>
          </handler>
      
          <handler class="org.wso2.carbon.registry.extensions.handlers.WSDLMediaTypeHandler">
              <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                  <property name="mediaType">application/wsdl+xml</property>
              </filter>
          </handler>
      
          <handler class="org.wso2.carbon.registry.extensions.handlers.XSDMediaTypeHandler">
              <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                  <property name="mediaType">application/x-xsd+xml</property>
              </filter>
          </handler> -->
        <!--remoteInstance url="https://localhost:9443/registry">
              <id>instanceid</id>
              <username>username</username>
              <password>password</password>
          </remoteInstance-->
        <!--remoteInstance url="https://localhost:9443/registry">
              <id>instanceid</id>
              <dbConfig>wso2registry</dbConfig>
              <readOnly>false</readOnly>
              <enableCache>true</enableCache>
              <registryRoot>/</registryRoot>
          </remoteInstance-->
        <!--mount path="/_system/config" overwrite="true|false|virtual">
              <instanceId>instanceid</instanceId>
              <targetPath>/_system/nodes</targetPath>
          </mount-->
        <!--
          Following handler used to clear synapse cache for the put, move, rename and delete operation on the
          registry resources.
          -->
        <handler class="org.wso2.carbon.mediation.library.RegistryCachingHandler">
          <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.URLMatcher">
            <property name="putPattern">.*</property>
            <property name="movePattern">.*</property>
            <property name="renamePattern">.*</property>
            <property name="deletePattern">.*</property>
          </filter>
        </handler>
        <versionResourcesOnChange>false</versionResourcesOnChange>
        <!-- NOTE: You can edit the options under "StaticConfiguration" only before the
           startup. -->
        <staticConfiguration>
          <versioningProperties>true</versioningProperties>
          <versioningComments>true</versioningComments>
          <versioningTags>true</versioningTags>
          <versioningRatings>true</versioningRatings>
        </staticConfiguration>
        <dbConfig name="wso2config">
          <dataSource>jdbc/WSO2ConfigDB</dataSource>
        </dbConfig>
        <remoteInstance url="https://localhost:9453/registry">
          <id>wso2config</id>
          <dbConfig>wso2config</dbConfig>
          <readOnly>false</readOnly>
          <registryRoot>/</registryRoot>
        </remoteInstance>
        <mount path="/_system/config" overwrite="true">
          <instanceId>wso2config</instanceId>
          <targetPath>/_system/config/broker</targetPath>
        </mount>
        <mount path="/_system/governance" overwrite="true">
          <instanceId>wso2config</instanceId>
          <targetPath>/_system/governance/broker</targetPath>
        </mount>
      </wso2registry>     
    user-mgt.xml: |-
      <?xml version='1.0' encoding='UTF-8'?>
      <UserManager>
        <Realm>
          <Configuration><AddAdmin>true</AddAdmin><AdminRole>admin</AdminRole><AdminUser><UserName>admin</UserName><Password>admin</Password></AdminUser><EveryOneRoleName>everyone</EveryOneRoleName><!-- By default users in this role sees the registry root -->
                  !-- Enable username claim retrieve from the UM_USER_NAME in JDBC datasources --&gt;
                  <OverrideUsernameClaimFromInternalUsername>true</OverrideUsernameClaimFromInternalUsername>
                  <Property name="isCascadeDeleteEnabled">true</Property>
                  <Property name="dataSource">jdbc/WSO2UserDB</Property>
              </Configuration>
          <!-- Following is the configuration for internal JDBC user store. This user store manager is based on JDBC.
      	         In case if application needs to manage passwords externally set property
      	         <Property name="PasswordsExternallyManaged">true</Property>.
      	         In case if user core cache domain is needed to identify uniquely set property
      	         <Property name="UserCoreCacheIdentifier">domain</Property>.
      	         Furthermore properties, IsEmailUserName and DomainCalculation are readonly properties.
      	         Note: Do not comment within UserStoreManager tags. Cause, specific tag names are used as tokens
      	         when building configurations for products.
      	    -->
          <UserStoreManager class="org.wso2.carbon.user.core.jdbc.JDBCUserStoreManager">
            <Property name="TenantManager">org.wso2.carbon.user.core.tenant.JDBCTenantManager</Property>
            <Property name="ReadOnly">false</Property>
            <Property name="ReadGroups">true</Property>
            <Property name="WriteGroups">true</Property>
            <Property name="UsernameJavaRegEx">^[\S]{3,30}$</Property>
            <Property name="UsernameJavaScriptRegEx">^[\S]{3,30}$</Property>
            <Property name="UsernameJavaRegExViolationErrorMsg">Username pattern policy violated</Property>
            <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
            <Property name="PasswordJavaScriptRegEx">^[\S]{5,30}$</Property>
            <Property name="PasswordJavaRegExViolationErrorMsg">Password length should be within 5 to 30 characters</Property>
            <Property name="RolenameJavaRegEx">^[\S]{3,30}$</Property>
            <Property name="RolenameJavaScriptRegEx">^[\S]{3,30}$</Property>
            <Property name="CaseInsensitiveUsername">true</Property>
            <Property name="SCIMEnabled">false</Property>
            <Property name="IsBulkImportSupported">true</Property>
            <Property name="PasswordDigest">SHA-256</Property>
            <Property name="StoreSaltedPassword">true</Property>
            <Property name="MultiAttributeSeparator">,</Property>
            <Property name="MaxUserNameListLength">100</Property>
            <Property name="MaxRoleNameListLength">100</Property>
            <Property name="UserRolesCacheEnabled">true</Property>
            <Property name="UserNameUniqueAcrossTenants">false</Property>
            <Property name="LeadingOrTrailingSpaceAllowedInUserName">false</Property>
          </UserStoreManager>
          <!-- If product is using an external LDAP as the user store in READ ONLY mode, use following user manager.
      		     In case if user core cache domain is needed to identify uniquely set property
      		     <Property name="UserCoreCacheIdentifier">domain</Property>
       	    -->
          <!--UserStoreManager class="org.wso2.carbon.user.core.ldap.ReadOnlyLDAPUserStoreManager">
                  <Property name="TenantManager">org.wso2.carbon.user.core.tenant.CommonHybridLDAPTenantManager</Property>
                  <Property name="ConnectionURL">ldap://localhost:10389</Property>
                  <Property name="ConnectionName">uid=admin,ou=system</Property>
                  <Property name="ConnectionPassword">admin</Property>
                  <Property name="AnonymousBind">false</Property>
                  <Property name="UserSearchBase">ou=system</Property>
                  <Property name="UserNameAttribute">uid</Property>
                  <Property name="UserNameSearchFilter">(&amp;(objectClass=person)(uid=?))</Property>
                  <Property name="UserNameListFilter">(&amp;(objectClass=person)(!(sn=Service)))</Property>
                  <Property name="DisplayNameAttribute"/>
                  <Property name="ReadGroups">true</Property>
                  <Property name="GroupSearchBase">ou=system</Property>
                  <Property name="GroupNameAttribute">cn</Property>
                  <Property name="GroupNameSearchFilter">(&amp;(objectClass=groupOfNames)(cn=?))</Property>
                  <Property name="GroupNameListFilter">(objectClass=groupOfNames)</Property>
                  <Property name="MembershipAttribute">member</Property>
                  <Property name="BackLinksEnabled">false</Property>
                  <Property name="UsernameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
                  <Property name="RolenameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="SCIMEnabled">false</Property>
                  <Property name="PasswordHashMethod">PLAIN_TEXT</Property>
                  <Property name="MultiAttributeSeparator">,</Property>
                  <Property name="MaxUserNameListLength">100</Property>
                  <Property name="MaxRoleNameListLength">100</Property>
                  <Property name="UserRolesCacheEnabled">true</Property>
                  <Property name="ConnectionPoolingEnabled">true</Property>
                  <Property name="LDAPConnectionTimeout">5000</Property>
                  <Property name="ReadTimeout"/>
                  <Property name="RetryAttempts"/>
                  <Property name="ReplaceEscapeCharactersAtUserLogin">true</Property>
              </UserStoreManager-->
          <!-- Active directory configuration is as follows.
      	         In case if user core cache domain is needed to identify uniquely set property
      	         <Property name="UserCoreCacheIdentifier">domain</Property>
      	         There are few special properties for "Active Directory".
      	         They are :
      	         1.Referral - (comment out this property if this feature is not reuired) This enables LDAP referral support.
      	         2.BackLinksEnabled - (Do not comment, set to true or false) In some cases LDAP works with BackLinksEnabled.
      	         In which role is stored at user level. Depending on this value we need to change the Search Base within code.
      	         isADLDSRole - (Do not comment) Set to true if connecting to an AD LDS instance else set to false.
      	    -->
          <!--UserStoreManager class="org.wso2.carbon.user.core.ldap.ActiveDirectoryUserStoreManager">
                  <Property name="TenantManager">org.wso2.carbon.user.core.tenant.CommonHybridLDAPTenantManager</Property>
                  <Property name="ConnectionURL">ldaps://10.100.1.100:636</Property> 
                  <Property name="ConnectionName">CN=admin,CN=Users,DC=WSO2,DC=Com</Property>
                  <Property name="ConnectionPassword">A1b2c3d4</Property>
                  <Property name="AnonymousBind">false</Property>
                  <Property name="UserSearchBase">CN=Users,DC=WSO2,DC=Com</Property>
                  <Property name="UserEntryObjectClass">user</Property>
                  <Property name="UserNameAttribute">cn</Property>
                  <Property name="UserNameSearchFilter">(&amp;(objectClass=user)(cn=?))</Property>
                  <Property name="UserNameListFilter">(&amp;(objectClass=user)(!(sn=Service)))</Property>
                  <Property name="DisplayNameAttribute"/>
                  <Property name="ReadGroups">true</Property>
                  <Property name="WriteGroups">true</Property>
                  <Property name="GroupSearchBase">CN=Users,DC=WSO2,DC=Com</Property>
                  <Property name="GroupEntryObjectClass">group</Property>
                  <Property name="GroupNameAttribute">cn</Property>
                  <Property name="GroupNameSearchFilter">(&amp;(objectClass=group)(cn=?))</Property>
                  <Property name="GroupNameListFilter">(objectcategory=group)</Property>
                  <Property name="MembershipAttribute">member</Property>
                  <Property name="MemberOfAttribute">memberOf</Property>
                  <Property name="BackLinksEnabled">true</Property>
                  <Property name="Referral">follow</Property>
                  <Property name="UsernameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="UsernameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="UsernameJavaRegExViolationErrorMsg">Username pattern policy violated</Property>
                  <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaScriptRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaRegExViolationErrorMsg">Password length should be within 5 to 30 characters</Property>
                  <Property name="RolenameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="RolenameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="SCIMEnabled">false</Property>
                  <Property name="IsBulkImportSupported">true</Property>
                  <Property name="EmptyRolesAllowed">true</Property>
                  <Property name="PasswordHashMethod">PLAIN_TEXT</Property>
                  <Property name="MultiAttributeSeparator">,</Property>
                  <Property name="isADLDSRole">false</Property>
                  <Property name="userAccountControl">512</Property>
                  <Property name="MaxUserNameListLength">100</Property>     
                  <Property name="MaxRoleNameListLength">100</Property>                     
                  <Property name="MembershipAttributeRange">1500</Property>
                  <Property name="kdcEnabled">false</Property>
                  <Property name="defaultRealmName">WSO2.ORG</Property>
                  <Property name="UserRolesCacheEnabled">true</Property>
                  <Property name="ConnectionPoolingEnabled">false</Property>
                  <Property name="LDAPConnectionTimeout">5000</Property>
                  <Property name="ReadTimeout"/>
                  <Property name="RetryAttempts"/>
                  <Property name="StartTLSEnabled">false</Property>
              </UserStoreManager-->
          <!-- Following user manager is used by Identity Server (IS) as its default user manager.
                   IS will do token replacement when building the product. Therefore do not change the syntax.
                   If "kdcEnabled" parameter is true, IS will allow service principle management.
                   Thus "ServicePasswordJavaRegEx", "ServiceNameJavaRegEx" properties control the service name format and
                   service password formats. In case if user core cache domain is needed to identify uniquely set property
                   <Property name="UserCoreCacheIdentifier">domain</Property>
              -->
          <!--ISUserStoreManager class="org.wso2.carbon.user.core.ldap.ReadWriteLDAPUserStoreManager">
                  <Property name="TenantManager">org.wso2.carbon.user.core.tenant.CommonHybridLDAPTenantManager</Property>
                  <Property name="ConnectionURL">ldap://localhost:${Ports.EmbeddedLDAP.LDAPServerPort}</Property>
                  <Property name="ConnectionName">uid=admin,ou=system</Property>
                  <Property name="ConnectionPassword">admin</Property>
                  <Property name="AnonymousBind">false</Property>
                  <Property name="UserSearchBase">ou=Users,dc=wso2,dc=org</Property>
                  <Property name="UserEntryObjectClass">identityPerson</Property>
                  <Property name="UserNameAttribute">uid</Property>
                  <Property name="UserNameSearchFilter">(&amp;(objectClass=person)(uid=?))</Property>
                  <Property name="UserNameListFilter">(&amp;(objectClass=person)(!(sn=Service)))</Property>
                  <Property name="DisplayNameAttribute"/>
                  <Property name="ReadGroups">true</Property>
                  <Property name="WriteGroups">true</Property>
                  <Property name="GroupSearchBase">ou=Groups,dc=wso2,dc=org</Property>
                  <Property name="GroupEntryObjectClass">groupOfNames</Property>
                  <Property name="GroupNameAttribute">cn</Property>
                  <Property name="GroupNameSearchFilter">(&amp;(objectClass=groupOfNames)(cn=?))</Property>
                  <Property name="GroupNameListFilter">(objectClass=groupOfNames)</Property>
                  <Property name="MembershipAttribute">member</Property>
                  <Property name="BackLinksEnabled">false</Property>
                  <Property name="UsernameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="UsernameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="UsernameJavaRegExViolationErrorMsg">Username pattern policy violated</Property>
                  <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaScriptRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaRegExViolationErrorMsg">Password length should be within 5 to 30 characters</Property>
                  <Property name="RolenameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="RolenameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="SCIMEnabled">true</Property>
                  <Property name="IsBulkImportSupported">true</Property>
                  <Property name="EmptyRolesAllowed">true</Property>
                  <Property name="PasswordHashMethod">PLAIN_TEXT</Property>
                  <Property name="MultiAttributeSeparator">,</Property>
                  <Property name="MaxUserNameListLength">100</Property>
                  <Property name="MaxRoleNameListLength">100</Property>
                  <Property name="kdcEnabled">false</Property>
                  <Property name="defaultRealmName">WSO2.ORG</Property>
                  <Property name="UserRolesCacheEnabled">true</Property>
                  <Property name="ConnectionPoolingEnabled">false</Property>
                  <Property name="LDAPConnectionTimeout">5000</Property>
                  <Property name="ReadTimeout"/>
                  <Property name="RetryAttempts"/>
                  <Property name="StartTLSEnabled">false</Property>
              </ISUserStoreManager-->
          <AuthorizationManager class="org.wso2.carbon.user.core.authorization.JDBCAuthorizationManager">
            <Property name="AdminRoleManagementPermissions">/permission</Property>
            <Property name="AuthorizationCacheEnabled">true</Property>
            <Property name="GetAllRolesOfUserEnabled">false</Property>
          </AuthorizationManager>
        </Realm>
      </UserManager>
      <!--
      
      ************* Description of some of the configuration properties used in user-mgt.xml *********************************
      
      DomainName -
          This property must be used by all secondary user store managers in multiple user store configuration.
          DomainName is a unique identifier given to the user store. Users must provide both the domain name and
          username at log-in as "DomainName\Username"
      
      UserRolesCacheEnabled -
          This is to indicate whether to cache role list of a user. By default it is set to true.
          You may need to disable it if user-roles are changed by external means and need to reflect
          those changes in the carbon product immediately.
      
      ReplaceEscapeCharactersAtUserLogin -
          This is to configure whether escape characters in user name needs to be replaced at user login.
          Currently the identified escape characters that needs to be replaced are '\' & '\\'
      
      UserDNPattern -
          This property will be used when authenticating users. During authentication we do a bind. But if the user is login
          with email address or some other property we need to first lookup LDAP and retrieve DN for the user.
          This involves an additional step.  If UserDNPattern is specified the DN will be constructed using the pattern
          specified in this property. Performance of this is much better than looking up DN and binding user.
      
      RoleDNPattern -
          This property will be used when checking whether user has been assigned to a given role.
          Rather than searching the role in search base, by using this property direct search can be done.
      
      PasswordHashMethod -
          This says how the password should be stored. Allowed values are as follows,
              SHA - Uses SHA digest method
              MD5 - Uses MD 5 digest method
              PLAIN_TEXT - Plain text passwords
              In addition to above this supports all digest methods supported by http://docs.oracle.com/javase/6/docs/api/java/security/MessageDigest.html.
      
      DisplayNameAttribute -
          This is to have a dedicated LDAP attribute to display an entity(User/Role) in UI, in addition to the UserNameAttribute which is used for IS-UserStore interactions.
      -->

# ConfigMap message-broker-bin
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: message-broker-bin
  data:
    wso2server.sh: |-
      #!/bin/sh
      # ----------------------------------------------------------------------------
      # Main Script for the WSO2 Carbon Server
      #
      # Environment Variable Prequisites
      #
      #   CARBON_HOME   Home of WSO2 Carbon installation. If not set I will  try
      #                   to figure it out.
      #
      #   JAVA_HOME       Must point at your Java Development Kit installation.
      #
      #   JAVA_OPTS       (Optional) Java runtime options used when the commands
      #                   is executed.
      #
      # NOTE: Borrowed generously from Apache Tomcat startup scripts.
      # -----------------------------------------------------------------------------
      
      # OS specific support.  $var _must_ be set to either true or false.
      #ulimit -n 100000
      
      cygwin=false;
      darwin=false;
      os400=false;
      mingw=false;
      case "`uname`" in
      CYGWIN*) cygwin=true;;
      MINGW*) mingw=true;;
      OS400*) os400=true;;
      Darwin*) darwin=true
              if [ -z "$JAVA_VERSION" ] ; then
                   JAVA_VERSION="CurrentJDK"
                 else
                   echo "Using Java version: $JAVA_VERSION"
                 fi
                 if [ -z "$JAVA_HOME" ] ; then
                   JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/${JAVA_VERSION}/Home
                 fi
                 ;;
      esac
      
      # resolve links - $0 may be a softlink
      PRG="$0"
      
      while [ -h "$PRG" ]; do
        ls=`ls -ld "$PRG"`
        link=`expr "$ls" : '.*-> \(.*\)$'`
        if expr "$link" : '.*/.*' > /dev/null; then
          PRG="$link"
        else
          PRG=`dirname "$PRG"`/"$link"
        fi
      done
      
      # Get standard environment variables
      PRGDIR=`dirname "$PRG"`
      
      # Only set CARBON_HOME if not already set
      [ -z "$CARBON_HOME" ] && CARBON_HOME=`cd "$PRGDIR/.." ; pwd`
      
      # Set AXIS2_HOME. Needed for One Click JAR Download
      AXIS2_HOME="$CARBON_HOME"
      
      # For Cygwin, ensure paths are in UNIX format before anything is touched
      if $cygwin; then
        [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
        [ -n "$CARBON_HOME" ] && CARBON_HOME=`cygpath --unix "$CARBON_HOME"`
        [ -n "$AXIS2_HOME" ] && CARBON_HOME=`cygpath --unix "$CARBON_HOME"`
      fi
      
      # For OS400
      if $os400; then
        # Set job priority to standard for interactive (interactive - 6) by using
        # the interactive priority - 6, the helper threads that respond to requests
        # will be running at the same priority as interactive jobs.
        COMMAND='chgjob job('$JOBNAME') runpty(6)'
        system $COMMAND
      
        # Enable multi threading
        QIBM_MULTI_THREADED=Y
        export QIBM_MULTI_THREADED
      fi
      
      # For Migwn, ensure paths are in UNIX format before anything is touched
      if $mingw ; then
        [ -n "$CARBON_HOME" ] &&
          CARBON_HOME="`(cd "$CARBON_HOME"; pwd)`"
        [ -n "$JAVA_HOME" ] &&
          JAVA_HOME="`(cd "$JAVA_HOME"; pwd)`"
        [ -n "$AXIS2_HOME" ] &&
          CARBON_HOME="`(cd "$CARBON_HOME"; pwd)`"
        # TODO classpath?
      fi
      
      if [ -z "$JAVACMD" ] ; then
        if [ -n "$JAVA_HOME"  ] ; then
          if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
            # IBM's JDK on AIX uses strange locations for the executables
            JAVACMD="$JAVA_HOME/jre/sh/java"
          else
            JAVACMD="$JAVA_HOME/bin/java"
          fi
        else
          JAVACMD=java
        fi
      fi
      
      if [ ! -x "$JAVACMD" ] ; then
        echo "Error: JAVA_HOME is not defined correctly."
        echo " CARBON cannot execute $JAVACMD"
        exit 1
      fi
      
      # if JAVA_HOME is not set we're not happy
      if [ -z "$JAVA_HOME" ]; then
        echo "You must set the JAVA_HOME variable before running CARBON."
        exit 1
      fi
      
      if [ -e "$CARBON_HOME/wso2carbon.pid" ]; then
        PID=`cat "$CARBON_HOME"/wso2carbon.pid`
      fi
      
      # ----- Process the input command ----------------------------------------------
      args=""
      for c in $*
      do
          if [ "$c" = "--debug" ] || [ "$c" = "-debug" ] || [ "$c" = "debug" ]; then
                CMD="--debug"
                continue
          elif [ "$CMD" = "--debug" ]; then
                if [ -z "$PORT" ]; then
                      PORT=$c
                fi
          elif [ "$c" = "--stop" ] || [ "$c" = "-stop" ] || [ "$c" = "stop" ]; then
                CMD="stop"
          elif [ "$c" = "--start" ] || [ "$c" = "-start" ] || [ "$c" = "start" ]; then
                CMD="start"
          elif [ "$c" = "--version" ] || [ "$c" = "-version" ] || [ "$c" = "version" ]; then
                CMD="version"
          elif [ "$c" = "--restart" ] || [ "$c" = "-restart" ] || [ "$c" = "restart" ]; then
                CMD="restart"
          elif [ "$c" = "--test" ] || [ "$c" = "-test" ] || [ "$c" = "test" ]; then
                CMD="test"
          else
              args="$args $c"
          fi
      done
      
      if [ "$CMD" = "--debug" ]; then
        if [ "$PORT" = "" ]; then
          echo " Please specify the debug port after the --debug option"
          exit 1
        fi
        if [ -n "$JAVA_OPTS" ]; then
          echo "Warning !!!. User specified JAVA_OPTS will be ignored, once you give the --debug option."
        fi
        CMD="RUN"
        JAVA_OPTS="-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=$PORT"
        echo "Please start the remote debugging client to continue..."
      elif [ "$CMD" = "start" ]; then
        if [ -e "$CARBON_HOME/wso2carbon.pid" ]; then
          if  ps -p $PID > /dev/null ; then
            echo "Process is already running"
            exit 0
          fi
        fi
        export CARBON_HOME="$CARBON_HOME"
      # using nohup sh to avoid erros in solaris OS.TODO
        nohup sh "$CARBON_HOME"/bin/wso2server.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "stop" ]; then
        export CARBON_HOME="$CARBON_HOME"
        kill -term `cat "$CARBON_HOME"/wso2carbon.pid`
        exit 0
      elif [ "$CMD" = "restart" ]; then
        export CARBON_HOME="$CARBON_HOME"
        kill -term `cat "$CARBON_HOME"/wso2carbon.pid`
        process_status=0
        pid=`cat "$CARBON_HOME"/wso2carbon.pid`
        while [ "$process_status" -eq "0" ]
        do
              sleep 1;
              ps -p$pid 2>&1 > /dev/null
              process_status=$?
        done
      
      # using nohup sh to avoid erros in solaris OS.TODO
        nohup sh "$CARBON_HOME"/bin/wso2server.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "test" ]; then
          JAVACMD="exec "$JAVACMD""
      elif [ "$CMD" = "version" ]; then
        cat "$CARBON_HOME"/bin/version.txt
        cat "$CARBON_HOME"/bin/wso2carbon-version.txt
        exit 0
      fi
      
      # ---------- Handle the SSL Issue with proper JDK version --------------------
      jdk_17=`$JAVA_HOME/bin/java -version 2>&1 | grep "1.[7|8]"`
      if [ "$jdk_17" = "" ]; then
         echo " Starting WSO2 Carbon (in unsupported JDK)"
         echo " [ERROR] CARBON is supported only on JDK 1.7 and 1.8"
      fi
      
      CARBON_XBOOTCLASSPATH=""
      for f in "$CARBON_HOME"/../lib/xboot/*.jar
      do
          if [ "$f" != "$CARBON_HOME/wso2/lib/xboot/*.jar" ];then
              CARBON_XBOOTCLASSPATH="$CARBON_XBOOTCLASSPATH":$f
          fi
      done
      
      JAVA_ENDORSED_DIRS="$CARBON_HOME/../lib/endorsed":"$JAVA_HOME/jre/lib/endorsed":"$JAVA_HOME/lib/endorsed"
      
      CARBON_CLASSPATH=""
      if [ -e "$JAVA_HOME/lib/tools.jar" ]; then
          CARBON_CLASSPATH="$JAVA_HOME/../lib/tools.jar"
      fi
      for f in "$CARBON_HOME"/bin/*.jar
      do
          if [ "$f" != "$CARBON_HOME/bin/*.jar" ];then
              CARBON_CLASSPATH="$CARBON_CLASSPATH":$f
          fi
      done
      for t in "$CARBON_HOME"/../lib/commons-lang*.jar
      do
          CARBON_CLASSPATH="$CARBON_CLASSPATH":$t
      done
      # For Cygwin, switch paths to Windows format before running java
      if $cygwin; then
        JAVA_HOME=`cygpath --absolute --windows "$JAVA_HOME"`
        CARBON_HOME=`cygpath --absolute --windows "$CARBON_HOME"`
        AXIS2_HOME=`cygpath --absolute --windows "$CARBON_HOME"`
        CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
        JAVA_ENDORSED_DIRS=`cygpath --path --windows "$JAVA_ENDORSED_DIRS"`
        CARBON_CLASSPATH=`cygpath --path --windows "$CARBON_CLASSPATH"`
        CARBON_XBOOTCLASSPATH=`cygpath --path --windows "$CARBON_XBOOTCLASSPATH"`
      fi
      
      # ----- Execute The Requested Command -----------------------------------------
      
      echo JAVA_HOME environment variable is set to $JAVA_HOME
      echo CARBON_HOME environment variable is set to "$CARBON_HOME"
      
      cd "$CARBON_HOME"
      
      TMP_DIR="$CARBON_HOME"/tmp
      if [ -d "$TMP_DIR" ]; then
      rm -rf "$TMP_DIR"/*
      fi
      
      START_EXIT_STATUS=121
      status=$START_EXIT_STATUS
      
      if [ -z "$JVM_MEM_OPTS" ]; then
         java_version=$("$JAVACMD" -version 2>&1 | awk -F '"' '/version/ {print $2}')
         JVM_MEM_OPTS="-Xms256m -Xmx1024m"
         if [ "$java_version" \< "1.8" ]; then
            JVM_MEM_OPTS="$JVM_MEM_OPTS"
         fi
      fi
      echo "Using Java memory options: $JVM_MEM_OPTS"
      
      #setting up profile parameter for runtime in MB
      PROFILE_SELECTED="false"
      for i in "$@"; do
         if echo "$i" | grep -q "Dprofile"; then
            PROFILE_SELECTED="true"
         fi
      done
      
      if [ "$PROFILE_SELECTED" = false ] ; then
         NODE_PARAMS="$NODE_PARAMS -Dprofile=broker-default"
      fi
      
      #To monitor a Carbon server in remote JMX mode on linux host machines, set the below system property.
      #   -Djava.rmi.server.hostname="your.IP.goes.here"
      
      while [ "$status" = "$START_EXIT_STATUS" ]
      do
          $JAVACMD \
          -Xbootclasspath/a:"$CARBON_XBOOTCLASSPATH" \
          $JVM_MEM_OPTS \
          -XX:+HeapDumpOnOutOfMemoryError \
          -XX:HeapDumpPath="$CARBON_HOME/repository/logs/heap-dump.hprof" \
          $JAVA_OPTS \
          -Dcom.sun.management.jmxremote \
          -classpath "$CARBON_CLASSPATH" \
          -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" \
          -Djava.io.tmpdir="$CARBON_HOME/tmp" \
          -Dcatalina.base="$CARBON_HOME/../lib/tomcat" \
          -Dwso2.server.standalone=true \
          -Dcarbon.registry.root=/ \
          -Djava.command="$JAVACMD" \
          -DandesConfig=broker.xml \
          -Dqpid.conf="/conf/advanced/" \
          -Dcarbon.home="$CARBON_HOME" \
          -Dlogger.server.name="EI-Broker" \
          -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager \
          -Dcarbon.config.dir.path="$CARBON_HOME/conf" \
          -Dcarbon.repository.dir.path="$CARBON_HOME/repository" \
          -Dcarbon.components.dir.path="$CARBON_HOME/../components" \
          -Dcarbon.extensions.dir.path="$CARBON_HOME/../../extensions" \
          -Dcarbon.dropins.dir.path="$CARBON_HOME/../../dropins" \
          -Dcarbon.external.lib.dir.path="$CARBON_HOME/../../lib" \
          -Dcarbon.patches.dir.path="$CARBON_HOME/../../patches" \
          -Dcarbon.servicepacks.dir.path="$CARBON_HOME/../../servicepacks" \
          -Dcarbon.internal.lib.dir.path="$CARBON_HOME/../lib" \
          -Djava.util.logging.config.file="$CARBON_HOME/conf/etc/logging-bridge.properties" \
          -Dcomponents.repo="$CARBON_HOME/../components/plugins" \
          -Dconf.location="$CARBON_HOME/../broker/conf" \
          -Dcom.atomikos.icatch.file="$CARBON_HOME/../lib/transactions.properties" \
          -Dcom.atomikos.icatch.hide_init_file_path=true \
          -Dorg.apache.jasper.compiler.Parser.STRICT_QUOTE_ESCAPING=false \
          -Dorg.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER=true \
          -Dcom.sun.jndi.ldap.connect.pool.authentication=simple  \
          -Dcom.sun.jndi.ldap.connect.pool.timeout=3000  \
          -Dorg.terracotta.quartz.skipUpdateCheck=true \
          -Djava.security.egd=file:/dev/./urandom \
          -Dfile.encoding=UTF8 \
          -Djava.net.preferIPv4Stack=true \
          -Dcom.ibm.cacheLocalHost=true \
          -DworkerNode=false \
          -Dorg.apache.cxf.io.CachedOutputStream.Threshold=104857600 \
          $NODE_PARAMS \
          -javaagent:/home/wso2carbon/prometheus/jmx_prometheus_javaagent-0.12.0.jar=2222:/home/wso2carbon/prometheus/config.yaml \
          org.wso2.carbon.bootstrap.Bootstrap $*
          status=$?
      done

# ConfigMap integrator-bin
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: integrator-bin
  data:
    integrator.sh: |-
      #!/bin/sh
      # ----------------------------------------------------------------------------
      # Main Script for the WSO2 Carbon Server
      #
      # Environment Variable Prequisites
      #
      #   CARBON_HOME   Home of WSO2 Carbon installation. If not set I will  try
      #                   to figure it out.
      #
      #   JAVA_HOME       Must point at your Java Development Kit installation.
      #
      #   JAVA_OPTS       (Optional) Java runtime options used when the commands
      #                   is executed.
      #
      # NOTE: Borrowed generously from Apache Tomcat startup scripts.
      # -----------------------------------------------------------------------------
      
      # OS specific support.  $var _must_ be set to either true or false.
      #ulimit -n 100000
      
      cygwin=false;
      darwin=false;
      os400=false;
      mingw=false;
      case "`uname`" in
      CYGWIN*) cygwin=true;;
      MINGW*) mingw=true;;
      OS400*) os400=true;;
      Darwin*) darwin=true
              if [ -z "$JAVA_VERSION" ] ; then
                   JAVA_VERSION="CurrentJDK"
                 else
                   echo "Using Java version: $JAVA_VERSION"
                 fi
                 if [ -z "$JAVA_HOME" ] ; then
                   JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/${JAVA_VERSION}/Home
                 fi
                 ;;
      esac
      
      # resolve links - $0 may be a softlink
      PRG="$0"
      
      while [ -h "$PRG" ]; do
        ls=`ls -ld "$PRG"`
        link=`expr "$ls" : '.*-> \(.*\)$'`
        if expr "$link" : '.*/.*' > /dev/null; then
          PRG="$link"
        else
          PRG=`dirname "$PRG"`/"$link"
        fi
      done
      
      # Get standard environment variables
      PRGDIR=`dirname "$PRG"`
      
      # Only set CARBON_HOME if not already set
      [ -z "$CARBON_HOME" ] && CARBON_HOME=`cd "$PRGDIR/.." ; pwd`
      
      # Set AXIS2_HOME. Needed for One Click JAR Download
      AXIS2_HOME="$CARBON_HOME"
      
      # For Cygwin, ensure paths are in UNIX format before anything is touched
      if $cygwin; then
        [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
        [ -n "$CARBON_HOME" ] && CARBON_HOME=`cygpath --unix "$CARBON_HOME"`
        [ -n "$AXIS2_HOME" ] && CARBON_HOME=`cygpath --unix "$CARBON_HOME"`
      fi
      
      # For OS400
      if $os400; then
        # Set job priority to standard for interactive (interactive - 6) by using
        # the interactive priority - 6, the helper threads that respond to requests
        # will be running at the same priority as interactive jobs.
        COMMAND='chgjob job('$JOBNAME') runpty(6)'
        system $COMMAND
      
        # Enable multi threading
        QIBM_MULTI_THREADED=Y
        export QIBM_MULTI_THREADED
      fi
      
      # For Migwn, ensure paths are in UNIX format before anything is touched
      if $mingw ; then
        [ -n "$CARBON_HOME" ] &&
          CARBON_HOME="`(cd "$CARBON_HOME"; pwd)`"
        [ -n "$JAVA_HOME" ] &&
          JAVA_HOME="`(cd "$JAVA_HOME"; pwd)`"
        [ -n "$AXIS2_HOME" ] &&
          CARBON_HOME="`(cd "$CARBON_HOME"; pwd)`"
        # TODO classpath?
      fi
      
      if [ -z "$JAVACMD" ] ; then
        if [ -n "$JAVA_HOME"  ] ; then
          if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
            # IBM's JDK on AIX uses strange locations for the executables
            JAVACMD="$JAVA_HOME/jre/sh/java"
          else
            JAVACMD="$JAVA_HOME/bin/java"
          fi
        else
          JAVACMD=java
        fi
      fi
      
      if [ ! -x "$JAVACMD" ] ; then
        echo "Error: JAVA_HOME is not defined correctly."
        echo " CARBON cannot execute $JAVACMD"
        exit 1
      fi
      
      # if JAVA_HOME is not set we're not happy
      if [ -z "$JAVA_HOME" ]; then
        echo "You must set the JAVA_HOME variable before running CARBON."
        exit 1
      fi
      
      if [ -e "$CARBON_HOME/wso2carbon.pid" ]; then
        PID=`cat "$CARBON_HOME"/wso2carbon.pid`
      fi
      
      # ----- Process the input command ----------------------------------------------
      args=""
      for c in $*
      do
          if [ "$c" = "--debug" ] || [ "$c" = "-debug" ] || [ "$c" = "debug" ]; then
                CMD="--debug"
                continue
          elif [ "$CMD" = "--debug" ]; then
                if [ -z "$PORT" ]; then
                      PORT=$c
                fi
          elif [ "$c" = "--stop" ] || [ "$c" = "-stop" ] || [ "$c" = "stop" ]; then
                CMD="stop"
          elif [ "$c" = "--start" ] || [ "$c" = "-start" ] || [ "$c" = "start" ]; then
                CMD="start"
          elif [ "$c" = "--version" ] || [ "$c" = "-version" ] || [ "$c" = "version" ]; then
                CMD="version"
          elif [ "$c" = "--restart" ] || [ "$c" = "-restart" ] || [ "$c" = "restart" ]; then
                CMD="restart"
          else
              args="$args $c"
          fi
      done
      
      if [ "$CMD" = "--debug" ]; then
        if [ "$PORT" = "" ]; then
          echo " Please specify the debug port after the --debug option"
          exit 1
        fi
        if [ -n "$JAVA_OPTS" ]; then
          echo "Warning !!!. User specified JAVA_OPTS will be ignored, once you give the --debug option."
        fi
        CMD="RUN"
        JAVA_OPTS="-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=$PORT"
        echo "Please start the remote debugging client to continue..."
      elif [ "$CMD" = "start" ]; then
        if [ -e "$CARBON_HOME/wso2carbon.pid" ]; then
          if  ps -p $PID > /dev/null ; then
            echo "Process is already running"
            exit 0
          fi
        fi
        export CARBON_HOME="$CARBON_HOME"
      # using nohup sh to avoid erros in solaris OS.TODO
        nohup sh "$CARBON_HOME"/bin/integrator.sh $args > /dev/null 2>&1 &
        exit 0
      elif [ "$CMD" = "stop" ]; then
        export CARBON_HOME="$CARBON_HOME"
        kill -term `cat "$CARBON_HOME"/wso2carbon.pid`
        exit 0
      elif [ "$CMD" = "restart" ]; then
        export CARBON_HOME="$CARBON_HOME"
        kill -term `cat "$CARBON_HOME"/wso2carbon.pid`
        process_status=0
        pid=`cat "$CARBON_HOME"/wso2carbon.pid`
        while [ "$process_status" -eq "0" ]
        do
              sleep 1;
              ps -p$pid 2>&1 > /dev/null
              process_status=$?
        done
      
      # using nohup sh to avoid erros in solaris OS.TODO
        nohup sh "$CARBON_HOME"/bin/integrator.sh $args > /dev/null 2>&1 &
        exit 0
      
      elif [ "$CMD" = "version" ]; then
        cat "$CARBON_HOME"/bin/version.txt
        cat "$CARBON_HOME"/bin/wso2carbon-version.txt
        exit 0
      fi
      
      # ---------- Handle the SSL Issue with proper JDK version --------------------
      jdk_17=`$JAVA_HOME/bin/java -version 2>&1 | grep "1.[7|8]"`
      if [ "$jdk_17" = "" ]; then
         echo " Starting WSO2 Carbon (in unsupported JDK)"
         echo " [ERROR] CARBON is supported only on JDK 1.7 and 1.8"
      fi
      
      CARBON_XBOOTCLASSPATH=""
      for f in "$CARBON_HOME"/wso2/lib/xboot/*.jar
      do
          if [ "$f" != "$CARBON_HOME/wso2/lib/xboot/*.jar" ];then
              CARBON_XBOOTCLASSPATH="$CARBON_XBOOTCLASSPATH":$f
          fi
      done
      
      JAVA_ENDORSED_DIRS="$CARBON_HOME/wso2/lib/endorsed":"$JAVA_HOME/jre/lib/endorsed":"$JAVA_HOME/lib/endorsed"
      
      CARBON_CLASSPATH=""
      if [ -e "$JAVA_HOME/lib/tools.jar" ]; then
          CARBON_CLASSPATH="$JAVA_HOME/lib/tools.jar"
      fi
      for f in "$CARBON_HOME"/bin/*.jar
      do
          if [ "$f" != "$CARBON_HOME/bin/*.jar" ];then
              CARBON_CLASSPATH="$CARBON_CLASSPATH":$f
          fi
      done
      for t in "$CARBON_HOME"/wso2/lib/commons-lang*.jar
      do
          CARBON_CLASSPATH="$CARBON_CLASSPATH":$t
      done
      # For Cygwin, switch paths to Windows format before running java
      if $cygwin; then
        JAVA_HOME=`cygpath --absolute --windows "$JAVA_HOME"`
        CARBON_HOME=`cygpath --absolute --windows "$CARBON_HOME"`
        AXIS2_HOME=`cygpath --absolute --windows "$CARBON_HOME"`
        CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
        JAVA_ENDORSED_DIRS=`cygpath --path --windows "$JAVA_ENDORSED_DIRS"`
        CARBON_CLASSPATH=`cygpath --path --windows "$CARBON_CLASSPATH"`
        CARBON_XBOOTCLASSPATH=`cygpath --path --windows "$CARBON_XBOOTCLASSPATH"`
      fi
      
      # ----- Execute The Requested Command -----------------------------------------
      
      echo JAVA_HOME environment variable is set to $JAVA_HOME
      echo CARBON_HOME environment variable is set to "$CARBON_HOME"
      
      cd "$CARBON_HOME"
      
      TMP_DIR="$CARBON_HOME"/tmp
      if [ -d "$TMP_DIR" ]; then
      rm -rf "$TMP_DIR"/*
      fi
      
      START_EXIT_STATUS=121
      status=$START_EXIT_STATUS
      
      if [ -z "$JVM_MEM_OPTS" ]; then
         java_version=$("$JAVACMD" -version 2>&1 | awk -F '"' '/version/ {print $2}')
         JVM_MEM_OPTS="-Xms256m -Xmx1024m"
         if [ "$java_version" \< "1.8" ]; then
            JVM_MEM_OPTS="$JVM_MEM_OPTS"
         fi
      fi
      echo "Using Java memory options: $JVM_MEM_OPTS"
      
      #To monitor a Carbon server in remote JMX mode on linux host machines, set the below system property.
      #   -Djava.rmi.server.hostname="your.IP.goes.here"
      
      while [ "$status" = "$START_EXIT_STATUS" ]
      do
          $JAVACMD \
          -Xbootclasspath/a:"$CARBON_XBOOTCLASSPATH" \
          $JVM_MEM_OPTS \
          -XX:+HeapDumpOnOutOfMemoryError \
          -XX:HeapDumpPath="$CARBON_HOME/repository/logs/heap-dump.hprof" \
          $JAVA_OPTS \
          -Dcom.sun.management.jmxremote \
          -classpath "$CARBON_CLASSPATH" \
          -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" \
          -Djava.io.tmpdir="$CARBON_HOME/wso2/tmp" \
          -Dcatalina.base="$CARBON_HOME/wso2/lib/tomcat" \
          -Dwso2.server.standalone=true \
          -Dcarbon.registry.root=/ \
          -Djava.command="$JAVACMD" \
          -Dcarbon.home="$CARBON_HOME" \
          -Dlogger.server.name="EI-Core" \
          -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager \
          -Dcarbon.config.dir.path="$CARBON_HOME/conf" \
          -Dcarbon.components.dir.path="$CARBON_HOME/wso2/components" \
          -Dcarbon.extensions.dir.path="$CARBON_HOME/extensions" \
          -Dcarbon.dropins.dir.path="$CARBON_HOME/dropins" \
          -Dcarbon.external.lib.dir.path="$CARBON_HOME/lib" \
          -Dcarbon.patches.dir.path="$CARBON_HOME/patches" \
          -Dcarbon.servicepacks.dir.path="$CARBON_HOME/servicepacks" \
          -Dcarbon.internal.lib.dir.path="$CARBON_HOME/wso2/lib" \
          -Dei.extendedURIBasedDispatcher=org.wso2.carbon.integrator.core.handler.IntegratorStatefulHandler \
          -Djava.util.logging.config.file="$CARBON_HOME/conf/etc/logging-bridge.properties" \
          -Dcomponents.repo="$CARBON_HOME/wso2/components/plugins" \
          -Dconf.location="$CARBON_HOME/conf"\
          -Dcom.atomikos.icatch.file="$CARBON_HOME/wso2/lib/transactions.properties" \
          -Dcom.atomikos.icatch.hide_init_file_path=true \
          -Dorg.apache.jasper.compiler.Parser.STRICT_QUOTE_ESCAPING=false \
          -Dorg.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER=true \
          -Dcom.sun.jndi.ldap.connect.pool.authentication=simple  \
          -Dcom.sun.jndi.ldap.connect.pool.timeout=3000  \
          -Dorg.terracotta.quartz.skipUpdateCheck=true \
          -Djava.security.egd=file:/dev/./urandom \
          -Dfile.encoding=UTF8 \
          -Djava.net.preferIPv4Stack=true \
          -Dcom.ibm.cacheLocalHost=true \
          -DworkerNode=false \
          -Dorg.wso2.ignoreHostnameVerification=true \
          -Dorg.apache.activemq.SERIALIZABLE_PACKAGES="*" \
          -Dorg.apache.xml.security.ignoreLineBreaks=false \
          -javaagent:/home/wso2carbon/prometheus/jmx_prometheus_javaagent-0.12.0.jar=2222:/home/wso2carbon/prometheus/config.yaml \
          org.wso2.carbon.bootstrap.Bootstrap $*
          status=$?
      done

# ConfigMap integrator-conf-axis2
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: integrator-conf-axis2
  data:
    axis2.xml: |-
      <?xml version="1.0" encoding="ISO-8859-1"?>      
      <axisconfig name="AxisJava2.0">
          
          <!-- ================================================= -->
          <!--                  Parameters                       -->
          <!-- ================================================= -->
      
          <!-- Change this to true if you want to enable hot deployment of services -->
          <parameter name="hotdeployment" locked="false">true</parameter>
          <!-- Change this to true if you want to enable hot update of services -->
          <parameter name="hotupdate" locked="false">true</parameter>
      
          <!-- Change this to true if you want to enable MTOM -->
          <parameter name="enableMTOM" locked="false">false</parameter>
          <!-- Change this to true if you want to enable SwA -->
          <parameter name="enableSwA" locked="false">false</parameter>
      
          <!-- If you want to enable file caching for attachments change this to true -->
          <parameter name="cacheAttachments" locked="false">false</parameter>
          <!-- Attachment file caching location relative to CARBON_HOME -->
          <parameter name="attachmentDIR" locked="false">work/mtom</parameter>
          <!-- Attachment file cache threshold size -->
          <parameter name="sizeThreshold" locked="false">4000</parameter>
      
          <!-- Completely disable REST handling in Axis2/Synapse if the value is true -->
          <parameter name="disableREST" locked="false">false</parameter>
      
          <!-- Sandesha2 persistance storage manager -->
          <parameter name="Sandesha2StorageManager" locked="false">inmemory</parameter>
      
          <!-- Our HTTP endpoints can handle both REST and SOAP under the following service path. In -->
          <!-- case of a servlet container, if you change this you have to manually change the -->
          <!-- settings of your servlet container to map this context path to proper Axis2 servlets -->
          <parameter name="servicePath" locked="false">services</parameter>
      
          <!--the directory in which .aar services are deployed inside axis2 repository-->
          <parameter name="ServicesDirectory">axis2services</parameter>
      
          <!--If turned on with use the Accept header of the request to determine the contentType of the
          response-->
          <parameter name="httpContentNegotiation">true</parameter>
      
          <!--the directory in which modules are deployed inside axis2 repository-->
          <parameter name="ModulesDirectory">axis2modules</parameter>
      
          <!-- User agent and the server details to be used in the http communication -->
          <parameter name="userAgent" locked="true">WSO2 EI 6.6.0</parameter>
          <parameter name="server" locked="true">WSO2 EI 6.6.0</parameter>
      
          <!-- During a fault, stacktrace can be sent with the fault message. The following flag -->
          <!-- will control that behaviour -->
          <parameter name="sendStacktraceDetailsWithFaults" locked="false">false</parameter>
          
          <!-- If there aren't any information available to find out the fault reason, we set the -->
          <!-- message of the exception as the faultreason/Reason. But when a fault is thrown from -->
          <!-- a service or some where, it will be wrapped by different levels. Due to this the -->
          <!-- initial exception message can be lost. If this flag is set then, Axis2 tries to get -->
          <!-- the first exception and set its message as the faultreason/Reason. -->
          <parameter name="DrillDownToRootCauseForFaultReason" locked="false">false</parameter>
      
          <!-- Set the flag to true if you want to enable transport level session management -->
          <parameter name="manageTransportSession">true</parameter>
      
          <!-- This will give out the timout of the configuration contexts, in milliseconds -->
          <parameter name="ConfigContextTimeoutInterval" locked="false">30000</parameter>
      
          <!-- Synapse Configuration file location relative to CARBON_HOME -->
          <parameter name="SynapseConfig.ConfigurationFile" locked="false">repository/deployment/server/synapse-configs</parameter>
          <!-- Synapse Home parameter -->
          <parameter name="SynapseConfig.HomeDirectory" locked="false">.</parameter>
          <!-- Resolve root used to resolve synapse references like schemas inside a WSDL -->
          <parameter name="SynapseConfig.ResolveRoot" locked="false">.</parameter>
          <!-- Synapse Server name parameter -->
          <parameter name="SynapseConfig.ServerName" locked="false">localhost</parameter>
          <!-- Returns 401 for UT secured scenario with incorrect/missing credentials -->
          <parameter name="enableBasicAuth" locked="false">true</parameter>
      
          <!-- To override repository/services you need to uncomment following parameter and value -->
          <!-- SHOULD be absolute file path. -->
          <!--<parameter name="ServicesDirectory" locked="false">service</parameter>-->
      
          <!-- To override repository/modules you need to uncomment following parameter and value -->
          <!-- SHOULD be absolute file path. -->
          <!--<parameter name="ModulesDirectory" locked="false">modules</parameter>-->
      
          <!-- If you have a frontend host which exposes this webservice using a different public URL -->
          <!-- use this parameter to override autodetected url -->
          <!--<parameter name="httpFrontendHostUrl" locked="false">https://someotherhost/context</parameter>-->
      
          <!-- ================================================= -->
          <!--                  Listeners                        -->
          <!-- ================================================= -->
      
          <!-- This deployment interceptor will be called whenever before a module is initialized or -->
          <!-- service is deployed -->
          <listener class="org.wso2.carbon.core.deployment.DeploymentInterceptor"/>
      
          <!-- ================================================= -->
          <!--                  Deployers                        -->
          <!-- ================================================= -->
      
          <!-- Deployer for the dataservice. -->
          <!--<deployer extension="dbs" directory="dataservices" class="org.wso2.dataservices.core.DBDeployer"/>-->
      
          <!-- Axis1 deployer for Axis2 -->
          <!--<deployer extension="wsdd" class="org.wso2.carbon.axis1services.Axis1Deployer" directory="axis1services"/>-->
      
          <!-- POJO service deployer for Jar -->
          <!--<deployer extension="jar" class="org.apache.axis2.deployment.POJODeployer" directory="pojoservices"/>-->
      
          <!-- POJO service deployer for Class -->
          <!--<deployer extension="class" class="org.apache.axis2.deployment.POJODeployer" directory="pojoservices"/>-->
      
          <!-- JAXWS service deployer -->
          <!--<deployer extension=".jar" class="org.apache.axis2.jaxws.framework.JAXWSDeployer" directory="servicejars"/>-->
      
          <!-- ================================================= -->
          <!--                Message Receivers                  -->
          <!-- ================================================= -->
      
          <!-- This is the set of default Message Receivers for the system, if you want to have -->
          <!-- message receivers for any of the other Message exchange Patterns (MEP) implement it -->
          <!-- and add the implementation class to here, so that you can refer from any operation -->
          <!-- Note : You can override this for particular service by adding this same element to the -->
          <!-- services.xml with your preferences -->
          <messageReceivers>
              <messageReceiver mep="http://www.w3.org/ns/wsdl/in-only"
                               class="org.apache.axis2.rpc.receivers.RPCInOnlyMessageReceiver"/>
              <messageReceiver mep="http://www.w3.org/ns/wsdl/robust-in-only"
                               class="org.apache.axis2.rpc.receivers.RPCInOnlyMessageReceiver"/>
              <messageReceiver mep="http://www.w3.org/ns/wsdl/in-out"
                               class="org.apache.axis2.rpc.receivers.RPCMessageReceiver"/>
          </messageReceivers>
      
          <!-- ================================================= -->
          <!--                Message Formatters                 -->
          <!-- ================================================= -->
      
          <!-- Following content type to message formatter mapping can be used to implement support -->
          <!-- for different message format serializations in Axis2. These message formats are -->
          <!-- expected to be resolved based on the content type. -->
          <messageFormatters>
              <messageFormatter contentType="application/x-www-form-urlencoded"
                                class="org.apache.synapse.commons.formatters.XFormURLEncodedFormatter"/>
              <messageFormatter contentType="multipart/form-data"
                                class="org.apache.axis2.transport.http.MultipartFormDataFormatter"/>
              <messageFormatter contentType="application/xml"
                                class="org.apache.axis2.transport.http.ApplicationXMLFormatter"/>
              <messageFormatter contentType="text/xml"
                               class="org.apache.axis2.transport.http.SOAPMessageFormatter"/>
              <messageFormatter contentType="application/soap+xml"
                               class="org.apache.axis2.transport.http.SOAPMessageFormatter"/>
              <messageFormatter contentType="text/plain"
                               class="org.apache.axis2.format.PlainTextFormatter"/>
              <messageFormatter contentType="application/octet-stream"
                                class="org.wso2.carbon.relay.ExpandingMessageFormatter"/>
              <!--JSON Message Formatters-->
              <messageFormatter contentType="application/json"
                                class="org.wso2.carbon.integrator.core.json.JsonStreamFormatter"/>
              <!--messageFormatter contentType="application/x-www-form-urlencoded"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="multipart/form-data"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="application/xml"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="text/html"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="application/soap+xml"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
              <!--messageFormatter contentType="text/xml"
                              class="org.wso2.carbon.relay.ExpandingMessageFormatter"/-->
      	    <!--messageFormatter contentType="x-application/hessian"
                               class="org.apache.synapse.format.hessian.HessianMessageFormatter"/-->
              <!--messageFormatter contentType=""
                               class="org.apache.synapse.format.hessian.HessianMessageFormatter"/-->
              <!--messageFormatter contentType="application/edi-hl7"
                               class="org.wso2.carbon.business.messaging.hl7.message.HL7MessageFormatter"/-->
          </messageFormatters>
      
          <!-- ================================================= -->
          <!--                Message Builders                   -->
          <!-- ================================================= -->
      
          <!-- Following content type to builder mapping can be used to implement support for -->
          <!-- different message formats in Axis2. These message formats are expected to be -->
          <!-- resolved based on the content type. -->
          <messageBuilders>
              <messageBuilder contentType="application/xml"
                              class="org.apache.axis2.builder.ApplicationXMLBuilder"/>
              <messageBuilder contentType="application/x-www-form-urlencoded"
                              class="org.apache.synapse.commons.builders.XFormURLEncodedBuilder"/>
              <messageBuilder contentType="multipart/form-data"
                              class="org.apache.axis2.builder.MultipartFormDataBuilder"/>
              <messageBuilder contentType="text/plain"
                              class="org.apache.axis2.format.PlainTextBuilder"/>
              <messageBuilder contentType="application/octet-stream"
                              class="org.wso2.carbon.relay.BinaryRelayBuilder"/>
              <!--JSON Message Builders-->
              <messageBuilder contentType="application/json"
                              class="org.wso2.carbon.integrator.core.json.JsonStreamBuilder"/>
      	    <!--messageBuilder contentType="application/xml"
                              class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="application/x-www-form-urlencoded"
                              class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="multipart/form-data"
                              class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="multipart/related"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="application/soap+xml"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="text/plain"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="text/xml"
                             class="org.wso2.carbon.relay.BinaryRelayBuilder"/-->
              <!--messageBuilder contentType="x-application/hessian"
                              class="org.apache.synapse.format.hessian.HessianMessageBuilder"/-->
              <!--messageBuilder contentType=""
                               class="org.apache.synapse.format.hessian.HessianMessageBuilder"/-->
              <!--messageBuilder contentType="application/edi-hl7"
                              class="org.wso2.carbon.business.messaging.hl7.message.HL7MessageBuilder"/-->
          </messageBuilders>
      
          <!-- ================================================= -->
          <!--             Transport Ins (Listeners)             -->
          <!-- ================================================= -->
      
           <transportReceiver name="http" class="org.apache.synapse.transport.passthru.PassThroughHttpListener">
              <parameter name="port" locked="false">8280</parameter>
              <parameter name="non-blocking" locked="false">true</parameter>
              <!--<parameter name="bind-address" locked="false">wso2ei-gateway</parameter>-->
              <parameter name="WSDLEPRPrefix" locked="false">http://wso2ei-gateway</parameter>
              <parameter name="httpGetProcessor" locked="false">org.wso2.carbon.mediation.transport.handlers.PassThroughNHttpGetProcessor</parameter>
              <!--<parameter name="priorityConfigFile" locked="false">location of priority configuration file</parameter>-->
          </transportReceiver>
      
           <transportReceiver name="https" class="org.apache.synapse.transport.passthru.PassThroughHttpSSLListener">
              <parameter name="port" locked="false">8243</parameter>
              <parameter name="non-blocking" locked="false">true</parameter>
              <parameter name="HttpsProtocols">TLSv1,TLSv1.1,TLSv1.2</parameter>
              <!--<parameter name="bind-address" locked="false">wso2ei-gateway</parameter>-->
              <parameter name="WSDLEPRPrefix" locked="false">https://wso2ei-gateway</parameter>
              <parameter name="httpGetProcessor" locked="false">org.wso2.carbon.mediation.transport.handlers.PassThroughNHttpGetProcessor</parameter>
              <parameter name="keystore" locked="false">
                  <KeyStore>
                      <Location>repository/resources/security/wso2carbon.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                      <KeyPassword>wso2carbon</KeyPassword>
                  </KeyStore>
              </parameter>
              <parameter name="truststore" locked="false">
                  <TrustStore>
                      <Location>repository/resources/security/client-truststore.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                  </TrustStore>
              </parameter>
              <!--<parameter name="SSLVerifyClient">require</parameter>
                  supports optional|require or defaults to none -->
          </transportReceiver>
      
          <transportReceiver name="local" class="org.wso2.carbon.core.transports.local.CarbonLocalTransportReceiver"/>
      
          <!--<transportReceiver name="vfs" class="org.apache.synapse.transport.vfs.VFSTransportListener"/>-->
      
          <!--<transportReceiver name="mailto" class="org.apache.axis2.transport.mail.MailTransportListener">-->
              <!-- configure any optional POP3/IMAP properties
              check com.sun.mail.pop3 and com.sun.mail.imap package documentation for more details-->
          <!--</transportReceiver>-->
      
          <!--Uncomment this and configure as appropriate for JMS transport support, after setting up your JMS environment (e.g. ActiveMQ)
          <transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
              <parameter name="myTopicConnectionFactory" locked="false">
              	<parameter name="java.naming.factory.initial" locked="false">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              	<parameter name="java.naming.provider.url" locked="false">tcp://localhost:61616</parameter>
              	<parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">TopicConnectionFactory</parameter>
      		    <parameter name="transport.jms.ConnectionFactoryType" locked="false">topic</parameter>
              </parameter>
      
              <parameter name="myQueueConnectionFactory" locked="false">
              	<parameter name="java.naming.factory.initial" locked="false">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              	<parameter name="java.naming.provider.url" locked="false">tcp://localhost:61616</parameter>
              	<parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
      		    <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
      
              <parameter name="default" locked="false">
              	<parameter name="java.naming.factory.initial" locked="false">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              	<parameter name="java.naming.provider.url" locked="false">tcp://localhost:61616</parameter>
              	<parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
      		    <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
          </transportReceiver>-->
      
          <!--Uncomment this and configure as appropriate for JMS transport support with Apache Qpid -->
          <!--transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
              <parameter name="myTopicConnectionFactory" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.apache.qpid.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">TopicConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">topic</parameter>
              </parameter>
      
              <parameter name="myQueueConnectionFactory" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.apache.qpid.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
      
              <parameter name="default" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.apache.qpid.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
          </transportReceiver-->
      
          <!--Uncomment this and configure as appropriate for JMS transport support with WSO2 EI Broker Profile -->
          <transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
              <parameter name="myTopicConnectionFactory" locked="false">
                 <parameter name="java.naming.factory.initial" locked="false">org.wso2.andes.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">TopicConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">topic</parameter>
              </parameter>
      
              <parameter name="myQueueConnectionFactory" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.wso2.andes.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                 <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
      
              <parameter name="default" locked="false">
                  <parameter name="java.naming.factory.initial" locked="false">org.wso2.andes.jndi.PropertiesFileInitialContextFactory</parameter>
                  <parameter name="java.naming.provider.url" locked="false">conf/jndi.properties</parameter>
                  <parameter name="transport.jms.ConnectionFactoryJNDIName" locked="false">QueueConnectionFactory</parameter>
                  <parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
              </parameter>
          </transportReceiver>
      
          <!--Uncomment this for FIX transport support
          <transportReceiver name="fix" class="org.apache.synapse.transport.fix.FIXTransportListener"/>
          -->
          
          <!--transportReceiver name="hl7" class="org.wso2.carbon.business.messaging.hl7.transport.HL7TransportListener"/-->
      
          <!-- SAP Transport Listeners -->
          <!-- <transportReceiver name="idoc" class="org.wso2.carbon.transports.sap.SAPTransportListener"/> -->
          <!-- <transportReceiver name="bapi" class="org.wso2.carbon.transports.sap.SAPTransportListener"/> -->
      
          <!--Uncomment this and configure as appropriate for RabbitMQ transport support
          <transportReceiver name="rabbitmq" class="org.apache.axis2.transport.rabbitmq.RabbitMQListener">
              <parameter name="AMQPConnectionFactory" locked="false">
                  <parameter name="rabbitmq.server.host.name" locked="false">localhost</parameter>
                  <parameter name="rabbitmq.server.port" locked="false">5672</parameter>
                  <parameter name="rabbitmq.server.user.name" locked="false"></parameter>
                  <parameter name="rabbitmq.server.password" locked="false"></parameter>
                  <parameter name="rabbitmq.connection.retry.interval" locked="false">10000</parameter>
                  <parameter name="rabbitmq.connection.retry.count" locked="false">5</parameter>
              </parameter>
          </transportReceiver-->
      
         <!-- <transportReceiver name="mqtt" class="org.apache.axis2.transport.mqtt.MqttListener">
              <parameter locked="false" name="mqttConFactory">
                  <parameter locked="false" name="mqtt.server.host.name">localhost</parameter>
                  <parameter name="mqtt.connection.factory">mqttConFactory</parameter>
                  <parameter locked="false" name="mqtt.server.port">1883</parameter>
                  <parameter locked="false" name="mqtt.client.id">client-id-1234</parameter>
                  <parameter locked="false" name="mqtt.topic.name">esb.test</parameter>
              </parameter>
          </transportReceiver>-->
      
          <!-- ================================================= -->
          <!--             Transport Outs (Senders)              -->
          <!-- ================================================= -->
      
          <transportSender name="http" class="org.apache.synapse.transport.passthru.PassThroughHttpSender">
              <parameter name="non-blocking" locked="false">true</parameter>
              <!--<parameter name="warnOnHTTP500" locked="false">*</parameter>-->
              <!--parameter name="http.proxyHost" locked="false">localhost</parameter-->
              <!--<parameter name="http.proxyPort" locked="false">3128</parameter>-->
              <!--<parameter name="http.nonProxyHosts" locked="false">localhost|moon|sun</parameter>-->
          </transportSender>
      
          <transportSender name="https" class="org.apache.synapse.transport.passthru.PassThroughHttpSSLSender">
              <parameter name="non-blocking" locked="false">true</parameter>
              <parameter name="keystore" locked="false">
                  <KeyStore>
                      <Location>repository/resources/security/wso2carbon.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                      <KeyPassword>wso2carbon</KeyPassword>
                  </KeyStore>
              </parameter>
              <parameter name="truststore" locked="false">
                  <TrustStore>
                      <Location>repository/resources/security/client-truststore.jks</Location>
                      <Type>JKS</Type>
                      <Password>wso2carbon</Password>
                  </TrustStore>
              </parameter>
              <!--<parameter name="HostnameVerifier">DefaultAndLocalhost</parameter>-->
                  <!--supports Strict|AllowAll|DefaultAndLocalhost or the default if none specified -->
          </transportSender>
      
          <transportSender name="local" class="org.wso2.carbon.core.transports.local.CarbonLocalTransportSender"/>
      
          <!--Uncomment this local transport to use local transport in mediation flow-->
          <!--<transportSender name="local" class="org.apache.axis2.transport.local.NonBlockingLocalTransportSender"/>-->
      
         <!-- uncomment this and configure to use connection pools for sending messages-->
           <transportSender name="jms" class="org.apache.axis2.transport.jms.JMSSender"/>
      
          <!--transportSender name="vfs" class="org.apache.synapse.transport.vfs.VFSTransportSender"/-->
      
          <!-- Uncomment and configure the SMTP server information
          check com.sun.mail.smtp package documentation for descriptions of properties
          <transportSender name="mailto" class="org.apache.axis2.transport.mail.MailTransportSender">
              <parameter name="mail.smtp.host">smtp.gmail.com</parameter>
              <parameter name="mail.smtp.port">587</parameter>
              <parameter name="mail.smtp.starttls.enable">true</parameter>
              <parameter name="mail.smtp.auth">true</parameter>
              <parameter name="mail.smtp.user">synapse.demo.0</parameter>
              <parameter name="mail.smtp.password">mailpassword</parameter>
              <parameter name="mail.smtp.from">synapse.demo.0@gmail.com</parameter>
          </transportSender>-->
      
          <!--Uncomment this for FIX transport support
          <transportSender name="fix" class="org.apache.synapse.transport.fix.FIXTransportSender"/>
          -->
          
          <!--transportSender name="hl7" class="org.wso2.carbon.business.messaging.hl7.transport.HL7TransportSender"/-->
      
          <!-- SAP Transport Senders -->
          <!-- <transportSender name="idoc" class="org.wso2.carbon.transports.sap.SAPTransportSender"/> -->
          <!-- <transportSender name="bapi" class="org.wso2.carbon.transports.sap.SAPTransportSender"/> -->
      
          <!-- Uncomment this and configure to use RabbitMQ connection pools for sending messages
          <transportSender name="rabbitmq" class="org.apache.axis2.transport.rabbitmq.RabbitMQSender"/-->
      
          <!--<transportSender name="mqtt" class="org.apache.axis2.transport.mqtt.MqttSender"/>-->
          
          <!--<transportSender name="ws" class="org.wso2.carbon.websocket.transport.WebsocketTransportSender">
              <parameter name="ws.outflow.dispatch.sequence" locked="false">outflowDispatchSeq</parameter>
              <parameter name="ws.outflow.dispatch.fault.sequence" locked="false">outflowFaultSeq</parameter>       
          </transportSender>-->
          
          <!--<transportSender name="wss" class="org.wso2.carbon.websocket.transport.WebsocketTransportSender">
              <parameter name="ws.outflow.dispatch.sequence" locked="false">outflowDispatchSeq</parameter>
              <parameter name="ws.outflow.dispatch.fault.sequence" locked="false">outflowFaultSeq</parameter>
              <parameter name="ws.trust.store" locked="false">
                  <ws.trust.store.location>repository/resources/security/client-truststore.jks</ws.trust.store.location>
                  <ws.trust.store.Password>wso2carbon</ws.trust.store.Password>
              </parameter>
          </transportSender>-->
      
      
          <!-- ================================================= -->
          <!--             Global Engaged Modules                -->
          <!-- ================================================= -->
      
          <!-- Comment this out to disable Addressing -->
          <module ref="addressing"/>
      
          <!-- ================================================= -->
          <!--                Clustering                         -->
          <!-- ================================================= -->
          <!--
           To enable clustering for this node, set the value of "enable" attribute of the "clustering"
           element to "true". The initialization of a node in the cluster is handled by the class
           corresponding to the "class" attribute of the "clustering" element. It is also responsible for
           getting this node to join the cluster.
           -->
          <clustering class="org.wso2.carbon.core.clustering.hazelcast.HazelcastClusteringAgent"
                      enable="true">
      
              <!-- Parameter to differentiate clustering mode, Default value will be "nonWorkerManager" in which
               case the all nodes of the cluster run schedule tasks-->
              <parameter name="clusteringPattern">nonWorkerManager</parameter>
      
              <!--
                 This parameter indicates whether the cluster has to be automatically initalized
                 when the AxisConfiguration is built. If set to "true" the initialization will not be
                 done at that stage, and some other party will have to explictly initialize the cluster.
              -->
              <parameter name="AvoidInitiation">true</parameter>
      
              <!--
                 The membership scheme used in this setup. The only values supported at the moment are
                 "multicast" and "wka"
      
                 1. multicast - membership is automatically discovered using multicasting
                 2. wka - Well-Known Address based multicasting. Membership is discovered with the help
                          of one or more nodes running at a Well-Known Address. New members joining a
                          cluster will first connect to a well-known node, register with the well-known node
                          and get the membership list from it. When new members join, one of the well-known
                          nodes will notify the others in the group. When a member leaves the cluster or
                          is deemed to have left the cluster, it will be detected by the Group Membership
                          Service (GMS) using a TCP ping mechanism.
              -->
              <parameter name="membershipScheme">kubernetes</parameter>
              <!--<parameter name="licenseKey">xxx</parameter>-->
              <!--<parameter name="mgtCenterURL">http://localhost:8081/mancenter/</parameter>-->
      
              <!--
               The clustering domain/group. Nodes in the same group will belong to the same multicast
               domain. There will not be interference between nodes in different groups.
              -->
              <parameter name="domain">wso2.ei.domain</parameter>
      
              <!-- The multicast address to be used -->
              <!--<parameter name="mcastAddress">228.0.0.4</parameter>-->
      
              <!-- The multicast port to be used -->
              <parameter name="mcastPort">45564</parameter>
      
              <parameter name="mcastTTL">100</parameter>
      
              <parameter name="mcastTimeout">60</parameter>
      
              <!--
                 The IP address of the network interface to which the multicasting has to be bound to.
                 Multicasting would be done using this interface.
              -->
              <!--
                  <parameter name="mcastBindAddress">127.0.0.1</parameter>
              -->
              <!-- The host name or IP address of this member -->
      
              <parameter name="localMemberHost">integrator</parameter>
      
              <!--
                  The bind adress of this member. The difference between localMemberHost & localMemberBindAddress
                  is that localMemberHost is the one that is advertised by this member, while localMemberBindAddress
                  is the address to which this member is bound to.
              -->
              <!--
              <parameter name="localMemberBindAddress">127.0.0.1</parameter>
              -->
      
              <!--
              The TCP port used by this member. This is the port through which other nodes will
              contact this member
               -->
              <parameter name="localMemberPort">4100</parameter>
      
              <!--
                  The bind port of this member. The difference between localMemberPort & localMemberBindPort
                  is that localMemberPort is the one that is advertised by this member, while localMemberBindPort
                  is the port to which this member is bound to.
              -->
              <!--
              <parameter name="localMemberBindPort">4001</parameter>
              -->
      
              <!--
              Properties specific to this member
              -->
              <parameter name="properties">
                  <property name="backendServerURL" value="https://${hostName}:${httpsPort}/services/"/>
                  <property name="mgtConsoleURL" value="https://${hostName}:${httpsPort}/"/>
       	    <!-- Manger Setup with Port Mapping-->
      	    <!--property name="port.mapping.8280" value="9764"/>
                  <property name="port.mapping.8243" value="9444"/>
                  <property name="subDomain" value="mgt"/-->
      
      	    <!-- Worker Setup-->
      	    <!--property name="subDomain" value="worker"/-->
              </parameter>
      
              <parameter name="membershipSchemeClassName">org.wso2.carbon.membership.scheme.kubernetes.KubernetesMembershipScheme</parameter>
              <parameter name="KUBERNETES_NAMESPACE">${OPENSHIFT_PROJECT_NAME}</parameter>
              <parameter name="KUBERNETES_SERVICES">wso2ei-pattern-2-integrator-service</parameter>
              <parameter name="KUBERNETES_MASTER_SKIP_SSL_VERIFICATION">true</parameter>
              <parameter name="USE_DNS">false</parameter>
      
              <!--
              Enable the groupManagement entry if you need to run this node as a cluster manager.
              Multiple application domains with different GroupManagementAgent implementations
              can be defined in this section.
              -->
              <groupManagement enable="false">
                  <applicationDomain name="wso2.esb.domain"
                                     description="EI group"
                                     agent="org.wso2.carbon.core.clustering.hazelcast.HazelcastGroupManagementAgent"
                                     subDomain="worker"
                                     port="2222"/>
              </groupManagement>
          </clustering>
      
          <!-- ================================================= -->
          <!--                   Transactions                    -->
          <!-- ================================================= -->
      
          <!--
              Uncomment and configure the following section to enable transactions support 
          -->
          <!--<transaction timeout="30000">
              <parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
              <parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
              <parameter name="UserTransactionJNDIName">UserTransaction</parameter>
              <parameter name="TransactionManagerJNDIName">TransactionManager</parameter>
          </transaction>-->
      
          <!-- ================================================= -->
          <!--                    Phases                         -->
          <!-- ================================================= -->
      
          <phaseOrder type="InFlow">
              <!--  System pre defined phases       -->
              <!--
                 The MsgInObservation phase is used to observe messages as soon as they are
                 received. In this phase, we could do some things such as SOAP message tracing & keeping
                 track of the time at which a particular message was received
      
                 NOTE: This should be the very first phase in this flow
              -->
              <phase name="MsgInObservation">
      	    <handler name="TraceMessageBuilderDispatchHandler"
                           class="org.apache.synapse.transport.passthru.util.TraceMessageBuilderDispatchHandler"/>
      	</phase>
              <phase name="Validation"/>
              <phase name="Transport">
                  <handler name="IntegratorStatefulHandler" class="org.wso2.carbon.integrator.core.handler.IntegratorStatefulHandler">
                      <order phase="Transport"/>
                      <handler name="JSONMessageHandler"
                               class="org.apache.axis2.json.gson.JSONMessageHandler" />
                  </handler>
         	        <handler name="CarbonContextConfigurator"
                           class="org.wso2.carbon.mediation.initializer.handler.CarbonContextConfigurator"/>
                  <handler name="RelaySecuirtyMessageBuilderDispatchandler"
                           class="org.apache.synapse.transport.passthru.util.RelaySecuirtyMessageBuilderDispatchandler"/>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
                      <order phase="Transport"/>
                  </handler>
                  <!--handler name="SMTPFaultHandler"
                           class="org.wso2.carbon.core.transports.smtp.SMTPFaultHandler">
                      <order phase="Transport"/>
                  </handler-->
              </phase>
              <phase name="Addressing">
                  <handler name="AddressingBasedDispatcher"
                           class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
                      <order phase="Addressing"/>
                  </handler>
              </phase>
              <phase name="Security"/>
              <phase name="PreDispatch">
                  <!--Uncomment following handler to enable logging in EI log UI-->
                  <!--<handler name="TenantDomainSetter"-->
                           <!--class="org.wso2.carbon.utils.logging.handler.TenantDomainSetter"/>-->
              </phase>
              <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
                  <handler name="IntegratorStatefulHandler" class="org.wso2.carbon.integrator.core.handler.IntegratorStatefulHandler"/>
                  <handler name="JSONMessageHandler" class="org.apache.axis2.json.gson.JSONMessageHandler" />
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
                  <handler name="RequestURIOperationDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher"/>
                  <handler name="SOAPMessageBodyBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
      
                  <handler name="HTTPLocationBasedDispatcher"
                           class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
                  <handler name="MultitenantDispatcher"
                           class="org.wso2.carbon.tenant.dispatcher.MultitenantDispatcher"/>
                  <handler name="SynapseDispatcher"
                           class="org.apache.synapse.core.axis2.SynapseDispatcher"/>
                  <handler name="SynapseMustUnderstandHandler"
                           class="org.apache.synapse.core.axis2.SynapseMustUnderstandHandler"/>
              </phase>
              <!--  System pre defined phases       -->
              <phase name="RMPhase"/>
              <phase name="OpPhase"/>
              <phase name="AuthPhase"/>
              <phase name="MUPhase"/>
              <!-- After Postdispatch phase module author or or service author can add any phase he want -->
              <phase name="OperationInPhase"/>
          </phaseOrder>
      
          <phaseOrder type="OutFlow">
              <!-- Handlers related to unified-endpoint component are added to the UEPPhase -->
              <phase name="UEPPhase" />
              <!--      user can add his own phases to this area  -->
              <phase name="RMPhase"/>
              <phase name="MUPhase"/>
              <phase name="OpPhase"/>
              <phase name="OperationOutPhase"/>
              <!--system predefined phase-->
              <!--these phase will run irrespective of the service-->
              <phase name="PolicyDetermination"/>
              <phase name="PTSecurityOutPhase">
      		<handler name="RelaySecuirtyMessageBuilderDispatchandler"
                           class="org.apache.synapse.transport.passthru.util.RelaySecuirtyMessageBuilderDispatchandler"/>
      	    </phase>
              <phase name="MessageOut"/>
              <phase name="Security"/>
      
              <!--
                 The MsgOutObservation phase is used to observe messages just before the
                 responses are sent out. In this phase, we could do some things such as SOAP message
                 tracing & keeping track of the time at which a particular response was sent.
      
                 NOTE: This should be the very last phase in this flow
              -->
              <phase name="MsgOutObservation"/>
          </phaseOrder>
      
          <phaseOrder type="InFaultFlow">
              <!--
                 The MsgInObservation phase is used to observe messages as soon as they are
                 received. In this phase, we could do some things such as SOAP message tracing & keeping
                 track of the time at which a particular message was received
      
                 NOTE: This should be the very first phase in this flow
              -->
              <phase name="MsgInObservation"/>
              <phase name="Validation"/>
              <phase name="Transport">
                  <handler name="IntegratorStatefulHandler" class="org.wso2.carbon.integrator.core.handler.IntegratorStatefulHandler">
                      <order phase="Transport"/>
                      <handler name="JSONMessageHandler"
                               class="org.apache.axis2.json.gson.JSONMessageHandler" />
                  </handler>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
                      <order phase="Transport"/>
                  </handler>
              </phase>
              <phase name="Addressing">
                  <handler name="AddressingBasedDispatcher"
                           class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
                      <order phase="Addressing"/>
                  </handler>
              </phase>
              <phase name="Security"/>
              <phase name="PreDispatch"/>
              <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
                  <handler name="IntegratorStatefulHandler" class="org.wso2.carbon.integrator.core.handler.IntegratorStatefulHandler"/>
                  <handler name="SOAPActionBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
                  <handler name="RequestURIOperationDispatcher"
                           class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher"/>
                  <handler name="SOAPMessageBodyBasedDispatcher"
                           class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
      
                  <handler name="HTTPLocationBasedDispatcher"
                           class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
              </phase>
              <!--      user can add his own phases to this area  -->
              <phase name="RMPhase"/>
              <phase name="OpPhase"/>
              <phase name="MUPhase"/>
              <phase name="OperationInFaultPhase"/>
          </phaseOrder>
      
          <phaseOrder type="OutFaultFlow">
              <!-- Handlers related to unified-endpoint component are added to the UEPPhase -->
              <phase name="UEPPhase" />
              <!--      user can add his own phases to this area  -->
              <phase name="RMPhase"/>
              <!-- Must Understand Header processing phase -->
              <phase name="MUPhase"/>
              <phase name="OperationOutFaultPhase"/>
              <phase name="PolicyDetermination"/>
              <phase name="MessageOut"/>
              <phase name="Security"/>
      	<phase name="Transport"/>
              <!--
                 The MsgOutObservation phase is used to observe messages just before the
                 responses are sent out. In this phase, we could do some things such as SOAP message
                 tracing & keeping track of the time at which a particular response was sent.
      
                 NOTE: This should be the very last phase in this flow
              -->
              <phase name="MsgOutObservation"/>
          </phaseOrder>
      
      </axisconfig>

# ConfigMap integrator-conf-datasources
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: integrator-conf-datasources
  data:
    master-datasources.xml: |-
      <?xml version='1.0' encoding='UTF-8'?>
      <datasources-configuration xmlns:svns="http://org.wso2.securevault/configuration">
        <providers>
          <provider>org.wso2.carbon.ndatasource.rdbms.RDBMSDataSourceReader</provider>
        </providers>
        <datasources>
          <datasource>
            <name>WSO2_CARBON_DB</name>
            <description>The datasource used for registry and user manager</description>
            <jndiConfig>
              <name>jdbc/WSO2CarbonDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:h2:./repository/database/WSO2CARBON_DB;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=60000</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>org.h2.Driver</driverClassName>
                <maxActive>50</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
                <defaultAutoCommit>false</defaultAutoCommit>
              </configuration>
            </definition>
          </datasource>
          <!-- For an explanation of the properties, see: http://people.apache.org/~fhanik/jdbc-pool/jdbc-pool.html -->
          <!--datasource>
                  <name>SAMPLE_DATA_SOURCE</name>
                  <jndiConfig>
                      <name></name>
                      <environment>
                          <property name="java.naming.factory.initial"></property>
                          <property name="java.naming.provider.url"></property>
                      </environment>
                  </jndiConfig>
                  <definition type="RDBMS">
                      <configuration>
      
                          <defaultAutoCommit></defaultAutoCommit>
                          <defaultReadOnly></defaultReadOnly>
                          <defaultTransactionIsolation>NONE|READ_COMMITTED|READ_UNCOMMITTED|REPEATABLE_READ|SERIALIZABLE</defaultTransactionIsolation>
                          <defaultCatalog></defaultCatalog>
                          <username></username>
                          <password svns:secretAlias="WSO2.DB.Password"></password>
                          <maxActive></maxActive>
                          <maxIdle></maxIdle>
                          <initialSize></initialSize>
                          <maxWait></maxWait>
      
                          <dataSourceClassName>com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</dataSourceClassName>
                          <dataSourceProps>
                              <property name="url">jdbc:mysql://localhost:3306/Test1</property>
                              <property name="user">root</property>
                              <property name="password">123</property>
                          </dataSourceProps>
      
                      </configuration>
                  </definition>
              </datasource-->
          <datasource>
            <name>WSO2_CONFIG_DB</name>
            <description>The datasource used for config registry</description>
            <jndiConfig>
              <name>jdbc/WSO2ConfigDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2EI_INTEGRATOR_CONFIG_GOV_DB?autoReconnect=true&amp;useSSL=false</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>com.mysql.jdbc.Driver</driverClassName>
                <maxActive>80</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
              </configuration>
            </definition>
          </datasource>
          <datasource>
            <name>WSO2_USER_DB</name>
            <description>The datasource is used for user management and userstore</description>
            <jndiConfig>
              <name>jdbc/WSO2UserDB</name>
            </jndiConfig>
            <definition type="RDBMS">
              <configuration>
                <url>jdbc:mysql://wso2ei-rdbms-service-mysql:3306/WSO2EI_USER_DB?autoReconnect=true&amp;useSSL=false</url>
                <username>wso2carbon</username>
                <password>wso2carbon</password>
                <driverClassName>com.mysql.jdbc.Driver</driverClassName>
                <maxActive>50</maxActive>
                <maxWait>60000</maxWait>
                <testOnBorrow>true</testOnBorrow>
                <validationQuery>SELECT 1</validationQuery>
                <validationInterval>30000</validationInterval>
              </configuration>
            </definition>
          </datasource>
        </datasources>
      </datasources-configuration>

# ConfigMap integrator-conf-entrypoint
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: integrator-conf-entrypoint
  data:
    docker-entrypoint.sh: |
      #!/bin/bash

      set -e

      # volume mounts
      config_volume=${WORKING_DIRECTORY}/wso2-config-volume
      artifact_volume=${WORKING_DIRECTORY}/wso2-artifact-volume

      # check if the WSO2 non-root user home exists
      test ! -d ${WORKING_DIRECTORY} && echo "WSO2 Docker non-root user home does not exist" && exit 1

      # check if the WSO2 product home exists
      test ! -d ${WSO2_SERVER_HOME} && echo "WSO2 Docker product home does not exist" && exit 1

      # copy any configuration changes mounted to config_volume
      test -d ${config_volume} && [[ "$(ls -A ${config_volume})" ]] && cp -RL ${config_volume}/* ${WSO2_SERVER_HOME}/
      # copy any artifact changes mounted to artifact_volume
      test -d ${artifact_volume} && [[ "$(ls -A ${artifact_volume})" ]] && cp -RL ${artifact_volume}/* ${WSO2_SERVER_HOME}/

      # make any node specific configuration changes
      # for example, set the Docker container IP as the `localMemberHost` under axis2.xml clustering configurations (effective only when clustering is enabled)
      sed -i "s#<parameter\ name=\"localMemberHost\".*<\/parameter>#<parameter\ name=\"localMemberHost\">${NODE_IP}<\/parameter>#" ${WSO2_SERVER_HOME}/conf/axis2/axis2.xml

      # start WSO2 Carbon server
      sh ${WSO2_SERVER_HOME}/bin/integrator.sh "$@"

# ConfigMap integrator-conf
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: integrator-conf
  data:
    carbon.xml: |-
      <?xml version='1.0' encoding='ISO-8859-1' standalone='no'?>
      <!--
          This is the main server configuration file
      
          ${carbon.home} represents the carbon.home system property.
          Other system properties can be specified in a similar manner.
      -->
      <Server xmlns="http://wso2.org/projects/carbon/carbon.xml">
        <!--
             Product Name
          -->
        <Name>WSO2 Enterprise Integrator</Name>
        <!--
             machine readable unique key to identify each product
          -->
        <ServerKey>EI</ServerKey>
        <!--
             Product Version
          -->
        <Version>6.6.0</Version>
        <!--
             Host name or IP address of the machine hosting this server
             e.g. www.wso2.org, 192.168.1.10
             This is will become part of the End Point Reference of the
             services deployed on this server instance.
          -->
        <!--HostName>www.wso2.org</HostName-->
        <!--
          Host name to be used for the Carbon management console
          -->
        <!--MgtHostName>mgt.wso2.org</MgtHostName-->
        <!--
              The URL of the back end server. This is where the admin services are hosted and
              will be used by the clients in the front end server.
              This is required only for the Front-end server. This is used when seperating BE server from FE server
             -->
        <ServerURL>local:/${carbon.context}/services/</ServerURL>
        <!--
          <ServerURL>https://${carbon.local.ip}:${carbon.management.port}${carbon.context}/services/</ServerURL>
          -->
        <!--
           The URL of the index page. This is where the user will be redirected after signing in to the
           carbon server.
           -->
        <!-- IndexPageURL>/carbon/admin/index.jsp</IndexPageURL-->
        <!--
          For cApp deployment, we have to identify the roles that can be acted by the current server.
          The following property is used for that purpose. Any number of roles can be defined here.
          Regular expressions can be used in the role.
          Ex : <Role>.*</Role> means this server can act any role
          -->
        <ServerRoles>
          <Role>EnterpriseIntegrator</Role>
          <Role>EnterpriseServiceBus</Role>
          <Role>DataServicesServer</Role>
        </ServerRoles>
        <!-- uncommnet this line to subscribe to a bam instance automatically -->
        <!--<BamServerURL>https://bamhost:bamport/services/</BamServerURL>-->
        <!--
             The fully qualified name of the server
          -->
        <Package>org.wso2.carbon</Package>
        <!--
             Webapp context root of WSO2 Carbon management console.
          -->
        <WebContextRoot>/</WebContextRoot>
        <!--
          	Proxy context path is a useful parameter to add a proxy path when a Carbon server is fronted by reverse proxy. In addtion
              to the proxy host and proxy port this parameter allows you add a path component to external URLs. e.g.
           		URL of the Carbon server -> https://10.100.1.1:9443/carbon
         		URL of the reverse proxy -> https://prod.abc.com/appserver/carbon
      
         	appserver - proxy context path. This specially required whenever you are generating URLs to displace in
         	Carbon UI components.
          -->
        <!--
          	<MgtProxyContextPath></MgtProxyContextPath>
          	<ProxyContextPath></ProxyContextPath>
          -->
        <!-- In-order to  get the registry http Port from the back-end when the default http transport is not the same-->
        <!--RegistryHttpPort>9763</RegistryHttpPort-->
        <!--
          Number of items to be displayed on a management console page. This is used at the
          backend server for pagination of various items.
          -->
        <ItemsPerPage>15</ItemsPerPage>
        <!-- The endpoint URL of the cloud instance management Web service -->
        <!--<InstanceMgtWSEndpoint>https://ec2.amazonaws.com/</InstanceMgtWSEndpoint>-->
        <!--
             Ports used by this server
          -->
        <Ports>
          <!-- Ports offset. This entry will set the value of the ports defined below to
               the define value + Offset.
               e.g. Offset=2 and HTTPS port=9443 will set the effective HTTPS port to 9445
               -->
          <Offset>0</Offset>
          <!-- The JMX Ports -->
          <JMX>
            <!--The port RMI registry is exposed-->
            <RMIRegistryPort>9999</RMIRegistryPort>
            <!--The port RMI server should be exposed-->
            <RMIServerPort>11111</RMIServerPort>
          </JMX>
          <!-- Embedded LDAP server specific ports -->
          <EmbeddedLDAP>
            <!-- Port which embedded LDAP server runs -->
            <LDAPServerPort>10389</LDAPServerPort>
            <!-- Port which KDC (Kerberos Key Distribution Center) server runs -->
            <KDCServerPort>8000</KDCServerPort>
          </EmbeddedLDAP>
          <!-- 
                   Override datasources JNDIproviderPort defined in bps.xml and datasources.properties files
      	-->
          <!--<JNDIProviderPort>2199</JNDIProviderPort>-->
          <!--Override receive port of thrift based entitlement service.-->
          <ThriftEntitlementReceivePort>10500</ThriftEntitlementReceivePort>
          <!--
           This is the proxy port of the worker cluster. These need to be configured in a scenario where
           manager node is not exposed through the load balancer through which the workers are exposed
           therefore doesn't have a proxy port.
          <WorkerHttpProxyPort>80</WorkerHttpProxyPort>
          <WorkerHttpsProxyPort>443</WorkerHttpsProxyPort>
          -->
        </Ports>
        <!--
              JNDI Configuration
          -->
        <JNDI>
          <!-- 
                   The fully qualified name of the default initial context factory
              -->
          <DefaultInitialContextFactory>org.wso2.carbon.tomcat.jndi.CarbonJavaURLContextFactory</DefaultInitialContextFactory>
          <!-- 
                   The restrictions that are done to various JNDI Contexts in a Multi-tenant environment 
              -->
          <Restrictions>
            <!--
                      Contexts that will be available only to the super-tenant
                  -->
            <!-- <SuperTenantOnly>
                      <UrlContexts>
                          <UrlContext>
                              <Scheme>foo</Scheme>
                          </UrlContext>
                          <UrlContext>
                              <Scheme>bar</Scheme>
                          </UrlContext>
                      </UrlContexts>
                  </SuperTenantOnly> -->
            <!-- 
                      Contexts that are common to all tenants
                  -->
            <AllTenants>
              <UrlContexts>
                <UrlContext>
                  <Scheme>java</Scheme>
                </UrlContext>
                <!-- <UrlContext>
                              <Scheme>foo</Scheme>
                          </UrlContext> -->
              </UrlContexts>
            </AllTenants>
            <!-- 
                       All other contexts not mentioned above will be available on a per-tenant basis 
                       (i.e. will not be shared among tenants)
                  -->
          </Restrictions>
        </JNDI>
        <!--
              Property to determine if the server is running an a cloud deployment environment.
              This property should only be used to determine deployment specific details that are
              applicable only in a cloud deployment, i.e when the server deployed *-as-a-service.
          -->
        <IsCloudDeployment>false</IsCloudDeployment>
        <!--
      	Property to determine whether usage data should be collected for metering purposes
          -->
        <EnableMetering>false</EnableMetering>
        <!-- The Max time a thread should take for execution in seconds -->
        <MaxThreadExecutionTime>600</MaxThreadExecutionTime>
        <!--
              A flag to enable or disable Ghost Deployer. By default this is set to false. That is
              because the Ghost Deployer works only with the HTTP/S transports. If you are using
              other transports, don't enable Ghost Deployer.
          -->
        <GhostDeployment>
          <Enabled>false</Enabled>
        </GhostDeployment>
        <!--
              Eager loading or lazy loading is a design pattern commonly used in computer programming which
              will initialize an object upon creation or load on-demand. In carbon, lazy loading is used to
              load tenant when a request is received only. Similarly Eager loading is used to enable load
              existing tenants after carbon server starts up. Using this feature, you will be able to include
              or exclude tenants which are to be loaded when server startup.
      
              We can enable only one LoadingPolicy at a given time.
      
              1. Tenant Lazy Loading
                 This is the default behaviour and enabled by default. With this policy, tenants are not loaded at
                 server startup, but loaded based on-demand (i.e when a request is received for a tenant).
                 The default tenant idle time is 30 minutes.
      
              2. Tenant Eager Loading
                 This is by default not enabled. It can be be enabled by un-commenting the <EagerLoading> section.
                 The eager loading configurations supported are as below. These configurations can be given as the
                 value for <Include> element with eager loading.
                      (i)Load all tenants when server startup             -   *
                      (ii)Load all tenants except foo.com & bar.com       -   *,!foo.com,!bar.com
                      (iii)Load only foo.com &  bar.com to be included    -   foo.com,bar.com
          -->
        <Tenant>
          <LoadingPolicy>
            <LazyLoading>
              <IdleTime>30</IdleTime>
            </LazyLoading>
            <!-- <EagerLoading>
                         <Include>*,!foo.com,!bar.com</Include>
                  </EagerLoading>-->
          </LoadingPolicy>
        </Tenant>
        <!--
           Caching related configurations
          -->
        <Cache>
          <!-- Default cache timeout in minutes -->
          <DefaultCacheTimeout>15</DefaultCacheTimeout>
        </Cache>
        <!--
          Axis2 related configurations
          -->
        <Axis2Config>
          <!--
                   Location of the Axis2 Services & Modules repository
      
                   This can be a directory in the local file system, or a URL.
      
                   e.g.
                   1. /home/wso2wsas/repository/ - An absolute path
                   2. repository - In this case, the path is relative to CARBON_HOME
                   3. file:///home/wso2wsas/repository/
                   4. http://wso2wsas/repository/
              -->
          <RepositoryLocation>${carbon.home}/repository/deployment/server/</RepositoryLocation>
          <!--
               Deployment update interval in seconds. This is the interval between repository listener
               executions. 
              -->
          <DeploymentUpdateInterval>15</DeploymentUpdateInterval>
          <!--
                  Location of the main Axis2 configuration descriptor file, a.k.a. axis2.xml file
      
                  This can be a file on the local file system, or a URL
      
                  e.g.
                  1. /home/repository/axis2.xml - An absolute path
                  2. conf/axis2.xml - In this case, the path is relative to CARBON_HOME
                  3. file:///home/carbon/repository/axis2.xml
                  4. http://repository/conf/axis2.xml
              -->
          <ConfigurationFile>${carbon.home}/conf/axis2/axis2.xml</ConfigurationFile>
          <!--
                ServiceGroupContextIdleTime, which will be set in ConfigurationContex
                for multiple clients which are going to access the same ServiceGroupContext
                Default Value is 30 Sec.
              -->
          <ServiceGroupContextIdleTime>30000</ServiceGroupContextIdleTime>
          <!--
                This repository location is used to crete the client side configuration
                context used by the server when calling admin services.
              -->
          <ClientRepositoryLocation>${carbon.home}/repository/deployment/client/</ClientRepositoryLocation>
          <!-- This axis2 xml is used in createing the configuration context by the FE server
               calling to BE server -->
          <clientAxis2XmlLocation>${carbon.home}/conf/axis2/axis2_client.xml</clientAxis2XmlLocation>
          <!-- If this parameter is set, the ?wsdl on an admin service will not give the admin service wsdl. -->
          <HideAdminServiceWSDLs>true</HideAdminServiceWSDLs>
          <!--WARNING-Use With Care! Uncommenting bellow parameter would expose all AdminServices in HTTP transport.
      	With HTTP transport your credentials and data routed in public channels are vulnerable for sniffing attacks. 
      	Use bellow parameter ONLY if your communication channels are confirmed to be secured by other means -->
          <!--HttpAdminServices>*</HttpAdminServices-->
        </Axis2Config>
        <!--
             The default user roles which will be created when the server
             is started up for the first time.
          -->
        <ServiceUserRoles>
          <Role>
            <Name>admin</Name>
            <Description>Default Administrator Role</Description>
          </Role>
          <Role>
            <Name>user</Name>
            <Description>Default User Role</Description>
          </Role>
        </ServiceUserRoles>
        <!-- 
            Enable following config to allow Emails as usernames. 	
          -->
        <!--EnableEmailUserName>true</EnableEmailUserName-->
        <!--
             Configurations related to Carbon Crypto Service which is a crypto framework used inside Carbon products.
          -->
        <CryptoService>
          <Enabled>true</Enabled>
          <!-- The crypto provider which is used for internal data encryption and decryption -->
          <InternalCryptoProviderClassName>org.wso2.carbon.crypto.provider.KeyStoreBasedInternalCryptoProvider</InternalCryptoProviderClassName>
          <!--
                  The crypto provider which is used for the crypto needs which come when communicating with external parties.
                  e.g. Signing, Decrypting.
              -->
          <ExternalCryptoProviderClassName>org.wso2.carbon.core.encryption.KeyStoreBasedExternalCryptoProvider</ExternalCryptoProviderClassName>
          <!--
                  The list of key resolvers which will be used based on the context when handling crypto with external parties.
                  e.g. Resolving the public key of an external entity.
              -->
          <KeyResolvers>
            <KeyResolver className="org.wso2.carbon.crypto.defaultProvider.resolver.ContextIndependentKeyResolver" priority="-1"/>
          </KeyResolvers>
        </CryptoService>
        <!--
            Security configurations
          -->
        <Security>
          <!--
                  KeyStore which will be used for encrypting/decrypting passwords
                  and other sensitive information.
              -->
          <KeyStore>
            <!-- Keystore file location-->
            <Location>${carbon.home}/repository/resources/security/wso2carbon.jks</Location>
            <!-- Keystore type (JKS/PKCS12 etc.)-->
            <Type>JKS</Type>
            <!-- Keystore password-->
            <Password>wso2carbon</Password>
            <!-- Private Key alias-->
            <KeyAlias>wso2carbon</KeyAlias>
            <!-- Private Key password-->
            <KeyPassword>wso2carbon</KeyPassword>
          </KeyStore>
          <!--
                  The KeyStore which is used for encrypting/decrypting internal data.
                  This block is read by Carbon Crypto Service.
              -->
          <InternalKeyStore>
            <!-- Keystore file location-->
            <Location>${carbon.home}/repository/resources/security/wso2carbon.jks</Location>
            <!-- Keystore type (JKS/PKCS12 etc.)-->
            <Type>JKS</Type>
            <!-- Keystore password-->
            <Password>wso2carbon</Password>
            <!-- Private Key alias-->
            <KeyAlias>wso2carbon</KeyAlias>
            <!-- Private Key password-->
            <KeyPassword>wso2carbon</KeyPassword>
          </InternalKeyStore>
          <!--
                  System wide trust-store which is used to maintain the certificates of all
                  the trusted parties.
              -->
          <TrustStore>
            <!-- trust-store file location -->
            <Location>${carbon.home}/repository/resources/security/client-truststore.jks</Location>
            <!-- trust-store type (JKS/PKCS12 etc.) -->
            <Type>JKS</Type>
            <!-- trust-store password -->
            <Password>wso2carbon</Password>
          </TrustStore>
          <!--
                  The Authenticator configuration to be used at the JVM level. We extend the
                  java.net.Authenticator to make it possible to authenticate to given servers and 
                  proxies.
              -->
          <NetworkAuthenticatorConfig>
            <!-- 
                      Below is a sample configuration for a single authenticator. Please note that
                      all child elements are mandatory. Not having some child elements would lead to
                      exceptions at runtime.
                  -->
            <!-- <Credential> -->
            <!-- 
                          the pattern that would match a subset of URLs for which this authenticator
                          would be used
                      -->
            <!-- <Pattern>regularExpression</Pattern> -->
            <!-- 
                          the type of this authenticator. Allowed values are:
                          1. server
                          2. proxy
                      -->
            <!-- <Type>proxy</Type> -->
            <!-- the username used to log in to server/proxy -->
            <!-- <Username>username</Username> -->
            <!-- the password used to log in to server/proxy -->
            <!-- <Password>password</Password> -->
            <!-- </Credential> -->
          </NetworkAuthenticatorConfig>
          <!--
               The Tomcat realm to be used for hosted Web applications. Allowed values are;
               1. UserManager
               2. Memory
      
               If this is set to 'UserManager', the realm will pick users & roles from the system's
               WSO2 User Manager. If it is set to 'memory', the realm will pick users & roles from
               CARBON_HOME/conf/tomcat/tomcat-users.xml
              -->
          <TomcatRealm>UserManager</TomcatRealm>
          <!--Option to disable storing of tokens issued by STS-->
          <DisableTokenStore>false</DisableTokenStore>
          <!--
      	 Security token store class name. If this is not set, default class will be
      	 org.wso2.carbon.security.util.SecurityTokenStore
      	-->
          <!--TokenStoreClassName>org.wso2.carbon.identity.sts.store.DBTokenStore</TokenStoreClassName-->
          <XSSPreventionConfig>
            <Enabled>true</Enabled>
            <Rule>allow</Rule>
            <Patterns>
              <!--Pattern></Pattern-->
            </Patterns>
          </XSSPreventionConfig>
        </Security>
        <!--
             The temporary work directory
          -->
        <WorkDirectory>${carbon.home}/tmp/work</WorkDirectory>
        <!--
             House-keeping configuration
          -->
        <HouseKeeping>
          <!--
                 true  - Start House-keeping thread on server startup
                 false - Do not start House-keeping thread on server startup.
                         The user will run it manually as and when he wishes.
              -->
          <AutoStart>true</AutoStart>
          <!--
                 The interval in *minutes*, between house-keeping runs
              -->
          <Interval>10</Interval>
          <!--
                The maximum time in *minutes*, temp files are allowed to live
                in the system. Files/directories which were modified more than
                "MaxTempFileLifetime" minutes ago will be removed by the
                house-keeping task
              -->
          <MaxTempFileLifetime>30</MaxTempFileLifetime>
        </HouseKeeping>
        <!--
             Configuration for handling different types of file upload & other file uploading related
             config parameters.
             To map all actions to a particular FileUploadExecutor, use
             <Action>*</Action>
          -->
        <FileUploadConfig>
          <!--
                 The total file upload size limit in MB
              -->
          <TotalFileSizeLimit>100</TotalFileSizeLimit>
          <Mapping>
            <Actions>
              <Action>keystore</Action>
              <Action>certificate</Action>
              <Action>*</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.AnyFileUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>jarZip</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.JarZipUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>dbs</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.DBSFileUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>tools</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.ToolsFileUploadExecutor</Class>
          </Mapping>
          <Mapping>
            <Actions>
              <Action>toolsAny</Action>
            </Actions>
            <Class>org.wso2.carbon.ui.transports.fileupload.ToolsAnyFileUploadExecutor</Class>
          </Mapping>
        </FileUploadConfig>
        <!-- FileNameRegEx is used to validate the file input/upload/write-out names.
          e.g.
           <FileNameRegEx>^(?!(?:CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(?:\.[^.])?$)[^&lt;&gt:"/\\|?*\x00-\x1F][^&lt;&gt:"/\\|?*\x00-\x1F\ .]$</FileNameRegEx>
          -->
        <!--<FileNameRegEx></FileNameRegEx>-->
        <!--
             Processors which process special HTTP GET requests such as ?wsdl, ?policy etc.
      
             In order to plug in a processor to handle a special request, simply add an entry to this
             section.
      
             The value of the Item element is the first parameter in the query string(e.g. ?wsdl)
             which needs special processing
             
             The value of the Class element is a class which implements
             org.wso2.carbon.transport.HttpGetRequestProcessor
          -->
        <HttpGetRequestProcessors>
          <Processor>
            <Item>info</Item>
            <Class>org.wso2.carbon.core.transports.util.InfoProcessor</Class>
          </Processor>
          <Processor>
            <Item>wsdl</Item>
            <Class>org.wso2.carbon.core.transports.util.Wsdl11Processor</Class>
          </Processor>
          <Processor>
            <Item>wsdl2</Item>
            <Class>org.wso2.carbon.core.transports.util.Wsdl20Processor</Class>
          </Processor>
          <Processor>
            <Item>xsd</Item>
            <Class>org.wso2.carbon.core.transports.util.XsdProcessor</Class>
          </Processor>
        </HttpGetRequestProcessors>
        <!-- Deployment Synchronizer Configuration. Enable value to true when running with "svn based" dep sync.
      	In master nodes you need to set both AutoCommit and AutoCheckout to true
      	and in  worker nodes set only AutoCheckout to true.
          -->
        <DeploymentSynchronizer>
          <Enabled>false</Enabled>
          <AutoCommit>false</AutoCommit>
          <AutoCheckout>true</AutoCheckout>
          <RepositoryType>svn</RepositoryType>
          <SvnUrl>http://svnrepo.example.com/repos/</SvnUrl>
          <SvnUser>username</SvnUser>
          <SvnPassword>password</SvnPassword>
          <SvnUrlAppendTenantId>true</SvnUrlAppendTenantId>
        </DeploymentSynchronizer>
        <!-- Deployment Synchronizer Configuration. Uncomment the following section when running with "registry based" dep sync.
              In master nodes you need to set both AutoCommit and AutoCheckout to true
              and in  worker nodes set only AutoCheckout to true.
          -->
        <!--<DeploymentSynchronizer>
              <Enabled>true</Enabled>
              <AutoCommit>false</AutoCommit>
              <AutoCheckout>true</AutoCheckout>
          </DeploymentSynchronizer>-->
        <!-- Mediation persistence configurations. Only valid if mediation features are available i.e. ESB -->
        <!--<MediationConfig>
              <LoadFromRegistry>false</LoadFromRegistry>
              <SaveToFile>false</SaveToFile>
              <Persistence>enabled</Persistence>
              <RegistryPersistence>enabled</RegistryPersistence>
          </MediationConfig>-->
        <!--
          Server intializing code, specified as implementation classes of org.wso2.carbon.core.ServerInitializer.
          This code will be run when the Carbon server is initialized
          -->
        <ServerInitializers>
          <!--<Initializer></Initializer>-->
        </ServerInitializers>
        <!--
          Indicates whether the Carbon Servlet is required by the system, and whether it should be
          registered
          -->
        <RequireCarbonServlet>${require.carbon.servlet}</RequireCarbonServlet>
        <!--
          Carbon H2 OSGI Configuration
          By default non of the servers start.
              name="web" - Start the web server with the H2 Console
              name="webPort" - The port (default: 8082)
              name="webAllowOthers" - Allow other computers to connect
              name="webSSL" - Use encrypted (HTTPS) connections
              name="tcp" - Start the TCP server
              name="tcpPort" - The port (default: 9092)
              name="tcpAllowOthers" - Allow other computers to connect
              name="tcpSSL" - Use encrypted (SSL) connections
              name="pg" - Start the PG server
              name="pgPort"  - The port (default: 5435)
              name="pgAllowOthers"  - Allow other computers to connect
              name="trace" - Print additional trace information; for all servers
              name="baseDir" - The base directory for H2 databases; for all servers  
          -->
        <!--H2DatabaseConfiguration>
              <property name="web" />
              <property name="webPort">8082</property>
              <property name="webAllowOthers" />
              <property name="webSSL" />
              <property name="tcp" />
              <property name="tcpPort">9092</property>
              <property name="tcpAllowOthers" />
              <property name="tcpSSL" />
              <property name="pg" />
              <property name="pgPort">5435</property>
              <property name="pgAllowOthers" />
              <property name="trace" />
              <property name="baseDir">${carbon.home}</property>
          </H2DatabaseConfiguration-->
        <!--Disabling statistics reporter by default-->
        <StatisticsReporterDisabled>true</StatisticsReporterDisabled>
        <!-- Enable accessing Admin Console via HTTP -->
        <!-- EnableHTTPAdminConsole>true</EnableHTTPAdminConsole -->
        <!--
             Default Feature Repository of WSO2 Carbon.
          -->
        <FeatureRepository>
          <RepositoryName>default repository</RepositoryName>
          <RepositoryURL>http://product-dist.wso2.com/p2/carbon/releases/wilkes/</RepositoryURL>
        </FeatureRepository>
        <!--
      	Configure API Management
         -->
        <APIManagement>
          <!--Uses the embedded API Manager by default. If you want to use an external 
      	API Manager instance to manage APIs, configure below  externalAPIManager-->
          <Enabled>true</Enabled>
          <!--Uncomment and configure API Gateway and 
      	Publisher URLs to use external API Manager instance-->
          <!--ExternalAPIManager>
      
      		<APIGatewayURL>http://localhost:8281</APIGatewayURL>
      		<APIPublisherURL>http://localhost:8281/publisher</APIPublisherURL>
      
      	</ExternalAPIManager-->
          <LoadAPIContextsInServerStartup>true</LoadAPIContextsInServerStartup>
        </APIManagement>
        <!-- 
          Configuring EI analytics server details. 
          mediation.flow.statistics.enable has to be set to true in synapse.properties 
          file in addition to these configs
          -->
        <Analytics>
          <!-- 
                  Server URL of the analytics server. Events are published to this URL
                  This url is in the format <protocol>://<hostname or ip>:<port>. 
                  For the HA mode use a comma seperated list of urls of the nalytics nodes to 
                  enable publishing events to the servers in a round robin manner.
                  e.g.; tcp://analytics-server-1:7612,tcp://analytics-server-2:7612
               -->
          <ServerURL>tcp://wso2ei-pattern-2-analytics-worker-service-1:7612|tcp://wso2ei-pattern-2-analytics-worker-service-2:7612</ServerURL>
          <AuthServerURL> ssl://wso2ei-pattern-2-analytics-worker-service-1:7712|ssl://wso2ei-pattern-2-analytics-worker-service-2:7712</AuthServerURL>
          <!--
                  Credentails of the admin user of the analytics server.
              -->
          <Username>admin</Username>
          <Password>admin</Password>
        </Analytics>
        <HostName>wso2ei-gateway</HostName>
        <MgtHostName>wso2ei-integrator</MgtHostName>
      </Server>   
    jndi.properties: |-
      # register some connection factories
      # connectionfactory.[jndiname] = [ConnectionURL]
      connectionfactory.QueueConnectionFactory = amqp://admin:admin@clientID/carbon?brokerlist='tcp://wso2ei-pattern-2-mb-service:5675?retries='5'&connectdelay='50''
      connectionfactory.TopicConnectionFactory = amqp://admin:admin@clientID/carbon?brokerlist='tcp://wso2ei-pattern-2-mb-service:5675?retries='5'&connectdelay='50''
      # register some queues in JNDI using the form
      # queue.[jndiName] = [physicalName]
      queue.MyQueue = example.MyQueue
      
      # register some topics in JNDI using the form
      # topic.[jndiName] = [physicalName]
      topic.MyTopic = example.MyTopic  
    registry.xml: |-
      <?xml version="1.0" encoding="ISO-8859-1"?>
      <wso2registry>
      
          <!--
          For details on configuring different config & governance registries see;
          http://wso2.org/library/tutorials/2010/04/sharing-registry-space-across-multiple-product-instances
          -->
      
          <currentDBConfig>wso2registry</currentDBConfig>
          <readOnly>false</readOnly>
          <enableCache>true</enableCache>
          <registryRoot>/</registryRoot>
      
          <dbConfig name="wso2registry">
              <dataSource>jdbc/WSO2CarbonDB</dataSource>
          </dbConfig>
      
          <!-- Configuration registry mount [start] -->
          <dbConfig name="wso2config">
              <dataSource>jdbc/WSO2ConfigDB</dataSource>
          </dbConfig>
          <remoteInstance url="https://localhost:9453/registry">
              <id>wso2config</id>
              <dbConfig>wso2config</dbConfig>
              <readOnly>false</readOnly>
              <registryRoot>/</registryRoot>
          </remoteInstance>
          <mount path="/_system/config" overwrite="true">
              <instanceId>wso2config</instanceId>
              <targetPath>/_system/config/integrator</targetPath>
          </mount>
          <mount path="/_system/governance" overwrite="true">
              <instanceId>wso2config</instanceId>
              <targetPath>/_system/governance/integrator</targetPath>
          </mount>
          <!-- Configuration registry mount [end] -->
      
          <indexingConfiguration>
              <skipCache>true</skipCache>
              <startIndexing>true</startIndexing>
              <startingDelayInSeconds>35</startingDelayInSeconds>
              <indexingFrequencyInSeconds>5</indexingFrequencyInSeconds>
              <!--number of resources submit for given indexing thread -->
              <batchSize>10</batchSize>
              <!--number of worker threads for indexing -->
              <indexerPoolSize>10</indexerPoolSize>
              <!-- location storing the time the indexing took place-->
              <lastAccessTimeLocation>/_system/local/repository/components/org.wso2.carbon.registry/indexing/lastaccesstime</lastAccessTimeLocation>
              <!-- the indexers that implement the indexer interface for a relevant media type/(s) -->
              <indexers>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.MSExcelIndexer" mediaTypeRegEx="application/vnd.ms-excel"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.MSPowerpointIndexer" mediaTypeRegEx="application/vnd.ms-powerpoint"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.MSWordIndexer" mediaTypeRegEx="application/msword"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.PDFIndexer" mediaTypeRegEx="application/pdf"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.XMLIndexer" mediaTypeRegEx="application/xml"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.XMLIndexer" mediaTypeRegEx="application/(.)+\+xml"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="application/swagger\+json"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="application/(.)+\+json"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="text/(.)+"/>
                  <indexer class="org.wso2.carbon.registry.indexing.indexer.PlainTextIndexer" mediaTypeRegEx="application/x-javascript"/>
              </indexers>
              <exclusions>
                  <exclusion pathRegEx="/_system/config/repository/dashboards/gadgets/swfobject1-5/.*[.]html"/>
                  <exclusion pathRegEx="/_system/local/repository/components/org[.]wso2[.]carbon[.]registry/mount/.*"/>
              </exclusions>
          </indexingConfiguration>
      
          <!--<handler class="org.wso2.carbon.registry.extensions.handlers.SynapseRepositoryHandler">
               <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                   <property name="mediaType">application/vnd.apache.synapse</property>
               </filter>
           </handler>
      
           <handler class="org.wso2.carbon.registry.extensions.handlers.SynapseRepositoryHandler">
               <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                   <property name="mediaType">application/vnd.apache.esb</property>
               </filter>
           </handler>
      
           <handler class="org.wso2.carbon.registry.extensions.handlers.Axis2RepositoryHandler">
               <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                   <property name="mediaType">application/vnd.apache.axis2</property>
               </filter>
           </handler>
      
           <handler class="org.wso2.carbon.registry.extensions.handlers.Axis2RepositoryHandler">
               <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                   <property name="mediaType">application/vnd.apache.wsas</property>
               </filter>
           </handler>
      
           <handler class="org.wso2.carbon.registry.extensions.handlers.WSDLMediaTypeHandler">
               <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                   <property name="mediaType">application/wsdl+xml</property>
               </filter>
           </handler>
      
           <handler class="org.wso2.carbon.registry.extensions.handlers.XSDMediaTypeHandler">
               <filter class="org.wso2.carbon.registry.core.jdbc.handlers.filters.MediaTypeMatcher">
                   <property name="mediaType">application/x-xsd+xml</property>
               </filter>
           </handler> -->
      
          <!--remoteInstance url="https://localhost:9443/registry">
              <id>instanceid</id>
              <username>username</username>
              <password>password</password>
          </remoteInstance-->
      
          <!--remoteInstance url="https://localhost:9443/registry">
              <id>instanceid</id>
              <dbConfig>wso2registry</dbConfig>
              <readOnly>false</readOnly>
              <enableCache>true</enableCache>
              <registryRoot>/</registryRoot>
          </remoteInstance-->
      
          <!--mount path="/_system/config" overwrite="true|false|virtual">
              <instanceId>instanceid</instanceId>
              <targetPath>/_system/nodes</targetPath>
          </mount-->
      
          <versionResourcesOnChange>false</versionResourcesOnChange>
      
          <!-- NOTE: You can edit the options under "StaticConfiguration" only before the startup. -->
          <staticConfiguration>
              <versioningProperties>true</versioningProperties>
              <versioningComments>true</versioningComments>
              <versioningTags>true</versioningTags>
              <versioningRatings>true</versioningRatings>
          </staticConfiguration>
      </wso2registry>    
    synapse.properties: |-
      #synapse.threads.core = 20
      #synapse.threads.max = 100
      #synapse.threads.keepalive = 5
      #synapse.threads.qlen = 10
      #synapse.threads.group = synapse-thread-group
      #synapse.threads.idprefix = SynapseWorker
      
      #inbound.threads.core = 20
      #inbound.threads.max = 100
      
      synapse.sal.endpoints.sesssion.timeout.default=600000
      synapse.global_timeout_interval=120000
      #In memory statistics cleaning state 
      statistics.clean.enable=true
      statistics.clean.interval=1000
      
      # Dependency tracking Synapse observer
      # Comment out to disable dependency management
      synapse.observers=org.wso2.carbon.mediation.dependency.mgt.DependencyTracker
      
      #preserve namespace when converting XML to JSON
      synapse.commons.json.preserve.namespace=false
      
      # User defined wsdlLocator/Schema Resolver Implementations.
      # synapse.wsdl.resolver=org.wso2.carbon.mediation.initializer.RegistryWSDLLocator
      # synapse.schema.resolver=org.wso2.carbon.mediation.initializer.RegistryXmlSchemaURIResolver
      
      # Uncomment following to support fallback XPATH 2.0 support with DOM and Saxon
      #synapse.xpath.dom.failover.enabled=true
      synapse.temp_data.chunk.size=3072
      
      # A configurator to add tenant information to the out thread local carbon context
      synapse.carbon.ext.tenant.info=org.wso2.carbon.mediation.initializer.handler.CarbonTenantInfoConfigurator
      # An initiator to initialize thread local carbon context with tenant information
      synapse.carbon.ext.tenant.info.initiator=org.wso2.carbon.mediation.initializer.handler.CarbonTenantInfoInitiator
      
      #external componenent registration for secure vault xpath funtion lookup
      synapse.xpath.func.extensions=org.wso2.carbon.mediation.security.vault.xpath.SecureVaultLookupXPathFunctionProvider
      
      #configuration for the external debugger channels if server is started in debug mode
      synapse.debugger.port.command=9005
      synapse.debugger.port.event=9006
      
      # Configuration to enable mediation flow analytics
      mediation.flow.statistics.enable=true
      mediation.flow.statistics.tracer.collect.payloads=true
      mediation.flow.statistics.tracer.collect.properties=true
      mediation.flow.statistics.event.consume.interval=1000
      mediation.flow.statistics.event.clean.interval=15000
      
      # Configuration to enable statistics globally irrespective of the individual artifact level setting
      mediation.flow.statistics.collect.all=true
      
      # Script Mediator Pool (impatcts only external scripts)
      #synapse.script.mediator.pool.size=15
    user-mgt.xml: |-
      <?xml version='1.0' encoding='UTF-8'?>
      <UserManager>
        <Realm>
          <Configuration><AddAdmin>true</AddAdmin><AdminRole>admin</AdminRole><AdminUser><UserName>admin</UserName><Password>admin</Password></AdminUser><EveryOneRoleName>everyone</EveryOneRoleName><!-- By default users in this role sees the registry root -->
                  !-- Enable username claim retrieve from the UM_USER_NAME in JDBC datasources --&gt;
                  <OverrideUsernameClaimFromInternalUsername>true</OverrideUsernameClaimFromInternalUsername>
                  <Property name="isCascadeDeleteEnabled">true</Property>
                  <Property name="dataSource">jdbc/WSO2UserDB</Property>
              </Configuration>
          <!-- Following is the configuration for internal JDBC user store. This user store manager is based on JDBC.
      	         In case if application needs to manage passwords externally set property
      	         <Property name="PasswordsExternallyManaged">true</Property>.
      	         In case if user core cache domain is needed to identify uniquely set property
      	         <Property name="UserCoreCacheIdentifier">domain</Property>.
      	         Furthermore properties, IsEmailUserName and DomainCalculation are readonly properties.
      	         Note: Do not comment within UserStoreManager tags. Cause, specific tag names are used as tokens
      	         when building configurations for products.
      	    -->
          <UserStoreManager class="org.wso2.carbon.user.core.jdbc.JDBCUserStoreManager">
            <Property name="TenantManager">org.wso2.carbon.user.core.tenant.JDBCTenantManager</Property>
            <Property name="ReadOnly">false</Property>
            <Property name="ReadGroups">true</Property>
            <Property name="WriteGroups">true</Property>
            <Property name="UsernameJavaRegEx">^[\S]{3,30}$</Property>
            <Property name="UsernameJavaScriptRegEx">^[\S]{3,30}$</Property>
            <Property name="UsernameJavaRegExViolationErrorMsg">Username pattern policy violated</Property>
            <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
            <Property name="PasswordJavaScriptRegEx">^[\S]{5,30}$</Property>
            <Property name="PasswordJavaRegExViolationErrorMsg">Password length should be within 5 to 30 characters</Property>
            <Property name="RolenameJavaRegEx">^[\S]{3,30}$</Property>
            <Property name="RolenameJavaScriptRegEx">^[\S]{3,30}$</Property>
            <Property name="CaseInsensitiveUsername">true</Property>
            <Property name="SCIMEnabled">false</Property>
            <Property name="IsBulkImportSupported">true</Property>
            <Property name="PasswordDigest">SHA-256</Property>
            <Property name="StoreSaltedPassword">true</Property>
            <Property name="MultiAttributeSeparator">,</Property>
            <Property name="MaxUserNameListLength">100</Property>
            <Property name="MaxRoleNameListLength">100</Property>
            <Property name="UserRolesCacheEnabled">true</Property>
            <Property name="UserNameUniqueAcrossTenants">false</Property>
            <Property name="LeadingOrTrailingSpaceAllowedInUserName">false</Property>
          </UserStoreManager>
          <!-- If product is using an external LDAP as the user store in READ ONLY mode, use following user manager.
      		     In case if user core cache domain is needed to identify uniquely set property
      		     <Property name="UserCoreCacheIdentifier">domain</Property>
       	    -->
          <!--UserStoreManager class="org.wso2.carbon.user.core.ldap.ReadOnlyLDAPUserStoreManager">
                  <Property name="TenantManager">org.wso2.carbon.user.core.tenant.CommonHybridLDAPTenantManager</Property>
                  <Property name="ConnectionURL">ldap://localhost:10389</Property>
                  <Property name="ConnectionName">uid=admin,ou=system</Property>
                  <Property name="ConnectionPassword">admin</Property>
                  <Property name="AnonymousBind">false</Property>
                  <Property name="UserSearchBase">ou=system</Property>
                  <Property name="UserNameAttribute">uid</Property>
                  <Property name="UserNameSearchFilter">(&amp;(objectClass=person)(uid=?))</Property>
                  <Property name="UserNameListFilter">(&amp;(objectClass=person)(!(sn=Service)))</Property>
                  <Property name="DisplayNameAttribute"/>
                  <Property name="ReadGroups">true</Property>
                  <Property name="GroupSearchBase">ou=system</Property>
                  <Property name="GroupNameAttribute">cn</Property>
                  <Property name="GroupNameSearchFilter">(&amp;(objectClass=groupOfNames)(cn=?))</Property>
                  <Property name="GroupNameListFilter">(objectClass=groupOfNames)</Property>
                  <Property name="MembershipAttribute">member</Property>
                  <Property name="BackLinksEnabled">false</Property>
                  <Property name="UsernameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
                  <Property name="RolenameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="SCIMEnabled">false</Property>
                  <Property name="PasswordHashMethod">PLAIN_TEXT</Property>
                  <Property name="MultiAttributeSeparator">,</Property>
                  <Property name="MaxUserNameListLength">100</Property>
                  <Property name="MaxRoleNameListLength">100</Property>
                  <Property name="UserRolesCacheEnabled">true</Property>
                  <Property name="ConnectionPoolingEnabled">true</Property>
                  <Property name="LDAPConnectionTimeout">5000</Property>
                  <Property name="ReadTimeout"/>
                  <Property name="RetryAttempts"/>
                  <Property name="ReplaceEscapeCharactersAtUserLogin">true</Property>
              </UserStoreManager-->
          <!-- Active directory configuration is as follows.
      	         In case if user core cache domain is needed to identify uniquely set property
      	         <Property name="UserCoreCacheIdentifier">domain</Property>
      	         There are few special properties for "Active Directory".
      	         They are :
      	         1.Referral - (comment out this property if this feature is not reuired) This enables LDAP referral support.
      	         2.BackLinksEnabled - (Do not comment, set to true or false) In some cases LDAP works with BackLinksEnabled.
      	         In which role is stored at user level. Depending on this value we need to change the Search Base within code.
      	         isADLDSRole - (Do not comment) Set to true if connecting to an AD LDS instance else set to false.
      	    -->
          <!--UserStoreManager class="org.wso2.carbon.user.core.ldap.ActiveDirectoryUserStoreManager">
                  <Property name="TenantManager">org.wso2.carbon.user.core.tenant.CommonHybridLDAPTenantManager</Property>
                  <Property name="ConnectionURL">ldaps://10.100.1.100:636</Property> 
                  <Property name="ConnectionName">CN=admin,CN=Users,DC=WSO2,DC=Com</Property>
                  <Property name="ConnectionPassword">A1b2c3d4</Property>
                  <Property name="AnonymousBind">false</Property>
                  <Property name="UserSearchBase">CN=Users,DC=WSO2,DC=Com</Property>
                  <Property name="UserEntryObjectClass">user</Property>
                  <Property name="UserNameAttribute">cn</Property>
                  <Property name="UserNameSearchFilter">(&amp;(objectClass=user)(cn=?))</Property>
                  <Property name="UserNameListFilter">(&amp;(objectClass=user)(!(sn=Service)))</Property>
                  <Property name="DisplayNameAttribute"/>
                  <Property name="ReadGroups">true</Property>
                  <Property name="WriteGroups">true</Property>
                  <Property name="GroupSearchBase">CN=Users,DC=WSO2,DC=Com</Property>
                  <Property name="GroupEntryObjectClass">group</Property>
                  <Property name="GroupNameAttribute">cn</Property>
                  <Property name="GroupNameSearchFilter">(&amp;(objectClass=group)(cn=?))</Property>
                  <Property name="GroupNameListFilter">(objectcategory=group)</Property>
                  <Property name="MembershipAttribute">member</Property>
                  <Property name="MemberOfAttribute">memberOf</Property>
                  <Property name="BackLinksEnabled">true</Property>
                  <Property name="Referral">follow</Property>
                  <Property name="UsernameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="UsernameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="UsernameJavaRegExViolationErrorMsg">Username pattern policy violated</Property>
                  <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaScriptRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaRegExViolationErrorMsg">Password length should be within 5 to 30 characters</Property>
                  <Property name="RolenameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="RolenameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="SCIMEnabled">false</Property>
                  <Property name="IsBulkImportSupported">true</Property>
                  <Property name="EmptyRolesAllowed">true</Property>
                  <Property name="PasswordHashMethod">PLAIN_TEXT</Property>
                  <Property name="MultiAttributeSeparator">,</Property>
                  <Property name="isADLDSRole">false</Property>
                  <Property name="userAccountControl">512</Property>
                  <Property name="MaxUserNameListLength">100</Property>     
                  <Property name="MaxRoleNameListLength">100</Property>                     
                  <Property name="MembershipAttributeRange">1500</Property>
                  <Property name="kdcEnabled">false</Property>
                  <Property name="defaultRealmName">WSO2.ORG</Property>
                  <Property name="UserRolesCacheEnabled">true</Property>
                  <Property name="ConnectionPoolingEnabled">false</Property>
                  <Property name="LDAPConnectionTimeout">5000</Property>
                  <Property name="ReadTimeout"/>
                  <Property name="RetryAttempts"/>
                  <Property name="StartTLSEnabled">false</Property>
              </UserStoreManager-->
          <!-- Following user manager is used by Identity Server (IS) as its default user manager.
                   IS will do token replacement when building the product. Therefore do not change the syntax.
                   If "kdcEnabled" parameter is true, IS will allow service principle management.
                   Thus "ServicePasswordJavaRegEx", "ServiceNameJavaRegEx" properties control the service name format and
                   service password formats. In case if user core cache domain is needed to identify uniquely set property
                   <Property name="UserCoreCacheIdentifier">domain</Property>
              -->
          <!--ISUserStoreManager class="org.wso2.carbon.user.core.ldap.ReadWriteLDAPUserStoreManager">
                  <Property name="TenantManager">org.wso2.carbon.user.core.tenant.CommonHybridLDAPTenantManager</Property>
                  <Property name="ConnectionURL">ldap://localhost:${Ports.EmbeddedLDAP.LDAPServerPort}</Property>
                  <Property name="ConnectionName">uid=admin,ou=system</Property>
                  <Property name="ConnectionPassword">admin</Property>
                  <Property name="AnonymousBind">false</Property>
                  <Property name="UserSearchBase">ou=Users,dc=wso2,dc=org</Property>
                  <Property name="UserEntryObjectClass">identityPerson</Property>
                  <Property name="UserNameAttribute">uid</Property>
                  <Property name="UserNameSearchFilter">(&amp;(objectClass=person)(uid=?))</Property>
                  <Property name="UserNameListFilter">(&amp;(objectClass=person)(!(sn=Service)))</Property>
                  <Property name="DisplayNameAttribute"/>
                  <Property name="ReadGroups">true</Property>
                  <Property name="WriteGroups">true</Property>
                  <Property name="GroupSearchBase">ou=Groups,dc=wso2,dc=org</Property>
                  <Property name="GroupEntryObjectClass">groupOfNames</Property>
                  <Property name="GroupNameAttribute">cn</Property>
                  <Property name="GroupNameSearchFilter">(&amp;(objectClass=groupOfNames)(cn=?))</Property>
                  <Property name="GroupNameListFilter">(objectClass=groupOfNames)</Property>
                  <Property name="MembershipAttribute">member</Property>
                  <Property name="BackLinksEnabled">false</Property>
                  <Property name="UsernameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="UsernameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="UsernameJavaRegExViolationErrorMsg">Username pattern policy violated</Property>
                  <Property name="PasswordJavaRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaScriptRegEx">^[\S]{5,30}$</Property>
                  <Property name="PasswordJavaRegExViolationErrorMsg">Password length should be within 5 to 30 characters</Property>
                  <Property name="RolenameJavaRegEx">[a-zA-Z0-9._\-|//]{3,30}$</Property>
                  <Property name="RolenameJavaScriptRegEx">^[\S]{3,30}$</Property>
                  <Property name="SCIMEnabled">true</Property>
                  <Property name="IsBulkImportSupported">true</Property>
                  <Property name="EmptyRolesAllowed">true</Property>
                  <Property name="PasswordHashMethod">PLAIN_TEXT</Property>
                  <Property name="MultiAttributeSeparator">,</Property>
                  <Property name="MaxUserNameListLength">100</Property>
                  <Property name="MaxRoleNameListLength">100</Property>
                  <Property name="kdcEnabled">false</Property>
                  <Property name="defaultRealmName">WSO2.ORG</Property>
                  <Property name="UserRolesCacheEnabled">true</Property>
                  <Property name="ConnectionPoolingEnabled">false</Property>
                  <Property name="LDAPConnectionTimeout">5000</Property>
                  <Property name="ReadTimeout"/>
                  <Property name="RetryAttempts"/>
                  <Property name="StartTLSEnabled">false</Property>
              </ISUserStoreManager-->
          <AuthorizationManager class="org.wso2.carbon.user.core.authorization.JDBCAuthorizationManager">
            <Property name="AdminRoleManagementPermissions">/permission</Property>
            <Property name="AuthorizationCacheEnabled">true</Property>
            <Property name="GetAllRolesOfUserEnabled">false</Property>
          </AuthorizationManager>
        </Realm>
      </UserManager>
      <!--
      
      ************* Description of some of the configuration properties used in user-mgt.xml *********************************
      
      DomainName -
          This property must be used by all secondary user store managers in multiple user store configuration.
          DomainName is a unique identifier given to the user store. Users must provide both the domain name and
          username at log-in as "DomainName\Username"
      
      UserRolesCacheEnabled -
          This is to indicate whether to cache role list of a user. By default it is set to true.
          You may need to disable it if user-roles are changed by external means and need to reflect
          those changes in the carbon product immediately.
      
      ReplaceEscapeCharactersAtUserLogin -
          This is to configure whether escape characters in user name needs to be replaced at user login.
          Currently the identified escape characters that needs to be replaced are '\' & '\\'
      
      UserDNPattern -
          This property will be used when authenticating users. During authentication we do a bind. But if the user is login
          with email address or some other property we need to first lookup LDAP and retrieve DN for the user.
          This involves an additional step.  If UserDNPattern is specified the DN will be constructed using the pattern
          specified in this property. Performance of this is much better than looking up DN and binding user.
      
      RoleDNPattern -
          This property will be used when checking whether user has been assigned to a given role.
          Rather than searching the role in search base, by using this property direct search can be done.
      
      PasswordHashMethod -
          This says how the password should be stored. Allowed values are as follows,
              SHA - Uses SHA digest method
              MD5 - Uses MD 5 digest method
              PLAIN_TEXT - Plain text passwords
              In addition to above this supports all digest methods supported by http://docs.oracle.com/javase/6/docs/api/java/security/MessageDigest.html.
      
      DisplayNameAttribute -
          This is to have a dedicated LDAP attribute to display an entity(User/Role) in UI, in addition to the UserNameAttribute which is used for IS-UserStore interactions.
      -->

# ServiceAccount wso2svc-account
- apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: wso2svc-account

# Secret wso2ei-rdbms-service-mysql
- apiVersion: v1
  kind: Secret
  metadata:
    name: wso2ei-rdbms-service-mysql
  type: Opaque
  data:
    mysql-root-password:  cm9vdA== 
    mysql-password:  d3NvMmNhcmJvbg==

# SecurityContextConstraints wso2svc-account
- apiVersion: security.openshift.io/v1
  kind: SecurityContextConstraints
  metadata:
    name: wso2svc-account
  runAsUser:
    type: RunAsAny
  seLinuxContext:
    type: RunAsAny
  supplementalGroups:
    type: RunAsAny
  users:
  - system:serviceaccount:${OPENSHIFT_PROJECT_NAME}:wso2svc-account
  volumes:
  - '*'

# Role endpoints-reader-role
- apiVersion: rbac.authorization.k8s.io/v1
  kind: Role
  metadata:
    name: endpoints-reader-role
  rules:
  - apiGroups: [""]
    verbs: ["get", "list"]
    resources: ["endpoints"]

# RoleBinding endpoints-reader-role-wso2-binding
- apiVersion: rbac.authorization.k8s.io/v1beta1
  kind: RoleBinding
  metadata:
    name: endpoints-reader-role-wso2-binding
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: Role
    name: endpoints-reader-role
  subjects:
    - kind: ServiceAccount
      name: wso2svc-account
      namespace: ${OPENSHIFT_PROJECT_NAME}

# PersistentVolume wso2am-mysql-db-service
- apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: wso2am-mysql-db-service
  spec:
    accessModes:
    - ReadWriteOnce
    capacity:
      storage: 8Gi
    nfs:
      path: ${NFS_SHARE_DATABASE}
      server: ${NFS_SERVER_IP}

# PersistentVolumeClaim wso2ei-rdbms-service-mysql
- apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: wso2ei-rdbms-service-mysql
  spec:
    accessModes:
    - ReadWriteOnce
    resources:
      requests:
        storage: 8Gi
    volumeMode: Filesystem

# DeploymentConfig wso2ei-rdbms-service-mysql
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: wso2ei-rdbms-service-mysql
  spec:
    replicas: 1
    selector:
      app: wso2ei-rdbms-service-mysql
    strategy:
      type: Rolling
    template:
      metadata:
        labels:
          app: wso2ei-rdbms-service-mysql
      spec:
        containers:
        - env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                key: mysql-root-password
                name: wso2ei-rdbms-service-mysql
          - name: MYSQL_PASSWORD
            valueFrom:
              secretKeyRef:
                key: mysql-password
                name: wso2ei-rdbms-service-mysql
          - name: MYSQL_USER
            value: wso2carbon
          - name: MYSQL_DATABASE
          image: mysql:5.7
          livenessProbe:
            exec:
              command:
              - sh
              - -c
              - mysqladmin ping -u root -p${MYSQL_ROOT_PASSWORD}
            failureThreshold: 3
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
          name: wso2ei-rdbms-service-mysql
          ports:
          - containerPort: 3306
            name: mysql
            protocol: TCP
          readinessProbe:
            exec:
              command:
              - sh
              - -c
              - mysqladmin ping -u root -p${MYSQL_ROOT_PASSWORD}
            failureThreshold: 3
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          resources:
            requests:
              cpu: 100m
              memory: 256Mi
          volumeMounts:
          - mountPath: /var/lib/mysql
            name: data
          - mountPath: /etc/mysql/conf.d/mysql.cnf
            name: configurations
            subPath: mysql.cnf
          - mountPath: /docker-entrypoint-initdb.d
            name: migrations
        initContainers:
        - command:
          - rm
          - -fr
          - /var/lib/mysql/lost+found
          image: busybox:1.29.3
          name: remove-lost-found
          resources:
            requests:
              cpu: 10m
              memory: 10Mi
          volumeMounts:
          - mountPath: /var/lib/mysql
            name: data
        volumes:
        - configMap:
            defaultMode: 420
            name: wso2ei-rdbms-service-mysql-configuration
          name: configurations
        - configMap:
            defaultMode: 420
            name: wso2ei-rdbms-service-mysql-initialization
          name: migrations
        - name: data
          persistentVolumeClaim:
            claimName: wso2ei-rdbms-service-mysql

# DeploymentConfig wso2ei-pattern-2-analytics-dashboard
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: wso2ei-pattern-2-analytics-dashboard
  spec:
    replicas:  1
    minReadySeconds: 30
    strategy:
      type: Rolling
    selector:
      deploymentName: wso2ei-pattern-2-analytics-dashboard
      app: wso2ei-pattern-2
      monitoring: jmx
    template:
      metadata:
        labels:
          deploymentName: wso2ei-pattern-2-analytics-dashboard
          app: wso2ei-pattern-2
          monitoring: jmx
      spec:
        initContainers: 
        - name: init-is-db
          image: busybox:1.31
          command: ['sh', '-c', 'echo -e "Checking for the availability of MySQL Server deployment"; while ! nc -z wso2ei-rdbms-service-mysql 3306; do sleep 1; printf "-"; done; echo -e "  >> MySQL Server has started";']
        containers:
        - name: wso2ei-with-analytics-dashboard   
          image: ${IMAGE_ANALYTICS_DASHBOARD}
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9643
            initialDelaySeconds: 20
            periodSeconds: 10
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9643
            initialDelaySeconds: 20
            periodSeconds: 10
          imagePullPolicy: Always
          lifecycle:
            preStop:
              exec:
                  command:  ['sh', '-c', '${WSO2_SERVER_HOME}/bin/analytics-dashboard.sh stop']
          resources:
            requests:
              cpu: ${RESOURCES_LIMITS_CPU_ANALYTICS_DASHBOARD}
              memory: ${RESOURCES_LIMITS_MEMORY_ANALYTICS_DASHBOARD}
            requests:
              cpu: ${RESOURCES_REQUEST_CPU_ANALYTICS_DASHBOARD}
              memory: ${RESOURCES_REQUEST_MEMORY_ANALYTICS_DASHBOARD}
          ports:
          - containerPort: 9643
            protocol: "TCP"
          volumeMounts:
          - name: analytics-conf-dashboard
            mountPath: "/home/wso2carbon/wso2-config-volume/wso2/analytics/conf/dashboard"
        securityContext:
          runAsUser: 802
        imagePullSecrets:
          - name: ${IMAGE_PULL_SECRET}
        volumes:
          - name: analytics-conf-dashboard
            configMap:
              name: analytics-conf-dashboard
        serviceAccountName: wso2svc-account

# DeploymentConfig wso2ei-pattern-2-analytics-worker-deployment-1
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: wso2ei-pattern-2-analytics-worker-deployment-1
  spec:
    replicas: 1
    minReadySeconds: 30
    strategy:
      type: Rolling
    selector:
      deploymentName: wso2ei-pattern-2-analytics-worker-1
      app: wso2ei-pattern-2
      monitoring: jmx
    template:
      metadata:
        labels:
          deploymentName: wso2ei-pattern-2-analytics-worker-1
          app: wso2ei-pattern-2
          monitoring: jmx
      spec:
        initContainers:
        - name: init-ei-db
          image: busybox:1.31
          command: ['sh', '-c', 'echo -e "Checking for the availability of MySQL Server deployment"; while ! nc -z wso2ei-rdbms-service-mysql 3306; do sleep 1; printf "-"; done; echo -e "  >> MySQL Server has started";']
        containers:
        - name: integrator-with-analytics-ei-analytics
          image: ${IMAGE_ANALYTICS_WORKER}
          env:
          - name: NODE_IP
            valueFrom:
              fieldRef:
                fieldPath: status.podIP
          resources:
            requests:
              cpu: ${RESOURCES_LIMITS_CPU_ANALYTICS_WORKER}
              memory: ${RESOURCES_LIMITS_MEMORY_ANALYTICS_WORKER}
            requests:
              cpu: ${RESOURCES_REQUEST_CPU_ANALYTICS_WORKER}
              memory: ${RESOURCES_REQUEST_CPU_ANALYTICS_WORKER}
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9444
            initialDelaySeconds: 20
            periodSeconds: 10
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9444
            initialDelaySeconds: 20
            periodSeconds: 10
          lifecycle:
            preStop:
              exec:
                command:  ['sh', '-c', '${WSO2_SERVER_HOME}/bin/analytics-worker.sh stop']
          imagePullPolicy: Always
          securityContext:
            runAsUser: 802
          ports:
          -
            containerPort: 9444
            protocol: TCP
          -
            containerPort: 9091
            protocol: TCP
          -
            containerPort: 9712
            protocol: TCP
          -
            containerPort: 9612
            protocol: TCP
          -
            containerPort: 7712
            protocol: TCP
          -
            containerPort: 7612
            protocol: TCP
          -
            containerPort: 7070
            protocol: TCP
          -
            containerPort: 7443
            protocol: TCP
          -
            containerPort: 9894
            protocol: TCP
          volumeMounts:
            - name: analytics-conf-worker
              mountPath: /home/wso2carbon/wso2-config-volume/wso2/analytics/conf/worker
        serviceAccountName: wso2svc-account
        imagePullSecrets:
          - name: ${IMAGE_PULL_SECRET}
        volumes:
          - name: analytics-conf-worker
            configMap:
              name: analytics-conf-worker

# DeploymentConfig wso2ei-pattern-2-analytics-worker-deployment-2
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: wso2ei-pattern-2-analytics-worker-deployment-2
  spec:
    replicas: 1
    minReadySeconds: 30
    strategy:
      type: Rolling
    selector:
      deploymentName: wso2ei-pattern-2-analytics-worker-2
      app: wso2ei-pattern-2
      monitoring: jmx
    template:
      metadata:
        labels:
          deploymentName: wso2ei-pattern-2-analytics-worker-2
          app: wso2ei-pattern-2
          monitoring: jmx
      spec:
        initContainers:
        - name: init-ei-db
          image: busybox:1.31
          command: ['sh', '-c', 'echo -e "Checking for the availability of MySQL Server deployment"; while ! nc -z wso2ei-rdbms-service-mysql 3306; do sleep 1; printf "-"; done; echo -e "  >> MySQL Server has started";']
        containers:
        - name: integrator-with-analytics-ei-analytics
          image: ${IMAGE_ANALYTICS_WORKER}
          env:
          - name: NODE_IP
            valueFrom:
              fieldRef:
                fieldPath: status.podIP
          resources:
            requests:
              cpu: ${RESOURCES_LIMITS_CPU_ANALYTICS_WORKER}
              memory: ${RESOURCES_LIMITS_MEMORY_ANALYTICS_WORKER}
            requests:
              cpu: ${RESOURCES_REQUEST_CPU_ANALYTICS_WORKER}
              memory: ${RESOURCES_REQUEST_CPU_ANALYTICS_WORKER}
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9444
            initialDelaySeconds: 20
            periodSeconds: 10
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9444
            initialDelaySeconds: 20
            periodSeconds: 10
          lifecycle:
            preStop:
              exec:
                command:  ['sh', '-c', '${WSO2_SERVER_HOME}/bin/analytics-worker.sh stop']
          imagePullPolicy: Always
          securityContext:
            runAsUser: 802
          ports:
          -
            containerPort: 9444
            protocol: TCP
          -
            containerPort: 9091
            protocol: TCP
          -
            containerPort: 9712
            protocol: TCP
          -
            containerPort: 9612
            protocol: TCP
          -
            containerPort: 7712
            protocol: TCP
          -
            containerPort: 7612
            protocol: TCP
          -
            containerPort: 7070
            protocol: TCP
          -
            containerPort: 7443
            protocol: TCP
          -
            containerPort: 9894
            protocol: TCP
          volumeMounts:
            - name: analytics-conf-worker
              mountPath: /home/wso2carbon/wso2-config-volume/wso2/analytics/conf/worker
        serviceAccountName: wso2svc-account
        imagePullSecrets:
          - name: ${IMAGE_PULL_SECRET}
        volumes:
          - name: analytics-conf-worker
            configMap:
              name: analytics-conf-worker

# DeploymentConfig wso2ei-pattern-2-mb-deployment
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: wso2ei-pattern-2-mb-deployment
  spec:
    replicas:  1
    minReadySeconds: 75
    strategy:
      type: Rolling
    selector:
      deploymentName: wso2ei-pattern-2-mb
      app: wso2ei-pattern-2
      monitoring: jmx
    template:
      metadata:
        labels:
          deploymentName: wso2ei-pattern-2-mb
          app: wso2ei-pattern-2
          monitoring: jmx
      spec:
        initContainers:
          - name: init-ei-db
            image: busybox:1.31
            command: ['sh', '-c', 'echo -e "Checking for the availability of MySQL Server deployment"; while ! nc -z wso2ei-rdbms-service-mysql 3306; do sleep 1; printf "-"; done; echo -e "  >> MySQL Server has started";']
        containers:
        - name: wso2ei-mb   
          image: ${IMAGE_EI_BROKER}
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9446
            initialDelaySeconds: 40
            periodSeconds: 10
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - nc -z localhost 9446
            initialDelaySeconds: 40
            periodSeconds: 10
          env:
            - name: NODE_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
          imagePullPolicy: Always
          command: ["/home/wso2carbon/entrypoint.sh"]
          resources:
            requests:
              cpu: ${RESOURCES_REQUEST_CPU}
              memory: ${RESOURCES_REQUEST_MEMORY}
            limits:
              cpu: ${RESOURCES_LIMITS_CPU}
              memory: ${RESOURCES_LIMITS_MEMORY}
          ports:
          - containerPort: 9766
            protocol: TCP
          - containerPort: 9446
            protocol: TCP
          - containerPort: 5675
            protocol: TCP
          - containerPort: 8675
            protocol: TCP
          - containerPort: 1886
            protocol: TCP
          - containerPort: 8836
            protocol: TCP
          - containerPort: 7614
            protocol: TCP
          volumeMounts:
          - name: mb-conf
            mountPath: /home/wso2carbon/wso2-config-volume/wso2/broker/conf
          - name: mb-conf-axis2
            mountPath: /home/wso2carbon/wso2-config-volume/wso2/broker/conf/axis2
          - name: mb-conf-datasources
            mountPath: /home/wso2carbon/wso2-config-volume/wso2/broker/conf/datasources
          - name: mb-conf-entrypoint
            mountPath: /home/wso2carbon/entrypoint.sh
            subPath: docker-entrypoint.sh
        serviceAccountName: wso2svc-account
        securityContext:
          runAsUser: 802
        imagePullSecrets:
          - name: ${IMAGE_PULL_SECRET}
        volumes:
        - name: mb-conf
          configMap:
            name: mb-conf
        - name: mb-conf-axis2
          configMap:
            name: mb-conf-axis2
        - name: mb-conf-datasources
          configMap:
            name: mb-conf-datasources
        - name: mb-conf-entrypoint
          configMap:
            name: mb-conf-entrypoint
            defaultMode: 0407

# DeploymentConfig wso2ei-pattern-2-integrator-deployment
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: wso2ei-pattern-2-integrator-deployment
  spec:
    replicas:  1
    minReadySeconds: 75
    strategy:
      type: Rolling
    selector:
      deploymentName: wso2ei-pattern-2-integrator
      app: wso2ei-pattern-2
      monitoring: jmx
    template:
      metadata:
        labels:
          deploymentName: wso2ei-pattern-2-integrator
          app: wso2ei-pattern-2
          monitoring: jmx
      spec:
        initContainers:
          - name: init-ei-db
            image: busybox:1.31
            command: ['sh', '-c', 'echo -e "Checking for the availability of MySQL Server deployment"; while ! nc -z wso2ei-rdbms-service-mysql 3306; do sleep 1; printf "-"; done; echo -e "  >> MySQL Server has started";']
          - name: init-ei-analytics
            image: busybox:1.31
            command: ['sh', '-c', 'echo -e "Checking for the availability of Analytics profile of WSO2 Enterprise Integrator deployment"; while ! nc -z wso2ei-pattern-2-analytics-worker-service-1 7712 && ! nc -z wso2ei-pattern-2-analytics-worker-service-2 7712; do sleep 1; printf "-"; done; echo -e "  >> Analytics profile of WSO2 Enterprise Integrator has started";']
          - name: init-ei-broker
            image: busybox:1.31
            command: ['sh', '-c', 'echo -e "Checking for the availability of Broker profile of WSO2 Enterprise Integrator deployment"; while ! nc -z wso2ei-pattern-2-mb-service 5675; do sleep 1; printf "-"; done; echo -e "  >> Broker profile of WSO2 Enterprise Integrator has started";']
        containers:
          - name: wso2ei-integrator
            image: ${IMAGE_EI}
            livenessProbe:
              exec:
                command:
                  - /bin/sh
                  - -c
                  - nc -z localhost 9443
              initialDelaySeconds: 40
              periodSeconds: 10
            readinessProbe:
              exec:
                command:
                  - /bin/sh
                  - -c
                  - nc -z localhost 9443
              initialDelaySeconds: 40
              periodSeconds: 10
            env:
              - name: NODE_IP
                valueFrom:
                  fieldRef:
                    fieldPath: status.podIP
            imagePullPolicy: Always
            command: ["/home/wso2carbon/entrypoint.sh"]
            resources:
              requests:
                cpu: ${RESOURCES_REQUEST_CPU}
                memory: ${RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: ${RESOURCES_LIMITS_CPU}
                memory: ${RESOURCES_LIMITS_MEMORY}
            ports:
              - containerPort: 8280
                protocol: TCP
              - containerPort: 8243
                protocol: TCP
              - containerPort: 9763
                protocol: TCP
              - containerPort: 9443
                protocol: TCP
            volumeMounts:
              - name: integrator-conf
                mountPath: /home/wso2carbon/wso2-config-volume/conf
              - name: integrator-conf-axis2
                mountPath: /home/wso2carbon/wso2-config-volume/conf/axis2
              - name: integrator-conf-datasources
                mountPath: /home/wso2carbon/wso2-config-volume/conf/datasources
              - name: integrator-conf-entrypoint
                mountPath: /home/wso2carbon/entrypoint.sh
                subPath: docker-entrypoint.sh
        serviceAccountName: wso2svc-account
        securityContext:
          runAsUser: 802
        imagePullSecrets:
          - name: ${IMAGE_PULL_SECRET}
        volumes:
          - name: integrator-conf
            configMap:
              name: integrator-conf
          - name: integrator-conf-axis2
            configMap:
              name: integrator-conf-axis2
          - name: integrator-conf-datasources
            configMap:
              name: integrator-conf-datasources
          - name: integrator-conf-entrypoint
            configMap:
              name: integrator-conf-entrypoint
              defaultMode: 0407

# Service wso2ei-rdbms-service-mysql
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-rdbms-service-mysql
  spec:
    type: ClusterIP
    ports:
    - name: mysql
      port: 3306
      targetPort: mysql
    selector:
      app: wso2ei-rdbms-service-mysql

# Service wso2ei-pattern-2-analytics-dashboard-service
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-pattern-2-analytics-dashboard-service
  spec:
    ports:
      - name: 'https'
        port: 9643
        protocol: TCP
    selector:
      deploymentName: wso2ei-pattern-2-analytics-dashboard
      app: wso2ei-pattern-2
      monitoring: jmx

# Service wso2ei-pattern-2-analytics-worker-service-1
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-pattern-2-analytics-worker-service-1
  spec:
    selector:
      deploymentName: wso2ei-pattern-2-analytics-worker-1
      app: wso2ei-pattern-2
      monitoring: jmx
    ports:
    - name: data-receiver-2
      port: 7612
      targetPort: 7612
      protocol: TCP
    - name: http-default
      port: 9091
      targetPort: 9091
      protocol: TCP
    - name: siddhi-defaul
      port: 7070
      targetPort: 8082
      protocol: TCP
    - name: siddhi-msf4j-https
      port: 7443
      targetPort: 11501
      protocol: TCP
    - name: data-receiver-1
      port: 7712
      targetPort: 7712
      protocol: TCP
    - name: http-msf4j-https
      port: 9444
      targetPort: 9444
      protocol: TCP
    - name: data-receiver-binary-1
      port: 9711
      targetPort: 9711
      protocol: TCP
    - name: data-receiver-binary-2
      port: 9611
      targetPort: 9611
      protocol: TCP

# Service wso2ei-pattern-2-analytics-worker-service-2
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-pattern-2-analytics-worker-service-2
  spec:
    selector:
      deploymentName: wso2ei-pattern-2-analytics-worker-2
      app: wso2ei-pattern-2
      monitoring: jmx
    ports:
    - name: data-receiver-2
      port: 7612
      targetPort: 7612
      protocol: TCP
    - name: http-default
      port: 9091
      targetPort: 9091
      protocol: TCP
    - name: siddhi-defaul
      port: 7070
      targetPort: 8082
      protocol: TCP
    - name: siddhi-msf4j-https
      port: 7443
      targetPort: 11501
      protocol: TCP
    - name: data-receiver-1
      port: 7712
      targetPort: 7712
      protocol: TCP
    - name: http-msf4j-https
      port: 9444
      targetPort: 9444
      protocol: TCP
    - name: data-receiver-binary-1
      port: 9711
      targetPort: 9711
      protocol: TCP
    - name: data-receiver-binary-2
      port: 9611
      targetPort: 9611
      protocol: TCP

# Service wso2ei-pattern-2-mb-service
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-pattern-2-mb-service
  spec:
    selector:
      deploymentName: wso2ei-pattern-2-mb
      app: wso2ei-pattern-2
      monitoring: jmx
    ports:
    - name: servlet-http
      port: 9766
      targetPort: 9766
      protocol: TCP
    - name: servlet-https
      port: 9446
      targetPort: 9446
      protocol: TCP
    - name: amqp-https
      port: 8675
      targetPort: 8675
      protocol: TCP
    - name: amqp-http
      port: 5675
      targetPort: 5675
      protocol: TCP
    - name: mqtt-https
      port: 8836
      targetPort: 8836
      protocol: TCP
    - name: mqtt-http
      port: 1886
      targetPort: 1886
      protocol: TCP
    - name: thrift
      port: 7614
      targetPort: 7614
      protocol: TCP

# Service wso2ei-pattern-2-integrator-gateway-service
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-pattern-2-integrator-gateway-service
  spec:
    selector:
      deploymentName: wso2ei-pattern-2-integrator
    ports:
    - name: pass-through-http
      port: 8280
      targetPort: 8280
      protocol: TCP
    - name: pass-through-https
      port: 8243
      targetPort: 8243
      protocol: TCP

# Service wso2ei-pattern-2-integrator-service
- apiVersion: v1
  kind: Service
  metadata:
    name: wso2ei-pattern-2-integrator-service
  spec:
    selector:
      deploymentName: wso2ei-pattern-2-integrator
      app: wso2ei-pattern-2
      monitoring: jmx
    ports:
    - name: servlet-http
      port: 9763
      targetPort: 9763
      protocol: TCP
    - name: servlet-https
      port: 9443
      targetPort: 9443
      protocol: TCP

# Route wso2ei-pattern-2-integrator-ingress
- apiVersion: route.openshift.io/v1
  kind: Route
  metadata:
    name: wso2ei-pattern-2-integrator-ingress
  spec:
    host: wso2ei-integrator.${OPENSHIFT_BASE_DOMAIN}
    port:
      targetPort: servlet-https
    tls:
      insecureEdgeTerminationPolicy: Redirect
      termination: passthrough
    to:
      kind: Service
      name: wso2ei-pattern-2-integrator-service

# Route wso2ei-pattern-2-integrator-gateway-tls-ingress
- apiVersion: route.openshift.io/v1
  kind: Route
  metadata:
    name: wso2ei-pattern-2-integrator-gateway-tls-ingress
  spec:
    host: wso2ei-gateway.${OPENSHIFT_BASE_DOMAIN}
    port:
      targetPort: pass-through-https
    tls:
      insecureEdgeTerminationPolicy: Redirect
      termination: passthrough
    to:
      kind: Service
      name: wso2ei-pattern-2-integrator-gateway-service

# Route wso2ei-pattern-2-mb-ingress
- apiVersion: route.openshift.io/v1
  kind: Route
  metadata:
    name: wso2ei-pattern-2-mb-ingress
  spec:
    host: wso2ei-broker.${OPENSHIFT_BASE_DOMAIN}
    port:
      targetPort: servlet-https
    tls:
      insecureEdgeTerminationPolicy: Redirect
      termination: passthrough
    to:
      kind: Service
      name: wso2ei-pattern-2-mb-service

# Route wso2ei-analytics-dashboard-ingress
- apiVersion: route.openshift.io/v1
  kind: Route
  metadata:
    name: wso2ei-analytics-dashboard-ingress
  spec:
    host: wso2ei-analytics-dashboard.${OPENSHIFT_BASE_DOMAIN}
    port:
      targetPort: https
    tls:
      insecureEdgeTerminationPolicy: Redirect
      termination: passthrough
    to:
      kind: Service
      name: wso2ei-pattern-2-analytics-dashboard-service

parameters:
- name: OPENSHIFT_PROJECT_NAME
  displayName: Name of the OpenShift project
  required: true
  value: wso2

- name: OPENSHIFT_BASE_DOMAIN
  displayName: OpenShift base domain
  required: true
  value: ""

- name: IMAGE_EI
  displayName: WSO2 Enterprice Integrator image name
  required: true
  value: docker.wso2.com/wso2ei-integrator:6.6.0

- name: IMAGE_EI_BROKER
  displayName: WSO2 Enterprice Integrator broker image name
  required: true
  value: docker.wso2.com/wso2ei-broker:6.6.0

- name: IMAGE_ANALYTICS_WORKER
  displayName: WSO2 Analytics Worker image name
  required: true
  value: docker.wso2.com/wso2ei-analytics-worker:6.6.0

- name: IMAGE_ANALYTICS_DASHBOARD
  displayName: WSO2 Analytics dashboard image name
  required: true
  value: docker.wso2.com/wso2ei-analytics-dashboard:6.6.0

- name: IMAGE_PULL_SECRET
  displayName: WSO2 Subscription Credentials
  required: true
  value: wso2ei-deployment-creds

- name: NFS_SERVER_IP
  displayName: NFS Server IP
  required: true
  value: ""

- name: NFS_SHARE_DATABASE
  displayName: NFS Share Path for database
  required: true
  value: ""

- name: RESOURCES_LIMITS_CPU
  displayName: Set a CPU resource limits for integrator and broker
  required: true
  value: '2000m'

- name: RESOURCES_LIMITS_MEMORY
  displayName: Set a memory resource limits limits for integrator and broker
  required: true
  value: '2Gi'

- name: RESOURCES_REQUEST_CPU
  displayName: Set a minimum CPU resource limits limits for integrator and broker
  required: true
  value: '1000m'

- name: RESOURCES_REQUEST_MEMORY
  displayName: Set a minimum memory resource limits limits for integrator and broker
  required: true
  value: '1Gi'

- name: RESOURCES_LIMITS_CPU_ANALYTICS_WORKER
  displayName: Set a CPU resource limits for analytics worker
  required: true
  value: '2000m'

- name: RESOURCES_LIMITS_MEMORY_ANALYTICS_WORKER
  displayName: Set a memory resource limits for analytics worker
  required: true
  value: '4Gi'

- name: RESOURCES_REQUEST_CPU_ANALYTICS_WORKER
  displayName: Set a minimum CPU resource limits for analytics worker
  required: true
  value: '2000m'

- name: RESOURCES_REQUEST_MEMORY_ANALYTICS_WORKER
  displayName: Set a minimum memory resource limits for analytics worker
  required: true
  value: '4Gi'

- name: RESOURCES_LIMITS_CPU_ANALYTICS_DASHBOARD
  displayName: Set a CPU resource limits for analytics dashboard
  required: true
  value: '2000m'

- name: RESOURCES_LIMITS_MEMORY_ANALYTICS_DASHBOARD
  displayName: Set a memory resource limits for analytics dashboard
  required: true
  value: '4Gi'

- name: RESOURCES_REQUEST_CPU_ANALYTICS_DASHBOARD
  displayName: Set a minimum CPU resource limits for analytics dashboard
  required: true
  value: '2000m'

- name: RESOURCES_REQUEST_MEMORY_ANALYTICS_DASHBOARD
  displayName: Set a minimum memory resource limits for analytics dashboard
  required: true
  value: '4Gi'

